
==================== FINAL INTERFACE ====================
2019-05-26 01:56:18.235708 UTC

interface main@main:Main [orphan module] 8002
  interface hash: 04ec497ecb9fd86a877221aa750d18f9
  ABI hash: aabf599541b66652213dd83fd5e87b39
  export-list hash: 999ba995d2a6193be2918382757dafdc
  orphan hash: a4c7aa2ab80d9e10450616487790dd34
  flag hash: c8b15b7b52cbff04d987e365817608d7
  sig of: Nothing
  used TH splices: False
  where
exports:
  Main.main
  Main.T1
  Main.T2
  Main.T3
module dependencies:
package dependencies: QuickCheck-2.9.2@QuickCheck-2.9.2-LvlomhGMxrFBkX1zwiWpQu
                      array-0.5.1.1@array-0.5.1.1 base-4.9.1.0
                      base-orphans-0.6@base-orphans-0.6-AbJ3lKVXygDCG0eeQEv8Iu
                      bifunctors-5.4.2@bifunctors-5.4.2-KcF2f75KyQm5BjgJ8WkHCw
                      binary-0.8.3.0@binary-0.8.3.0
                      bytestring-0.10.8.1@bytestring-0.10.8.1
                      chapter-exercises-0.1.0.0@chapter-exercises-0.1.0.0-MyTkAmxHPpEzugi6gUoOh
                      checkers-0.4.9.5@checkers-0.4.9.5-Dhm0rh3Bh7qFXgfQ8Df9YH
                      comonad-5.0.2@comonad-5.0.2-Fq9Xy9jdx6uIyJZn00E6Yc
                      containers-0.5.7.1@containers-0.5.7.1
                      deepseq-1.4.2.0@deepseq-1.4.2.0
                      distributive-0.5.3@distributive-0.5.3-IX4kyVcHAyoH4uFYrsjY1R
                      ghc-boot-th-8.0.2@ghc-boot-th-8.0.2 ghc-prim-0.5.0.0
                      hashable-1.2.6.1@hashable-1.2.6.1-2ZLNuHq395GGIHwEHuqZol
                      integer-gmp-1.0.0.1 pretty-1.1.3.3@pretty-1.1.3.3
                      primitive-0.6.2.0@primitive-0.6.2.0-4578caNkWQ54Gt1mxLF2Yh
                      random-1.1@random-1.1-9tceXaeYIMZ4JrKq20Egog
                      semigroupoids-5.2.1@semigroupoids-5.2.1-Db8txM8kTsI6Y49CY6g5Jn
                      tagged-0.8.5@tagged-0.8.5-1mTloBSoUxv8dqUr8XBGBt
                      template-haskell-2.11.1.0
                      text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00
                      tf-random-0.5@tf-random-0.5-CJZw1ZWS5MOJlR60HqKEZL
                      time-1.6.0.1@time-1.6.0.1 transformers-0.5.2.0@transformers-0.5.2.0
                      transformers-compat-0.5.1.4@transformers-compat-0.5.1.4-IuFogs8HAVUJBWVNMhtssu
                      unordered-containers-0.2.8.0@unordered-containers-0.2.8.0-Bp9XgxjuHxcI4tFehVMDGC
orphans: base-4.9.1.0:GHC.Base base-4.9.1.0:GHC.Float
         base-4.9.1.0:Text.Show.Functions
         base-orphans-0.6@base-orphans-0.6-AbJ3lKVXygDCG0eeQEv8Iu:Data.Orphans
         binary-0.8.3.0@binary-0.8.3.0:Data.Binary.Generic
         bytestring-0.10.8.1@bytestring-0.10.8.1:Data.ByteString.Builder
         checkers-0.4.9.5@checkers-0.4.9.5-Dhm0rh3Bh7qFXgfQ8Df9YH:Test.QuickCheck.Checkers
         hashable-1.2.6.1@hashable-1.2.6.1-2ZLNuHq395GGIHwEHuqZol:Data.Hashable.Generic
         text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text
         text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text.Lazy
         text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text.Show
         time-1.6.0.1@time-1.6.0.1:Data.Time.Calendar.Gregorian
         time-1.6.0.1@time-1.6.0.1:Data.Time.Format.Parse
         time-1.6.0.1@time-1.6.0.1:Data.Time.LocalTime.LocalTime
         transformers-0.5.2.0@transformers-0.5.2.0:Control.Monad.Trans.Error
family instance modules: base-4.9.1.0:Control.Applicative
                         base-4.9.1.0:Data.Complex base-4.9.1.0:Data.Either
                         base-4.9.1.0:Data.Functor.Compose base-4.9.1.0:Data.Functor.Const
                         base-4.9.1.0:Data.Functor.Identity
                         base-4.9.1.0:Data.Functor.Product base-4.9.1.0:Data.Functor.Sum
                         base-4.9.1.0:Data.List.NonEmpty base-4.9.1.0:Data.Monoid
                         base-4.9.1.0:Data.Semigroup base-4.9.1.0:Data.Type.Equality
                         base-4.9.1.0:Data.Version base-4.9.1.0:Data.Void
                         base-4.9.1.0:GHC.Exts base-4.9.1.0:GHC.Generics
                         base-4.9.1.0:GHC.IO.Exception base-4.9.1.0:GHC.TypeLits
                         bifunctors-5.4.2@bifunctors-5.4.2-KcF2f75KyQm5BjgJ8WkHCw:Data.Bifunctor.Biff
                         bifunctors-5.4.2@bifunctors-5.4.2-KcF2f75KyQm5BjgJ8WkHCw:Data.Bifunctor.Clown
                         bifunctors-5.4.2@bifunctors-5.4.2-KcF2f75KyQm5BjgJ8WkHCw:Data.Bifunctor.Flip
                         bifunctors-5.4.2@bifunctors-5.4.2-KcF2f75KyQm5BjgJ8WkHCw:Data.Bifunctor.Join
                         bifunctors-5.4.2@bifunctors-5.4.2-KcF2f75KyQm5BjgJ8WkHCw:Data.Bifunctor.Joker
                         bifunctors-5.4.2@bifunctors-5.4.2-KcF2f75KyQm5BjgJ8WkHCw:Data.Bifunctor.Product
                         bifunctors-5.4.2@bifunctors-5.4.2-KcF2f75KyQm5BjgJ8WkHCw:Data.Bifunctor.Tannen
                         bifunctors-5.4.2@bifunctors-5.4.2-KcF2f75KyQm5BjgJ8WkHCw:Data.Bifunctor.Wrapped
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntMap.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntSet.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Map.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Sequence
                         containers-0.5.7.1@containers-0.5.7.1:Data.Set.Base
                         ghc-boot-th-8.0.2@ghc-boot-th-8.0.2:GHC.LanguageExtensions.Type
                         pretty-1.1.3.3@pretty-1.1.3.3:Text.PrettyPrint.Annotated.HughesPJ
                         pretty-1.1.3.3@pretty-1.1.3.3:Text.PrettyPrint.HughesPJ
                         primitive-0.6.2.0@primitive-0.6.2.0-4578caNkWQ54Gt1mxLF2Yh:Control.Monad.Primitive
                         tagged-0.8.5@tagged-0.8.5-1mTloBSoUxv8dqUr8XBGBt:Data.Tagged
                         template-haskell-2.11.1.0:Language.Haskell.TH.Syntax
                         text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text
                         text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text.Lazy
                         unordered-containers-0.2.8.0@unordered-containers-0.2.8.0-Bp9XgxjuHxcI4tFehVMDGC:Data.HashMap.Base
import  -/  QuickCheck-2.9.2@QuickCheck-2.9.2-LvlomhGMxrFBkX1zwiWpQu:Test.QuickCheck 7a1791e2e66f06ce3b95a443f0d4b1ed
import  -/  QuickCheck-2.9.2@QuickCheck-2.9.2-LvlomhGMxrFBkX1zwiWpQu:Test.QuickCheck.Arbitrary 3eced3806649dec5bc33bd64f5171465
import  -/  QuickCheck-2.9.2@QuickCheck-2.9.2-LvlomhGMxrFBkX1zwiWpQu:Test.QuickCheck.Gen a986eabe5e103a4dc2686a9ffb4cae41
import  -/  base-4.9.1.0:GHC.Base c4231c43c07e46080a26bf94094c7aa1
import  -/  base-4.9.1.0:GHC.Err 3bba35a16538d33d424682ce66876cdd
import  -/  base-4.9.1.0:Prelude 22dd289b8469a8fa8dc81cab7b237771
import  -/  base-4.9.1.0:System.IO e4a64a8e3dce8616da54f0ee7104f7db
import  -/  chapter-exercises-0.1.0.0@chapter-exercises-0.1.0.0-MyTkAmxHPpEzugi6gUoOh:TraversableInstances 53464b372d99bd3f639eef1c441925a6
import  -/  checkers-0.4.9.5@checkers-0.4.9.5-Dhm0rh3Bh7qFXgfQ8Df9YH:Test.QuickCheck.Checkers 112c6b37bb972e77d1eaca37aac52a50
import  -/  checkers-0.4.9.5@checkers-0.4.9.5-Dhm0rh3Bh7qFXgfQ8Df9YH:Test.QuickCheck.Classes 299c87580860c205b01dd2588a41cffe
import  -/  ghc-prim-0.5.0.0:GHC.Classes 0bdf3d057a415ec1b84a7b1994efbe47
import  -/  ghc-prim-0.5.0.0:GHC.Types 89f8de4f08018c9177c98d979eae0e45
34eff2598e0ff1f644b76ec46f18f1ca
  $fArbitraryBig ::
    (Test.QuickCheck.Arbitrary.Arbitrary a,
     Test.QuickCheck.Arbitrary.Arbitrary b) =>
    Test.QuickCheck.Arbitrary.Arbitrary (TraversableInstances.Big a b)
  DFunId
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a
                      @ b
                      ($dArbitrary :: Test.QuickCheck.Arbitrary.Arbitrary a)
                      ($dArbitrary2 :: Test.QuickCheck.Arbitrary.Arbitrary b).
                  @ (TraversableInstances.Big a b)
                  (Main.$fArbitraryBig_$carbitrary @ a @ b $dArbitrary $dArbitrary2)
                  (Main.$fArbitraryBig_$cshrink @ a @ b $dArbitrary $dArbitrary2) -}
580981abf9982aa9881d13fbeaa8e464
  $fArbitraryBig1 ::
    (Test.QuickCheck.Arbitrary.Arbitrary a,
     Test.QuickCheck.Arbitrary.Arbitrary b) =>
    Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int -> TraversableInstances.Big a b
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><L,U(C(C1(U)),A)><L,1*U(U,U,U,1*U,A,A)><L,U>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   @ b
                   (w :: Test.QuickCheck.Arbitrary.Arbitrary a)
                   (w1 :: Test.QuickCheck.Arbitrary.Arbitrary b)
                   (w2 :: Test.QuickCheck.Random.QCGen)
                   (w3 :: GHC.Types.Int) ->
                 case Main.$w$carbitrary
                        @ a
                        @ b
                        w
                        w1
                        w2
                        w3 of ww { (#,,#) ww1 ww2 ww3 ->
                 TraversableInstances.Big @ a @ b ww1 ww2 ww3 }) -}
fce02c5138f2305815c6998c0053db0f
  $fArbitraryBig_$carbitrary ::
    (Test.QuickCheck.Arbitrary.Arbitrary a,
     Test.QuickCheck.Arbitrary.Arbitrary b) =>
    Test.QuickCheck.Gen.Gen (TraversableInstances.Big a b)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><L,U(C(C1(U)),A)><L,1*U(U,U,U,1*U,A,A)><L,U>m,
     Unfolding: InlineRule (0, True, True)
                Main.$fArbitraryBig1
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <Test.QuickCheck.Arbitrary.Arbitrary a>_R
                 ->_R <Test.QuickCheck.Arbitrary.Arbitrary b>_R
                 ->_R Sym (Test.QuickCheck.Gen.N:Gen[0]
                               <TraversableInstances.Big a b>_R)) -}
a92c0796f9c36a48cf4a0c8ae6e0b916
  $fArbitraryBig_$cshrink ::
    (Test.QuickCheck.Arbitrary.Arbitrary a,
     Test.QuickCheck.Arbitrary.Arbitrary b) =>
    TraversableInstances.Big a b -> [TraversableInstances.Big a b]
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><L,A><L,A>,
     Unfolding: InlineRule (3, True, True)
                (\ @ a
                   @ b
                   ($dArbitrary :: Test.QuickCheck.Arbitrary.Arbitrary a)
                   ($dArbitrary2 :: Test.QuickCheck.Arbitrary.Arbitrary b)
                   (ds1 :: TraversableInstances.Big a b) ->
                 GHC.Types.[] @ (TraversableInstances.Big a b)) -}
d96990ab0cf7459aab689d3cfadd47c2
  $fArbitraryBigger ::
    (Test.QuickCheck.Arbitrary.Arbitrary a,
     Test.QuickCheck.Arbitrary.Arbitrary b) =>
    Test.QuickCheck.Arbitrary.Arbitrary
      (TraversableInstances.Bigger a b)
  DFunId
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a
                      @ b
                      ($dArbitrary :: Test.QuickCheck.Arbitrary.Arbitrary a)
                      ($dArbitrary2 :: Test.QuickCheck.Arbitrary.Arbitrary b).
                  @ (TraversableInstances.Bigger a b)
                  (Main.$fArbitraryBigger_$carbitrary
                     @ a
                     @ b
                     $dArbitrary
                     $dArbitrary2)
                  (Main.$fArbitraryBigger_$cshrink
                     @ a
                     @ b
                     $dArbitrary
                     $dArbitrary2) -}
c5c363fce8af8cbf82f1209470a51857
  $fArbitraryBigger1 ::
    (Test.QuickCheck.Arbitrary.Arbitrary a,
     Test.QuickCheck.Arbitrary.Arbitrary b) =>
    Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int -> TraversableInstances.Bigger a b
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><L,U(C(C1(U)),A)><L,1*U(U,U,U,1*U,A,A)><L,U>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   @ b
                   (w :: Test.QuickCheck.Arbitrary.Arbitrary a)
                   (w1 :: Test.QuickCheck.Arbitrary.Arbitrary b)
                   (w2 :: Test.QuickCheck.Random.QCGen)
                   (w3 :: GHC.Types.Int) ->
                 case Main.$w$carbitrary1
                        @ a
                        @ b
                        w
                        w1
                        w2
                        w3 of ww { (#,,,#) ww1 ww2 ww3 ww4 ->
                 TraversableInstances.Bigger @ a @ b ww1 ww2 ww3 ww4 }) -}
a8b6997887057f1d7117be747d1abbd0
  $fArbitraryBigger_$carbitrary ::
    (Test.QuickCheck.Arbitrary.Arbitrary a,
     Test.QuickCheck.Arbitrary.Arbitrary b) =>
    Test.QuickCheck.Gen.Gen (TraversableInstances.Bigger a b)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><L,U(C(C1(U)),A)><L,1*U(U,U,U,1*U,A,A)><L,U>m,
     Unfolding: InlineRule (0, True, True)
                Main.$fArbitraryBigger1
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <Test.QuickCheck.Arbitrary.Arbitrary a>_R
                 ->_R <Test.QuickCheck.Arbitrary.Arbitrary b>_R
                 ->_R Sym (Test.QuickCheck.Gen.N:Gen[0]
                               <TraversableInstances.Bigger a b>_R)) -}
820becbdd995f4d0940bcc316854694e
  $fArbitraryBigger_$cshrink ::
    (Test.QuickCheck.Arbitrary.Arbitrary a,
     Test.QuickCheck.Arbitrary.Arbitrary b) =>
    TraversableInstances.Bigger a b
    -> [TraversableInstances.Bigger a b]
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><L,A><L,A>,
     Unfolding: InlineRule (3, True, True)
                (\ @ a
                   @ b
                   ($dArbitrary :: Test.QuickCheck.Arbitrary.Arbitrary a)
                   ($dArbitrary2 :: Test.QuickCheck.Arbitrary.Arbitrary b)
                   (ds1 :: TraversableInstances.Bigger a b) ->
                 GHC.Types.[] @ (TraversableInstances.Bigger a b)) -}
0b6e6d8f6dcab6fc98b0e5757049b121
  $fArbitraryConstant ::
    Test.QuickCheck.Arbitrary.Arbitrary a =>
    Test.QuickCheck.Arbitrary.Arbitrary
      (TraversableInstances.Constant a b)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a
                      @ b
                      ($dArbitrary :: Test.QuickCheck.Arbitrary.Arbitrary a).
                  @ (TraversableInstances.Constant a b)
                  (Main.$fArbitraryConstant_$carbitrary @ a @ b $dArbitrary)
                  (Main.$fArbitraryConstant_$cshrink @ a @ b $dArbitrary) -}
0bda11e985d044512b0ea5c87949bf6e
  $fArbitraryConstant1 ::
    Test.QuickCheck.Arbitrary.Arbitrary
      (GHC.Types.Int, GHC.Types.Int, [GHC.Types.Int])
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                Main.$fArbitraryConstant_$s$fArbitrary(,,) -}
6a211d4406672c9218bfb6236bf7039c
  $fArbitraryConstant2 ::
    Test.QuickCheck.Arbitrary.Arbitrary [GHC.Types.Int]
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                Main.$fArbitraryConstant_$s$fArbitrary[] -}
863344b35f57e88f8126098f43ce016c
  $fArbitraryConstant3 ::
    Test.QuickCheck.Arbitrary.Arbitrary a =>
    Test.QuickCheck.Random.QCGen -> GHC.Types.Int -> a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,1*U(U,U,U,1*U,A,A)><L,U>,
     Unfolding: (\ @ a
                   @ b
                   ($dArbitrary :: Test.QuickCheck.Arbitrary.Arbitrary a)
                   (eta :: Test.QuickCheck.Random.QCGen)
                   (eta1 :: GHC.Types.Int) ->
                 (Test.QuickCheck.Arbitrary.arbitrary @ a $dArbitrary)
                   `cast`
                 (Test.QuickCheck.Gen.N:Gen[0] <a>_R)
                   (case eta
                           `cast`
                         (Test.QuickCheck.Random.N:QCGen[0]) of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                    case System.Random.TF.Gen.$wtfGenSplit
                           ww1
                           ww2
                           ww3
                           ww4 of ww7 { (#,#) ww8 ww9 ->
                    ww8 `cast` (Sym (Test.QuickCheck.Random.N:QCGen[0])) } })
                   eta1) -}
5e2154c1e232fd389ac68d8b18548c1e
  $fArbitraryConstant_$carbitrary ::
    Test.QuickCheck.Arbitrary.Arbitrary a =>
    Test.QuickCheck.Gen.Gen (TraversableInstances.Constant a b)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,1*U(U,U,U,1*U,A,A)><L,U>,
     Unfolding: InlineRule (0, True, True)
                Main.$fArbitraryConstant3
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <Test.QuickCheck.Arbitrary.Arbitrary a>_R
                 ->_R Sym (Test.QuickCheck.Gen.N:Gen[0]
                               (TraversableInstances.N:Constant[0] <a>_R <b>_P))) -}
8fa33c9118b667a78e59de88609c47d5
  $fArbitraryConstant_$cshrink ::
    Test.QuickCheck.Arbitrary.Arbitrary a =>
    TraversableInstances.Constant a b
    -> [TraversableInstances.Constant a b]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><L,A>,
     Unfolding: InlineRule (2, True, True)
                (\ @ a
                   @ b
                   ($dArbitrary :: Test.QuickCheck.Arbitrary.Arbitrary a)
                   (ds1 :: TraversableInstances.Constant a b) ->
                 GHC.Types.[] @ (TraversableInstances.Constant a b)) -}
190998253aa1f98d3fe0202c828645cd
  $fArbitraryConstant_$s$cshrink ::
    TraversableInstances.Constant
      (GHC.Types.Int, GHC.Types.Int, [GHC.Types.Int]) b
    -> [TraversableInstances.Constant
          (GHC.Types.Int, GHC.Types.Int, [GHC.Types.Int]) b]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>,
     Unfolding: InlineRule (1, True, True)
                (\ @ b
                   (ds1 :: TraversableInstances.Constant
                             (GHC.Types.Int, GHC.Types.Int, [GHC.Types.Int]) b) ->
                 GHC.Types.[]
                   @ (TraversableInstances.Constant
                        (GHC.Types.Int, GHC.Types.Int, [GHC.Types.Int]) b)) -}
b90a8ce9f6d5d7aa3d8f5aa2f46e1bc6
  $fArbitraryConstant_$s$fArbitrary(,,) ::
    Test.QuickCheck.Arbitrary.Arbitrary
      (GHC.Types.Int, GHC.Types.Int, [GHC.Types.Int])
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (GHC.Types.Int, GHC.Types.Int, [GHC.Types.Int])
                  (Test.QuickCheck.Arbitrary.$fArbitrary(,,)_$carbitrary
                     @ GHC.Types.Int
                     @ GHC.Types.Int
                     @ [GHC.Types.Int]
                     Test.QuickCheck.Arbitrary.$fArbitraryInt
                     Test.QuickCheck.Arbitrary.$fArbitraryInt
                     Main.$fArbitraryConstant2)
                  (Test.QuickCheck.Arbitrary.$fArbitrary(,,)_$cshrink
                     @ GHC.Types.Int
                     @ GHC.Types.Int
                     @ [GHC.Types.Int]
                     Test.QuickCheck.Arbitrary.$fArbitraryInt
                     Test.QuickCheck.Arbitrary.$fArbitraryInt
                     Main.$fArbitraryConstant2) -}
79cdf9013c496d86d7fb67b1eff0e4ee
  $fArbitraryConstant_$s$fArbitraryConstant ::
    Test.QuickCheck.Arbitrary.Arbitrary
      (TraversableInstances.Constant
         (GHC.Types.Int, GHC.Types.Int, [GHC.Types.Int]) b)
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ b.
                  @ (TraversableInstances.Constant
                       (GHC.Types.Int, GHC.Types.Int, [GHC.Types.Int]) b)
                  (Main.$fArbitraryConstant_$carbitrary
                     @ (GHC.Types.Int, GHC.Types.Int, [GHC.Types.Int])
                     @ b
                     Main.$fArbitraryConstant1)
                  (Main.$fArbitraryConstant_$s$cshrink @ b) -}
3860d2b455ae97422b16bda5bcde9438
  $fArbitraryConstant_$s$fArbitrary[] ::
    Test.QuickCheck.Arbitrary.Arbitrary [GHC.Types.Int]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ [GHC.Types.Int]
                  (Test.QuickCheck.Arbitrary.$fArbitrary[]_$carbitrary
                     @ GHC.Types.Int
                     Test.QuickCheck.Arbitrary.$fArbitraryInt)
                  Main.$fArbitraryConstant_$s$fArbitrary[]_$cshrink -}
7bffcfda5ecaa2e6a7ab7b3bf8cc1e88
  $fArbitraryConstant_$s$fArbitrary[]_$cshrink ::
    [GHC.Types.Int] -> [[GHC.Types.Int]]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (xs :: [GHC.Types.Int]) ->
                 Test.QuickCheck.Arbitrary.shrinkList
                   @ GHC.Types.Int
                   Test.QuickCheck.Arbitrary.$fArbitraryInt_$cshrink
                   xs) -}
c08ccb5e516ad1ed3e9bbe345cc6458d
  $fArbitraryIdentity ::
    Test.QuickCheck.Arbitrary.Arbitrary a =>
    Test.QuickCheck.Arbitrary.Arbitrary
      (TraversableInstances.Identity a)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a
                      ($dArbitrary :: Test.QuickCheck.Arbitrary.Arbitrary a).
                  @ (TraversableInstances.Identity a)
                  (Main.$fArbitraryIdentity_$carbitrary @ a $dArbitrary)
                  (Main.$fArbitraryIdentity_$cshrink @ a $dArbitrary) -}
eba0f83fed1a17f87d01517ebf12b695
  $fArbitraryIdentity1 ::
    Test.QuickCheck.Arbitrary.Arbitrary a =>
    Test.QuickCheck.Random.QCGen -> GHC.Types.Int -> a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,1*U(U,U,U,1*U,A,A)><L,U>,
     Unfolding: (\ @ a
                   ($dArbitrary :: Test.QuickCheck.Arbitrary.Arbitrary a)
                   (eta :: Test.QuickCheck.Random.QCGen)
                   (eta1 :: GHC.Types.Int) ->
                 (Test.QuickCheck.Arbitrary.arbitrary @ a $dArbitrary)
                   `cast`
                 (Test.QuickCheck.Gen.N:Gen[0] <a>_R)
                   (case eta
                           `cast`
                         (Test.QuickCheck.Random.N:QCGen[0]) of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                    case System.Random.TF.Gen.$wtfGenSplit
                           ww1
                           ww2
                           ww3
                           ww4 of ww7 { (#,#) ww8 ww9 ->
                    ww8 `cast` (Sym (Test.QuickCheck.Random.N:QCGen[0])) } })
                   eta1) -}
133f3b131c564d139baa6f6a38522a3e
  $fArbitraryIdentity_$carbitrary ::
    Test.QuickCheck.Arbitrary.Arbitrary a =>
    Test.QuickCheck.Gen.Gen (TraversableInstances.Identity a)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,1*U(U,U,U,1*U,A,A)><L,U>,
     Unfolding: InlineRule (0, True, True)
                Main.$fArbitraryIdentity1
                  `cast`
                (forall (a :: <*>_N).
                 <Test.QuickCheck.Arbitrary.Arbitrary a>_R
                 ->_R Sym (Test.QuickCheck.Gen.N:Gen[0]
                               (TraversableInstances.N:Identity[0] <a>_R))) -}
cd93eef3c3e847f95b2dbfd0fa5d0eda
  $fArbitraryIdentity_$cshrink ::
    Test.QuickCheck.Arbitrary.Arbitrary a =>
    TraversableInstances.Identity a
    -> [TraversableInstances.Identity a]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><L,A>,
     Unfolding: InlineRule (2, True, True)
                (\ @ a
                   ($dArbitrary :: Test.QuickCheck.Arbitrary.Arbitrary a)
                   (ds1 :: TraversableInstances.Identity a) ->
                 GHC.Types.[] @ (TraversableInstances.Identity a)) -}
dec7b0609bd0ef883a9274877d50a5a6
  $fArbitraryIdentity_$s$cshrink ::
    TraversableInstances.Identity GHC.Types.Int
    -> [TraversableInstances.Identity GHC.Types.Int]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>,
     Unfolding: InlineRule (1, True, True)
                (\ (ds1 :: TraversableInstances.Identity GHC.Types.Int) ->
                 GHC.Types.[] @ (TraversableInstances.Identity GHC.Types.Int)) -}
8bdab17ae443e3b457ac77ba1137d3ca
  $fArbitraryIdentity_$s$fArbitraryIdentity ::
    Test.QuickCheck.Arbitrary.Arbitrary
      (TraversableInstances.Identity GHC.Types.Int)
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (TraversableInstances.Identity GHC.Types.Int)
                  (Main.$fArbitraryIdentity_$carbitrary
                     @ GHC.Types.Int
                     Test.QuickCheck.Arbitrary.$fArbitraryInt)
                  Main.$fArbitraryIdentity_$s$cshrink -}
e6fb2c3cec52ef948a2a2955c96e7858
  $fArbitraryList ::
    Test.QuickCheck.Arbitrary.Arbitrary a =>
    Test.QuickCheck.Arbitrary.Arbitrary (TraversableInstances.List a)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a
                      ($dArbitrary :: Test.QuickCheck.Arbitrary.Arbitrary a).
                  @ (TraversableInstances.List a)
                  (Main.$fArbitraryList_$carbitrary @ a $dArbitrary)
                  (Main.$fArbitraryList_$cshrink @ a $dArbitrary) -}
51fce377d204ff91a6aa28b1618b3f4b
  $fArbitraryList1 ::
    Test.QuickCheck.Arbitrary.Arbitrary a =>
    Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int -> TraversableInstances.List a
  {- Arity: 3,
     Strictness: <L,U(C(C1(U)),A)><L,1*U(U,U,U,1*U,A,A)><L,U> -}
fe440990bf40b8d2d92cac0f16e006c1
  $fArbitraryList_$carbitrary ::
    Test.QuickCheck.Arbitrary.Arbitrary a =>
    Test.QuickCheck.Gen.Gen (TraversableInstances.List a)
  {- Arity: 3,
     Strictness: <L,U(C(C1(U)),A)><L,1*U(U,U,U,1*U,A,A)><L,U>,
     Unfolding: InlineRule (0, True, True)
                Main.$fArbitraryList1
                  `cast`
                (forall (a :: <*>_N).
                 <Test.QuickCheck.Arbitrary.Arbitrary a>_R
                 ->_R Sym (Test.QuickCheck.Gen.N:Gen[0]
                               <TraversableInstances.List a>_R)) -}
2f3d38374e5d6dd6f316fe8b28f04a89
  $fArbitraryList_$cshrink ::
    Test.QuickCheck.Arbitrary.Arbitrary a =>
    TraversableInstances.List a -> [TraversableInstances.List a]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><L,A>,
     Unfolding: InlineRule (2, True, True)
                (\ @ a
                   ($dArbitrary :: Test.QuickCheck.Arbitrary.Arbitrary a)
                   (ds1 :: TraversableInstances.List a) ->
                 GHC.Types.[] @ (TraversableInstances.List a)) -}
7d1d06099d157953afaea0c24c810686
  $fArbitraryList_$s$cshrink ::
    TraversableInstances.List GHC.Types.Int
    -> [TraversableInstances.List GHC.Types.Int]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>,
     Unfolding: InlineRule (1, True, True)
                (\ (ds1 :: TraversableInstances.List GHC.Types.Int) ->
                 GHC.Types.[] @ (TraversableInstances.List GHC.Types.Int)) -}
a3ddd2b158a0b3918ce73e02ce1f9df2
  $fArbitraryList_$s$fArbitraryList ::
    Test.QuickCheck.Arbitrary.Arbitrary
      (TraversableInstances.List GHC.Types.Int)
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (TraversableInstances.List GHC.Types.Int)
                  (Main.$fArbitraryList_$carbitrary
                     @ GHC.Types.Int
                     Test.QuickCheck.Arbitrary.$fArbitraryInt)
                  Main.$fArbitraryList_$s$cshrink -}
d5386461532e470a3ac09136910b9754
  $fArbitraryOptional ::
    Test.QuickCheck.Arbitrary.Arbitrary a =>
    Test.QuickCheck.Arbitrary.Arbitrary
      (TraversableInstances.Optional a)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a
                      ($dArbitrary :: Test.QuickCheck.Arbitrary.Arbitrary a).
                  @ (TraversableInstances.Optional a)
                  (Main.$fArbitraryOptional_$carbitrary @ a $dArbitrary)
                  (Main.$fArbitraryOptional_$cshrink @ a $dArbitrary) -}
ebcb2236d3a3e9845f2642a2865b220d
  $fArbitraryOptional1 ::
    Test.QuickCheck.Arbitrary.Arbitrary a =>
    Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int -> TraversableInstances.Optional a
  {- Arity: 3,
     Strictness: <L,1*U(1*C1(C1(U)),A)><L,1*U(U,U,U,1*U,A,A)><L,U>,
     Unfolding: (\ @ a
                   ($dArbitrary :: Test.QuickCheck.Arbitrary.Arbitrary a)
                   (eta :: Test.QuickCheck.Random.QCGen)
                   (eta1 :: GHC.Types.Int) ->
                 let {
                   ds1 :: (Test.QuickCheck.Random.QCGen, Test.QuickCheck.Random.QCGen)
                   = case eta
                            `cast`
                          (Test.QuickCheck.Random.N:QCGen[0]) of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                     case System.Random.TF.Gen.$wtfGenSplit
                            ww1
                            ww2
                            ww3
                            ww4 of ww7 { (#,#) ww8 ww9 ->
                     (ww8 `cast` (Sym (Test.QuickCheck.Random.N:QCGen[0])),
                      ww9 `cast` (Sym (Test.QuickCheck.Random.N:QCGen[0]))) } }
                 } in
                 (Test.QuickCheck.Gen.elements
                    @ (TraversableInstances.Optional a)
                    (GHC.Types.:
                       @ (TraversableInstances.Optional a)
                       (TraversableInstances.Yep
                          @ a
                          ((Test.QuickCheck.Arbitrary.arbitrary @ a $dArbitrary)
                             `cast`
                           (Test.QuickCheck.Gen.N:Gen[0] <a>_R)
                             (case ds1 of wild { (,) r1 r2 -> r1 })
                             eta1))
                       (Main.$fArbitraryOptional2 @ a)))
                   `cast`
                 (Test.QuickCheck.Gen.N:Gen[0] <TraversableInstances.Optional a>_R)
                   (case ds1 of wild { (,) r1 r2 -> r2 })
                   eta1) -}
88935e71c066ddecac56a757dbfcb98f
  $fArbitraryOptional2 :: [TraversableInstances.Optional a]
  {- HasNoCafRefs,
     Unfolding: (\ @ a ->
                 GHC.Types.:
                   @ (TraversableInstances.Optional a)
                   (TraversableInstances.Nada @ a)
                   (GHC.Types.[] @ (TraversableInstances.Optional a))) -}
9466b3ba19227f00c590ca0ec48022ab
  $fArbitraryOptional_$carbitrary ::
    Test.QuickCheck.Arbitrary.Arbitrary a =>
    Test.QuickCheck.Gen.Gen (TraversableInstances.Optional a)
  {- Arity: 3,
     Strictness: <L,1*U(1*C1(C1(U)),A)><L,1*U(U,U,U,1*U,A,A)><L,U>,
     Unfolding: InlineRule (0, True, True)
                Main.$fArbitraryOptional1
                  `cast`
                (forall (a :: <*>_N).
                 <Test.QuickCheck.Arbitrary.Arbitrary a>_R
                 ->_R Sym (Test.QuickCheck.Gen.N:Gen[0]
                               <TraversableInstances.Optional a>_R)) -}
2a50d5df85c2335cee776e500661fe0c
  $fArbitraryOptional_$cshrink ::
    Test.QuickCheck.Arbitrary.Arbitrary a =>
    TraversableInstances.Optional a
    -> [TraversableInstances.Optional a]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><L,A>,
     Unfolding: InlineRule (2, True, True)
                (\ @ a
                   ($dArbitrary :: Test.QuickCheck.Arbitrary.Arbitrary a)
                   (ds1 :: TraversableInstances.Optional a) ->
                 GHC.Types.[] @ (TraversableInstances.Optional a)) -}
5e1c501105677619aee99dbc41d4239b
  $fArbitraryOptional_$s$cshrink ::
    TraversableInstances.Optional GHC.Types.Int
    -> [TraversableInstances.Optional GHC.Types.Int]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>,
     Unfolding: InlineRule (1, True, True)
                (\ (ds1 :: TraversableInstances.Optional GHC.Types.Int) ->
                 GHC.Types.[] @ (TraversableInstances.Optional GHC.Types.Int)) -}
9640d6ef110f4a48209426ad263707aa
  $fArbitraryOptional_$s$fArbitraryOptional ::
    Test.QuickCheck.Arbitrary.Arbitrary
      (TraversableInstances.Optional GHC.Types.Int)
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (TraversableInstances.Optional GHC.Types.Int)
                  (Main.$fArbitraryOptional_$carbitrary
                     @ GHC.Types.Int
                     Test.QuickCheck.Arbitrary.$fArbitraryInt)
                  Main.$fArbitraryOptional_$s$cshrink -}
eb2934a05dc9b96b0d06445161c70011
  $fArbitraryPair ::
    (Test.QuickCheck.Arbitrary.Arbitrary a,
     Test.QuickCheck.Arbitrary.Arbitrary b) =>
    Test.QuickCheck.Arbitrary.Arbitrary (TraversableInstances.Pair a b)
  DFunId
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a
                      @ b
                      ($dArbitrary :: Test.QuickCheck.Arbitrary.Arbitrary a)
                      ($dArbitrary2 :: Test.QuickCheck.Arbitrary.Arbitrary b).
                  @ (TraversableInstances.Pair a b)
                  (Main.$fArbitraryPair_$carbitrary @ a @ b $dArbitrary $dArbitrary2)
                  (Main.$fArbitraryPair_$cshrink @ a @ b $dArbitrary $dArbitrary2) -}
a05396567c4519123cd5ba8553abc8ea
  $fArbitraryPair1 ::
    (Test.QuickCheck.Arbitrary.Arbitrary a,
     Test.QuickCheck.Arbitrary.Arbitrary b) =>
    Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int -> TraversableInstances.Pair a b
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(U,U,U,1*U,A,A)><L,U>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   @ b
                   (w :: Test.QuickCheck.Arbitrary.Arbitrary a)
                   (w1 :: Test.QuickCheck.Arbitrary.Arbitrary b)
                   (w2 :: Test.QuickCheck.Random.QCGen)
                   (w3 :: GHC.Types.Int) ->
                 case Main.$w$carbitrary2
                        @ a
                        @ b
                        w
                        w1
                        w2
                        w3 of ww { (#,#) ww1 ww2 ->
                 TraversableInstances.Pair @ a @ b ww1 ww2 }) -}
83a3e1295fda217ad4d2f113ef67aa85
  $fArbitraryPair_$carbitrary ::
    (Test.QuickCheck.Arbitrary.Arbitrary a,
     Test.QuickCheck.Arbitrary.Arbitrary b) =>
    Test.QuickCheck.Gen.Gen (TraversableInstances.Pair a b)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(U,U,U,1*U,A,A)><L,U>m,
     Unfolding: InlineRule (0, True, True)
                Main.$fArbitraryPair1
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <Test.QuickCheck.Arbitrary.Arbitrary a>_R
                 ->_R <Test.QuickCheck.Arbitrary.Arbitrary b>_R
                 ->_R Sym (Test.QuickCheck.Gen.N:Gen[0]
                               <TraversableInstances.Pair a b>_R)) -}
3bd0b45e778ca40bdd66ff2e3aba3e4d
  $fArbitraryPair_$cshrink ::
    (Test.QuickCheck.Arbitrary.Arbitrary a,
     Test.QuickCheck.Arbitrary.Arbitrary b) =>
    TraversableInstances.Pair a b -> [TraversableInstances.Pair a b]
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><L,A><L,A>,
     Unfolding: InlineRule (3, True, True)
                (\ @ a
                   @ b
                   ($dArbitrary :: Test.QuickCheck.Arbitrary.Arbitrary a)
                   ($dArbitrary2 :: Test.QuickCheck.Arbitrary.Arbitrary b)
                   (ds1 :: TraversableInstances.Pair a b) ->
                 GHC.Types.[] @ (TraversableInstances.Pair a b)) -}
134b3974b5582be06a69854972c63d8d
  $fArbitraryS ::
    (Test.QuickCheck.Arbitrary.Arbitrary (n a),
     Test.QuickCheck.Arbitrary.Arbitrary a) =>
    Test.QuickCheck.Arbitrary.Arbitrary (TraversableInstances.S n a)
  DFunId
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ (n :: * -> *)
                      @ a
                      ($dArbitrary :: Test.QuickCheck.Arbitrary.Arbitrary (n a))
                      ($dArbitrary2 :: Test.QuickCheck.Arbitrary.Arbitrary a).
                  @ (TraversableInstances.S n a)
                  (Main.$fArbitraryS_$carbitrary @ n @ a $dArbitrary $dArbitrary2)
                  (Main.$fArbitraryS_$cshrink @ n @ a $dArbitrary $dArbitrary2) -}
b138d97eb5dddbabc98e043321fdf57c
  $fArbitraryS1 ::
    Test.QuickCheck.Arbitrary.Arbitrary
      (TraversableInstances.Optional GHC.Types.Int)
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                Main.$fArbitraryOptional_$s$fArbitraryOptional -}
7342f287d5efba1a445cab174881a1fd
  $fArbitraryS2 ::
    (Test.QuickCheck.Arbitrary.Arbitrary (n a),
     Test.QuickCheck.Arbitrary.Arbitrary a) =>
    Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int -> TraversableInstances.S n a
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(U,U,U,1*U,A,A)><L,U>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ @ (n :: * -> *)
                   @ a
                   (w :: Test.QuickCheck.Arbitrary.Arbitrary (n a))
                   (w1 :: Test.QuickCheck.Arbitrary.Arbitrary a)
                   (w2 :: Test.QuickCheck.Random.QCGen)
                   (w3 :: GHC.Types.Int) ->
                 case Main.$w$carbitrary3
                        @ n
                        @ a
                        w
                        w1
                        w2
                        w3 of ww { (#,#) ww1 ww2 ->
                 TraversableInstances.S @ n @ a ww1 ww2 }) -}
5b5312a5b21bcb9153e289796ff6f9af
  $fArbitraryS_$carbitrary ::
    (Test.QuickCheck.Arbitrary.Arbitrary (n a),
     Test.QuickCheck.Arbitrary.Arbitrary a) =>
    Test.QuickCheck.Gen.Gen (TraversableInstances.S n a)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(U,U,U,1*U,A,A)><L,U>m,
     Unfolding: InlineRule (0, True, True)
                Main.$fArbitraryS2
                  `cast`
                (forall (n :: <* -> *>_N) (a :: <*>_N).
                 <Test.QuickCheck.Arbitrary.Arbitrary (n a)>_R
                 ->_R <Test.QuickCheck.Arbitrary.Arbitrary a>_R
                 ->_R Sym (Test.QuickCheck.Gen.N:Gen[0]
                               <TraversableInstances.S n a>_R)) -}
54d70503e255403d3c7dcad4d2bf0883
  $fArbitraryS_$cshrink ::
    (Test.QuickCheck.Arbitrary.Arbitrary (n a),
     Test.QuickCheck.Arbitrary.Arbitrary a) =>
    TraversableInstances.S n a -> [TraversableInstances.S n a]
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><L,A><L,A>,
     Unfolding: InlineRule (3, True, True)
                (\ @ (n :: * -> *)
                   @ a
                   ($dArbitrary :: Test.QuickCheck.Arbitrary.Arbitrary (n a))
                   ($dArbitrary2 :: Test.QuickCheck.Arbitrary.Arbitrary a)
                   (ds1 :: TraversableInstances.S n a) ->
                 GHC.Types.[] @ (TraversableInstances.S n a)) -}
3695708ed21af0a42530f78f04201d27
  $fArbitraryS_$s$cshrink ::
    TraversableInstances.S TraversableInstances.Optional GHC.Types.Int
    -> [TraversableInstances.S
          TraversableInstances.Optional GHC.Types.Int]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>,
     Unfolding: InlineRule (1, True, True)
                (\ (ds1 :: TraversableInstances.S
                             TraversableInstances.Optional GHC.Types.Int) ->
                 GHC.Types.[]
                   @ (TraversableInstances.S
                        TraversableInstances.Optional GHC.Types.Int)) -}
41b21e32bff909b47e81ef55c73b32cf
  $fArbitraryS_$s$fArbitraryS ::
    Test.QuickCheck.Arbitrary.Arbitrary
      (TraversableInstances.S
         TraversableInstances.Optional GHC.Types.Int)
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (TraversableInstances.S
                       TraversableInstances.Optional GHC.Types.Int)
                  (Main.$fArbitraryS_$carbitrary
                     @ TraversableInstances.Optional
                     @ GHC.Types.Int
                     Main.$fArbitraryS1
                     Test.QuickCheck.Arbitrary.$fArbitraryInt)
                  Main.$fArbitraryS_$s$cshrink -}
e3145ab7439af34663f5c84ce63ee428
  $fArbitraryThree ::
    (Test.QuickCheck.Arbitrary.Arbitrary a,
     Test.QuickCheck.Arbitrary.Arbitrary b,
     Test.QuickCheck.Arbitrary.Arbitrary c) =>
    Test.QuickCheck.Arbitrary.Arbitrary
      (TraversableInstances.Three a b c)
  DFunId
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><L,U(C(C1(U)),A)><L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a
                      @ b
                      @ c
                      ($dArbitrary :: Test.QuickCheck.Arbitrary.Arbitrary a)
                      ($dArbitrary2 :: Test.QuickCheck.Arbitrary.Arbitrary b)
                      ($dArbitrary4 :: Test.QuickCheck.Arbitrary.Arbitrary c).
                  @ (TraversableInstances.Three a b c)
                  (Main.$fArbitraryThree_$carbitrary
                     @ a
                     @ b
                     @ c
                     $dArbitrary
                     $dArbitrary2
                     $dArbitrary4)
                  (Main.$fArbitraryThree_$cshrink
                     @ a
                     @ b
                     @ c
                     $dArbitrary
                     $dArbitrary2
                     $dArbitrary4) -}
7bdf7ff4aa186e0a3a5377bbf2ca8ee4
  $fArbitraryThree1 ::
    Test.QuickCheck.Arbitrary.Arbitrary (GHC.Base.Maybe GHC.Types.Int)
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                Main.$fArbitraryThree_$s$fArbitraryMaybe -}
2a694ab957317aee2959d0859eaa84a1
  $fArbitraryThree2 ::
    Test.QuickCheck.Arbitrary.Arbitrary GHC.Base.String
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                Main.$fArbitraryThree_$s$fArbitrary[] -}
94375ea0ed13729ad492a64f93917a8f
  $fArbitraryThree3 ::
    (Test.QuickCheck.Arbitrary.Arbitrary a,
     Test.QuickCheck.Arbitrary.Arbitrary b,
     Test.QuickCheck.Arbitrary.Arbitrary c) =>
    Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int -> TraversableInstances.Three a b c
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(U,U,U,1*U,A,A)><L,U>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (5, True, False)
                (\ @ a
                   @ b
                   @ c
                   (w :: Test.QuickCheck.Arbitrary.Arbitrary a)
                   (w1 :: Test.QuickCheck.Arbitrary.Arbitrary b)
                   (w2 :: Test.QuickCheck.Arbitrary.Arbitrary c)
                   (w3 :: Test.QuickCheck.Random.QCGen)
                   (w4 :: GHC.Types.Int) ->
                 case Main.$w$carbitrary4
                        @ a
                        @ b
                        @ c
                        w
                        w1
                        w2
                        w3
                        w4 of ww { (#,,#) ww1 ww2 ww3 ->
                 TraversableInstances.Three @ a @ b @ c ww1 ww2 ww3 }) -}
1ed0b79a348077e09f9804ae69aaf997
  $fArbitraryThree_$carbitrary ::
    (Test.QuickCheck.Arbitrary.Arbitrary a,
     Test.QuickCheck.Arbitrary.Arbitrary b,
     Test.QuickCheck.Arbitrary.Arbitrary c) =>
    Test.QuickCheck.Gen.Gen (TraversableInstances.Three a b c)
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(U,U,U,1*U,A,A)><L,U>m,
     Unfolding: InlineRule (0, True, True)
                Main.$fArbitraryThree3
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N) (c :: <*>_N).
                 <Test.QuickCheck.Arbitrary.Arbitrary a>_R
                 ->_R <Test.QuickCheck.Arbitrary.Arbitrary b>_R
                 ->_R <Test.QuickCheck.Arbitrary.Arbitrary c>_R
                 ->_R Sym (Test.QuickCheck.Gen.N:Gen[0]
                               <TraversableInstances.Three a b c>_R)) -}
43842c5590d3cc03dfbd935b6d9f4eac
  $fArbitraryThree_$cshrink ::
    (Test.QuickCheck.Arbitrary.Arbitrary a,
     Test.QuickCheck.Arbitrary.Arbitrary b,
     Test.QuickCheck.Arbitrary.Arbitrary c) =>
    TraversableInstances.Three a b c
    -> [TraversableInstances.Three a b c]
  {- Arity: 4, HasNoCafRefs, Strictness: <L,A><L,A><L,A><L,A>,
     Unfolding: InlineRule (4, True, True)
                (\ @ a
                   @ b
                   @ c
                   ($dArbitrary :: Test.QuickCheck.Arbitrary.Arbitrary a)
                   ($dArbitrary2 :: Test.QuickCheck.Arbitrary.Arbitrary b)
                   ($dArbitrary4 :: Test.QuickCheck.Arbitrary.Arbitrary c)
                   (ds1 :: TraversableInstances.Three a b c) ->
                 GHC.Types.[] @ (TraversableInstances.Three a b c)) -}
2eebd167490bfc0fdfa3206fd94f0fac
  $fArbitraryThree_$dArbitrary ::
    Test.QuickCheck.Arbitrary.Arbitrary
      (GHC.Base.String, GHC.Base.String, GHC.Base.String)
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                Main.$fArbitraryThree_$s$fArbitrary(,,) -}
268b370ca64a2cf4b07e4b5df655a7e8
  $fArbitraryThree_$s$cshrink ::
    TraversableInstances.Three
      (GHC.Types.Int, GHC.Types.Int, [GHC.Types.Int])
      (GHC.Base.String, GHC.Base.String, GHC.Base.String)
      (GHC.Base.Maybe GHC.Types.Int)
    -> [TraversableInstances.Three
          (GHC.Types.Int, GHC.Types.Int, [GHC.Types.Int])
          (GHC.Base.String, GHC.Base.String, GHC.Base.String)
          (GHC.Base.Maybe GHC.Types.Int)]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>,
     Unfolding: InlineRule (1, True, True)
                (\ (ds1 :: TraversableInstances.Three
                             (GHC.Types.Int, GHC.Types.Int, [GHC.Types.Int])
                             (GHC.Base.String, GHC.Base.String, GHC.Base.String)
                             (GHC.Base.Maybe GHC.Types.Int)) ->
                 GHC.Types.[]
                   @ (TraversableInstances.Three
                        (GHC.Types.Int, GHC.Types.Int, [GHC.Types.Int])
                        (GHC.Base.String, GHC.Base.String, GHC.Base.String)
                        (GHC.Base.Maybe GHC.Types.Int))) -}
b71f097398ad37e566dd2e0e150f8ac1
  $fArbitraryThree_$s$fArbitrary(,,) ::
    Test.QuickCheck.Arbitrary.Arbitrary
      ([GHC.Types.Char], [GHC.Types.Char], [GHC.Types.Char])
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ ([GHC.Types.Char], [GHC.Types.Char], [GHC.Types.Char])
                  (Test.QuickCheck.Arbitrary.$fArbitrary(,,)_$carbitrary
                     @ [GHC.Types.Char]
                     @ [GHC.Types.Char]
                     @ [GHC.Types.Char]
                     Main.$fArbitraryThree2
                     Main.$fArbitraryThree2
                     Main.$fArbitraryThree2)
                  (Test.QuickCheck.Arbitrary.$fArbitrary(,,)_$cshrink
                     @ [GHC.Types.Char]
                     @ [GHC.Types.Char]
                     @ [GHC.Types.Char]
                     Main.$fArbitraryThree2
                     Main.$fArbitraryThree2
                     Main.$fArbitraryThree2) -}
ed04be4fb4a4807eb04de8e21604f05b
  $fArbitraryThree_$s$fArbitraryMaybe ::
    Test.QuickCheck.Arbitrary.Arbitrary (GHC.Base.Maybe GHC.Types.Int)
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (GHC.Base.Maybe GHC.Types.Int)
                  (Test.QuickCheck.Arbitrary.$fArbitraryFirst_$carbitrary1
                     @ GHC.Types.Int
                     Test.QuickCheck.Arbitrary.$fArbitraryInt)
                  (Test.QuickCheck.Arbitrary.$fArbitraryMaybe_$cshrink
                     @ GHC.Types.Int
                     Test.QuickCheck.Arbitrary.$fArbitraryInt) -}
95ccd0dabeadafe7a61c72e9e2a4aa50
  $fArbitraryThree_$s$fArbitraryThree ::
    Test.QuickCheck.Arbitrary.Arbitrary
      (TraversableInstances.Three
         (GHC.Types.Int, GHC.Types.Int, [GHC.Types.Int])
         (GHC.Base.String, GHC.Base.String, GHC.Base.String)
         (GHC.Base.Maybe GHC.Types.Int))
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (TraversableInstances.Three
                       (GHC.Types.Int, GHC.Types.Int, [GHC.Types.Int])
                       (GHC.Base.String, GHC.Base.String, GHC.Base.String)
                       (GHC.Base.Maybe GHC.Types.Int))
                  (Main.$fArbitraryThree_$carbitrary
                     @ (GHC.Types.Int, GHC.Types.Int, [GHC.Types.Int])
                     @ (GHC.Base.String, GHC.Base.String, GHC.Base.String)
                     @ (GHC.Base.Maybe GHC.Types.Int)
                     Main.$fArbitraryConstant1
                     Main.$fArbitraryThree_$dArbitrary
                     Main.$fArbitraryThree1)
                  Main.$fArbitraryThree_$s$cshrink -}
5a1c5788b32458e91b3487df9f49b846
  $fArbitraryThree_$s$fArbitrary[] ::
    Test.QuickCheck.Arbitrary.Arbitrary [GHC.Types.Char]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ [GHC.Types.Char]
                  (Test.QuickCheck.Arbitrary.$fArbitrary[]_$carbitrary
                     @ GHC.Types.Char
                     Test.QuickCheck.Arbitrary.$fArbitraryChar)
                  Main.$fArbitraryThree_$s$fArbitrary[]_$cshrink -}
9babb4ed71097c3130a7f2506bb154e2
  $fArbitraryThree_$s$fArbitrary[]_$cshrink ::
    [GHC.Types.Char] -> [[GHC.Types.Char]]
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (xs :: [GHC.Types.Char]) ->
                 Test.QuickCheck.Arbitrary.shrinkList
                   @ GHC.Types.Char
                   Test.QuickCheck.Arbitrary.$fArbitraryChar_$cshrink
                   xs) -}
c282ad11ac60050d150e004ea3619498
  $fArbitraryTree ::
    Test.QuickCheck.Arbitrary.Arbitrary a =>
    Test.QuickCheck.Arbitrary.Arbitrary (TraversableInstances.Tree a)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a
                      ($dArbitrary :: Test.QuickCheck.Arbitrary.Arbitrary a).
                  @ (TraversableInstances.Tree a)
                  (Main.$fArbitraryTree_$carbitrary @ a $dArbitrary)
                  (Main.$fArbitraryTree_$cshrink @ a $dArbitrary) -}
8722ce8aebc9bd85f8ea6da1c1e4cf71
  $fArbitraryTree1 ::
    Test.QuickCheck.Arbitrary.Arbitrary a =>
    Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int -> TraversableInstances.Tree a
  {- Arity: 3,
     Strictness: <L,U(C(C1(U)),A)><L,1*U(U,U,U,1*U,A,A)><L,U> -}
c09e11b2af4f8e3211a47983247ee237
  $fArbitraryTree_$carbitrary ::
    Test.QuickCheck.Arbitrary.Arbitrary a =>
    Test.QuickCheck.Gen.Gen (TraversableInstances.Tree a)
  {- Arity: 3,
     Strictness: <L,U(C(C1(U)),A)><L,1*U(U,U,U,1*U,A,A)><L,U>,
     Unfolding: InlineRule (0, True, True)
                Main.$fArbitraryTree1
                  `cast`
                (forall (a :: <*>_N).
                 <Test.QuickCheck.Arbitrary.Arbitrary a>_R
                 ->_R Sym (Test.QuickCheck.Gen.N:Gen[0]
                               <TraversableInstances.Tree a>_R)) -}
665c8129920f75453a837090588d7108
  $fArbitraryTree_$cshrink ::
    Test.QuickCheck.Arbitrary.Arbitrary a =>
    TraversableInstances.Tree a -> [TraversableInstances.Tree a]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><L,A>,
     Unfolding: InlineRule (2, True, True)
                (\ @ a
                   ($dArbitrary :: Test.QuickCheck.Arbitrary.Arbitrary a)
                   (ds1 :: TraversableInstances.Tree a) ->
                 GHC.Types.[] @ (TraversableInstances.Tree a)) -}
732be69a478ad3b07d1774c6d0d90d1d
  $fArbitraryTree_$s$cshrink ::
    TraversableInstances.Tree GHC.Types.Int
    -> [TraversableInstances.Tree GHC.Types.Int]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>,
     Unfolding: InlineRule (1, True, True)
                (\ (ds1 :: TraversableInstances.Tree GHC.Types.Int) ->
                 GHC.Types.[] @ (TraversableInstances.Tree GHC.Types.Int)) -}
f6054eb0f93fc5637bbc449cffe11af5
  $fArbitraryTree_$s$fArbitraryTree ::
    Test.QuickCheck.Arbitrary.Arbitrary
      (TraversableInstances.Tree GHC.Types.Int)
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (TraversableInstances.Tree GHC.Types.Int)
                  (Main.$fArbitraryTree_$carbitrary
                     @ GHC.Types.Int
                     Test.QuickCheck.Arbitrary.$fArbitraryInt)
                  Main.$fArbitraryTree_$s$cshrink -}
f65315680150cf823a72a2917a6e4ad4
  $fEqPropBig ::
    (GHC.Classes.Eq a, GHC.Classes.Eq b) =>
    Test.QuickCheck.Checkers.EqProp (TraversableInstances.Big a b)
  DFunId
  {- Arity: 4,
     Strictness: <L,1*U(1*C1(C1(U)),A)><L,U(C(C1(U)),A)><L,1*U(U,U,U)><L,1*U(U,U,U)>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (2, False, True)
                Main.$fEqPropBig_$c=-=
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <GHC.Classes.Eq a>_R
                 ->_R <GHC.Classes.Eq b>_R
                 ->_R Sym (Test.QuickCheck.Checkers.N:EqProp[0]
                               <TraversableInstances.Big a b>_N)) -}
f6db05666f20fc7e675f5d3d85b96e7f
  $fEqPropBig_$c=-= ::
    (GHC.Classes.Eq a, GHC.Classes.Eq b) =>
    TraversableInstances.Big a b
    -> TraversableInstances.Big a b
    -> Test.QuickCheck.Property.Property
  {- Arity: 4,
     Strictness: <L,1*U(1*C1(C1(U)),A)><L,U(C(C1(U)),A)><L,1*U(U,U,U)><L,1*U(U,U,U)>,
     Unfolding: (\ @ a
                   @ b
                   ($dEq :: GHC.Classes.Eq a)
                   ($dEq1 :: GHC.Classes.Eq b)
                   (a1 :: TraversableInstances.Big a b)
                   (a' :: TraversableInstances.Big a b) ->
                 let {
                   x1 :: Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
                   = Test.QuickCheck.Property.protectResults
                       (Test.QuickCheck.Property.MkRose
                          @ Test.QuickCheck.Property.Result
                          (case a1 of ww { TraversableInstances.Big ww1 ww2 ww3 ->
                           case a' of ww4 { TraversableInstances.Big ww5 ww6 ww7 ->
                           case GHC.Classes.== @ a $dEq ww1 ww5 of wild {
                             GHC.Types.False -> Test.QuickCheck.Property.counterexample1
                             GHC.Types.True
                             -> case GHC.Classes.== @ b $dEq1 ww2 ww6 of wild1 {
                                  GHC.Types.False -> Test.QuickCheck.Property.counterexample1
                                  GHC.Types.True
                                  -> case GHC.Classes.== @ b $dEq1 ww3 ww7 of wild2 {
                                       GHC.Types.False -> Test.QuickCheck.Property.counterexample1
                                       GHC.Types.True
                                       -> Test.QuickCheck.Property.succeeded } } } } })
                          (GHC.Types.[]
                             @ (Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result)))
                 } in
                 (\ (ds :: Test.QuickCheck.Random.QCGen) (ds1 :: GHC.Types.Int) ->
                  x1)
                   `cast`
                 (Trans
                      (Sym (Test.QuickCheck.Gen.N:Gen[0]
                                (Test.QuickCheck.Property.N:Prop[0])))
                      (Sym (Test.QuickCheck.Property.N:Property[0])))) -}
9729c05eae81c8c9b197ee9febe08409
  $fEqPropBigger ::
    (GHC.Classes.Eq a, GHC.Classes.Eq b) =>
    Test.QuickCheck.Checkers.EqProp (TraversableInstances.Bigger a b)
  DFunId
  {- Arity: 4,
     Strictness: <L,1*U(1*C1(C1(U)),A)><L,U(C(C1(U)),A)><L,1*U(U,U,U,U)><L,1*U(U,U,U,U)>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (2, False, True)
                Main.$fEqPropBigger_$c=-=
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <GHC.Classes.Eq a>_R
                 ->_R <GHC.Classes.Eq b>_R
                 ->_R Sym (Test.QuickCheck.Checkers.N:EqProp[0]
                               <TraversableInstances.Bigger a b>_N)) -}
84409eb130d0e1b445b2e33d3bd9e996
  $fEqPropBigger_$c=-= ::
    (GHC.Classes.Eq a, GHC.Classes.Eq b) =>
    TraversableInstances.Bigger a b
    -> TraversableInstances.Bigger a b
    -> Test.QuickCheck.Property.Property
  {- Arity: 4,
     Strictness: <L,1*U(1*C1(C1(U)),A)><L,U(C(C1(U)),A)><L,1*U(U,U,U,U)><L,1*U(U,U,U,U)>,
     Unfolding: (\ @ a
                   @ b
                   ($dEq :: GHC.Classes.Eq a)
                   ($dEq1 :: GHC.Classes.Eq b)
                   (a1 :: TraversableInstances.Bigger a b)
                   (a' :: TraversableInstances.Bigger a b) ->
                 let {
                   x1 :: Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
                   = Test.QuickCheck.Property.protectResults
                       (Test.QuickCheck.Property.MkRose
                          @ Test.QuickCheck.Property.Result
                          (case a1 of ww { TraversableInstances.Bigger ww1 ww2 ww3 ww4 ->
                           case a' of ww5 { TraversableInstances.Bigger ww6 ww7 ww8 ww9 ->
                           case TraversableInstances.$w$c==1
                                  @ a
                                  @ b
                                  $dEq1
                                  $dEq
                                  ww1
                                  ww2
                                  ww3
                                  ww4
                                  ww6
                                  ww7
                                  ww8
                                  ww9 of wild {
                             GHC.Types.False -> Test.QuickCheck.Property.counterexample1
                             GHC.Types.True -> Test.QuickCheck.Property.succeeded } } })
                          (GHC.Types.[]
                             @ (Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result)))
                 } in
                 (\ (ds :: Test.QuickCheck.Random.QCGen) (ds1 :: GHC.Types.Int) ->
                  x1)
                   `cast`
                 (Trans
                      (Sym (Test.QuickCheck.Gen.N:Gen[0]
                                (Test.QuickCheck.Property.N:Prop[0])))
                      (Sym (Test.QuickCheck.Property.N:Property[0])))) -}
985afe20a2654e590fcf89b1168e2da8
  $fEqPropConstant ::
    GHC.Classes.Eq a =>
    Test.QuickCheck.Checkers.EqProp (TraversableInstances.Constant a b)
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*C1(C1(U)),A)><L,U><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (1, False, True)
                Main.$fEqPropConstant_$c=-=
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <GHC.Classes.Eq a>_R
                 ->_R Sym (Test.QuickCheck.Checkers.N:EqProp[0]
                               <TraversableInstances.Constant a b>_N)) -}
48c6bde18c732900b0247515879b6f3d
  $fEqPropConstant_$c=-= ::
    GHC.Classes.Eq a =>
    TraversableInstances.Constant a b
    -> TraversableInstances.Constant a b
    -> Test.QuickCheck.Property.Property
  {- Arity: 3, Strictness: <L,1*U(1*C1(C1(U)),A)><L,U><L,U>,
     Unfolding: InlineRule (3, True, True)
                (\ @ a
                   @ b
                   ($dEq :: GHC.Classes.Eq a)
                   (ds :: TraversableInstances.Constant a b)
                   (ds1 :: TraversableInstances.Constant a b) ->
                 Test.QuickCheck.Checkers.eq
                   @ a
                   $dEq
                   ds `cast` (TraversableInstances.N:Constant[0] <a>_R <b>_P)
                   ds1 `cast` (TraversableInstances.N:Constant[0] <a>_R <b>_P)) -}
04e7e020b7c980c0b991e32ed85758a7
  $fEqPropIdentity ::
    GHC.Classes.Eq a =>
    Test.QuickCheck.Checkers.EqProp (TraversableInstances.Identity a)
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*C1(C1(U)),A)><L,U><L,U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (1, False, True)
                Main.$fEqPropIdentity_$c=-=
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Classes.Eq a>_R
                 ->_R Sym (Test.QuickCheck.Checkers.N:EqProp[0]
                               <TraversableInstances.Identity a>_N)) -}
67e6aba3da4880b2dac0edb6654328ac
  $fEqPropIdentity_$c=-= ::
    GHC.Classes.Eq a =>
    TraversableInstances.Identity a
    -> TraversableInstances.Identity a
    -> Test.QuickCheck.Property.Property
  {- Arity: 3, Strictness: <L,1*U(1*C1(C1(U)),A)><L,U><L,U>,
     Unfolding: (\ @ a
                   ($dEq :: GHC.Classes.Eq a)
                   (a1 :: TraversableInstances.Identity a)
                   (a' :: TraversableInstances.Identity a) ->
                 let {
                   x1 :: Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
                   = Test.QuickCheck.Property.protectResults
                       (Test.QuickCheck.Property.MkRose
                          @ Test.QuickCheck.Property.Result
                          (case GHC.Classes.==
                                  @ a
                                  $dEq
                                  a1 `cast` (TraversableInstances.N:Identity[0] <a>_R)
                                  a' `cast` (TraversableInstances.N:Identity[0] <a>_R) of wild {
                             GHC.Types.False -> Test.QuickCheck.Property.counterexample1
                             GHC.Types.True -> Test.QuickCheck.Property.succeeded })
                          (GHC.Types.[]
                             @ (Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result)))
                 } in
                 (\ (ds :: Test.QuickCheck.Random.QCGen) (ds1 :: GHC.Types.Int) ->
                  x1)
                   `cast`
                 (Trans
                      (Sym (Test.QuickCheck.Gen.N:Gen[0]
                                (Test.QuickCheck.Property.N:Prop[0])))
                      (Sym (Test.QuickCheck.Property.N:Property[0])))) -}
6548feb09cc54d31bf5064c05a159100
  $fEqPropList ::
    GHC.Classes.Eq a =>
    Test.QuickCheck.Checkers.EqProp (TraversableInstances.List a)
  DFunId
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A)><L,1*U><L,1*U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (1, False, True)
                Main.$fEqPropList_$c=-=
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Classes.Eq a>_R
                 ->_R Sym (Test.QuickCheck.Checkers.N:EqProp[0]
                               <TraversableInstances.List a>_N)) -}
5eab9d8461862684b33813b08750054a
  $fEqPropList_$c=-= ::
    GHC.Classes.Eq a =>
    TraversableInstances.List a
    -> TraversableInstances.List a -> Test.QuickCheck.Property.Property
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A)><L,1*U><L,1*U>,
     Unfolding: (\ @ a
                   ($dEq :: GHC.Classes.Eq a)
                   (a1 :: TraversableInstances.List a)
                   (a' :: TraversableInstances.List a) ->
                 let {
                   x1 :: Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
                   = Test.QuickCheck.Property.protectResults
                       (Test.QuickCheck.Property.MkRose
                          @ Test.QuickCheck.Property.Result
                          (case TraversableInstances.$fEqList_$c== @ a $dEq a1 a' of wild {
                             GHC.Types.False -> Test.QuickCheck.Property.counterexample1
                             GHC.Types.True -> Test.QuickCheck.Property.succeeded })
                          (GHC.Types.[]
                             @ (Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result)))
                 } in
                 (\ (ds :: Test.QuickCheck.Random.QCGen) (ds1 :: GHC.Types.Int) ->
                  x1)
                   `cast`
                 (Trans
                      (Sym (Test.QuickCheck.Gen.N:Gen[0]
                                (Test.QuickCheck.Property.N:Prop[0])))
                      (Sym (Test.QuickCheck.Property.N:Property[0])))) -}
21b10a875d0e934ce4cc6356470e0cb1
  $fEqPropOptional ::
    GHC.Classes.Eq a =>
    Test.QuickCheck.Checkers.EqProp (TraversableInstances.Optional a)
  DFunId
  {- Arity: 3, Strictness: <L,1*U(1*C1(C1(U)),A)><L,1*U><L,1*U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (1, False, True)
                Main.$fEqPropOptional_$c=-=
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Classes.Eq a>_R
                 ->_R Sym (Test.QuickCheck.Checkers.N:EqProp[0]
                               <TraversableInstances.Optional a>_N)) -}
5c84b8edfd554e067e18fb6961c39b17
  $fEqPropOptional_$c=-= ::
    GHC.Classes.Eq a =>
    TraversableInstances.Optional a
    -> TraversableInstances.Optional a
    -> Test.QuickCheck.Property.Property
  {- Arity: 3, Strictness: <L,1*U(1*C1(C1(U)),A)><L,1*U><L,1*U>,
     Unfolding: (\ @ a
                   ($dEq :: GHC.Classes.Eq a)
                   (a1 :: TraversableInstances.Optional a)
                   (a' :: TraversableInstances.Optional a) ->
                 let {
                   x1 :: Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
                   = Test.QuickCheck.Property.protectResults
                       (Test.QuickCheck.Property.MkRose
                          @ Test.QuickCheck.Property.Result
                          (case a1 of wild {
                             TraversableInstances.Nada
                             -> case a' of wild1 {
                                  TraversableInstances.Nada -> Test.QuickCheck.Property.succeeded
                                  TraversableInstances.Yep ipv
                                  -> Test.QuickCheck.Property.counterexample1 }
                             TraversableInstances.Yep a2
                             -> case a' of wild1 {
                                  TraversableInstances.Nada
                                  -> Test.QuickCheck.Property.counterexample1
                                  TraversableInstances.Yep b1
                                  -> case GHC.Classes.== @ a $dEq a2 b1 of wild2 {
                                       GHC.Types.False -> Test.QuickCheck.Property.counterexample1
                                       GHC.Types.True -> Test.QuickCheck.Property.succeeded } } })
                          (GHC.Types.[]
                             @ (Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result)))
                 } in
                 (\ (ds :: Test.QuickCheck.Random.QCGen) (ds1 :: GHC.Types.Int) ->
                  x1)
                   `cast`
                 (Trans
                      (Sym (Test.QuickCheck.Gen.N:Gen[0]
                                (Test.QuickCheck.Property.N:Prop[0])))
                      (Sym (Test.QuickCheck.Property.N:Property[0])))) -}
82c70304515847809e9d6cb9b9017bd9
  $fEqPropPair ::
    (GHC.Classes.Eq a, GHC.Classes.Eq b) =>
    Test.QuickCheck.Checkers.EqProp (TraversableInstances.Pair a b)
  DFunId
  {- Arity: 4,
     Strictness: <L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(U,U)><L,1*U(U,U)>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (2, False, True)
                Main.$fEqPropPair_$c=-=
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <GHC.Classes.Eq a>_R
                 ->_R <GHC.Classes.Eq b>_R
                 ->_R Sym (Test.QuickCheck.Checkers.N:EqProp[0]
                               <TraversableInstances.Pair a b>_N)) -}
d28c8c2debad8497545077ca98c88e3c
  $fEqPropPair_$c=-= ::
    (GHC.Classes.Eq a, GHC.Classes.Eq b) =>
    TraversableInstances.Pair a b
    -> TraversableInstances.Pair a b
    -> Test.QuickCheck.Property.Property
  {- Arity: 4,
     Strictness: <L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(U,U)><L,1*U(U,U)>,
     Unfolding: (\ @ a
                   @ b
                   ($dEq :: GHC.Classes.Eq a)
                   ($dEq1 :: GHC.Classes.Eq b)
                   (a1 :: TraversableInstances.Pair a b)
                   (a' :: TraversableInstances.Pair a b) ->
                 let {
                   x1 :: Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
                   = Test.QuickCheck.Property.protectResults
                       (Test.QuickCheck.Property.MkRose
                          @ Test.QuickCheck.Property.Result
                          (case a1 of ww { TraversableInstances.Pair ww1 ww2 ->
                           case a' of ww3 { TraversableInstances.Pair ww4 ww5 ->
                           case GHC.Classes.== @ a $dEq ww1 ww4 of wild {
                             GHC.Types.False -> Test.QuickCheck.Property.counterexample1
                             GHC.Types.True
                             -> case GHC.Classes.== @ b $dEq1 ww2 ww5 of wild1 {
                                  GHC.Types.False -> Test.QuickCheck.Property.counterexample1
                                  GHC.Types.True -> Test.QuickCheck.Property.succeeded } } } })
                          (GHC.Types.[]
                             @ (Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result)))
                 } in
                 (\ (ds :: Test.QuickCheck.Random.QCGen) (ds1 :: GHC.Types.Int) ->
                  x1)
                   `cast`
                 (Trans
                      (Sym (Test.QuickCheck.Gen.N:Gen[0]
                                (Test.QuickCheck.Property.N:Prop[0])))
                      (Sym (Test.QuickCheck.Property.N:Property[0])))) -}
de14846572c3b8e8d6e79466a3173ec8
  $fEqPropS ::
    (GHC.Classes.Eq (n a), GHC.Classes.Eq a) =>
    Test.QuickCheck.Checkers.EqProp (TraversableInstances.S n a)
  DFunId
  {- Arity: 4,
     Strictness: <L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(U,U)><L,1*U(U,U)>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (2, False, True)
                Main.$fEqPropS_$c=-=
                  `cast`
                (forall (n :: <* -> *>_N) (a :: <*>_N).
                 <GHC.Classes.Eq (n a)>_R
                 ->_R <GHC.Classes.Eq a>_R
                 ->_R Sym (Test.QuickCheck.Checkers.N:EqProp[0]
                               <TraversableInstances.S n a>_N)) -}
871d1e6ffb3e8524be94712db5c7d271
  $fEqPropS_$c=-= ::
    (GHC.Classes.Eq (n a), GHC.Classes.Eq a) =>
    TraversableInstances.S n a
    -> TraversableInstances.S n a -> Test.QuickCheck.Property.Property
  {- Arity: 4,
     Strictness: <L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(U,U)><L,1*U(U,U)>,
     Unfolding: (\ @ (n :: * -> *)
                   @ a
                   ($dEq :: GHC.Classes.Eq (n a))
                   ($dEq1 :: GHC.Classes.Eq a)
                   (a1 :: TraversableInstances.S n a)
                   (a' :: TraversableInstances.S n a) ->
                 let {
                   x1 :: Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
                   = Test.QuickCheck.Property.protectResults
                       (Test.QuickCheck.Property.MkRose
                          @ Test.QuickCheck.Property.Result
                          (case a1 of ww { TraversableInstances.S ww1 ww2 ->
                           case a' of ww3 { TraversableInstances.S ww4 ww5 ->
                           case GHC.Classes.== @ (n a) $dEq ww1 ww4 of wild {
                             GHC.Types.False -> Test.QuickCheck.Property.counterexample1
                             GHC.Types.True
                             -> case GHC.Classes.== @ a $dEq1 ww2 ww5 of wild1 {
                                  GHC.Types.False -> Test.QuickCheck.Property.counterexample1
                                  GHC.Types.True -> Test.QuickCheck.Property.succeeded } } } })
                          (GHC.Types.[]
                             @ (Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result)))
                 } in
                 (\ (ds :: Test.QuickCheck.Random.QCGen) (ds1 :: GHC.Types.Int) ->
                  x1)
                   `cast`
                 (Trans
                      (Sym (Test.QuickCheck.Gen.N:Gen[0]
                                (Test.QuickCheck.Property.N:Prop[0])))
                      (Sym (Test.QuickCheck.Property.N:Property[0])))) -}
1b7fbd23eb0e95126aa750079c012f96
  $fEqPropThree ::
    (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c) =>
    Test.QuickCheck.Checkers.EqProp (TraversableInstances.Three a b c)
  DFunId
  {- Arity: 5,
     Strictness: <L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(U,U,U)><L,1*U(U,U,U)>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (3, False, True)
                Main.$fEqPropThree_$c=-=
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N) (c :: <*>_N).
                 <GHC.Classes.Eq a>_R
                 ->_R <GHC.Classes.Eq b>_R
                 ->_R <GHC.Classes.Eq c>_R
                 ->_R Sym (Test.QuickCheck.Checkers.N:EqProp[0]
                               <TraversableInstances.Three a b c>_N)) -}
b45e74a01b51f522e0ded4de40d3b40b
  $fEqPropThree_$c=-= ::
    (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c) =>
    TraversableInstances.Three a b c
    -> TraversableInstances.Three a b c
    -> Test.QuickCheck.Property.Property
  {- Arity: 5,
     Strictness: <L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(U,U,U)><L,1*U(U,U,U)>,
     Unfolding: (\ @ a
                   @ b
                   @ c
                   ($dEq :: GHC.Classes.Eq a)
                   ($dEq1 :: GHC.Classes.Eq b)
                   ($dEq2 :: GHC.Classes.Eq c)
                   (a1 :: TraversableInstances.Three a b c)
                   (a' :: TraversableInstances.Three a b c) ->
                 let {
                   x1 :: Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
                   = Test.QuickCheck.Property.protectResults
                       (Test.QuickCheck.Property.MkRose
                          @ Test.QuickCheck.Property.Result
                          (case a1 of ww { TraversableInstances.Three ww1 ww2 ww3 ->
                           case a' of ww4 { TraversableInstances.Three ww5 ww6 ww7 ->
                           case GHC.Classes.== @ a $dEq ww1 ww5 of wild {
                             GHC.Types.False -> Test.QuickCheck.Property.counterexample1
                             GHC.Types.True
                             -> case GHC.Classes.== @ b $dEq1 ww2 ww6 of wild1 {
                                  GHC.Types.False -> Test.QuickCheck.Property.counterexample1
                                  GHC.Types.True
                                  -> case GHC.Classes.== @ c $dEq2 ww3 ww7 of wild2 {
                                       GHC.Types.False -> Test.QuickCheck.Property.counterexample1
                                       GHC.Types.True
                                       -> Test.QuickCheck.Property.succeeded } } } } })
                          (GHC.Types.[]
                             @ (Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result)))
                 } in
                 (\ (ds :: Test.QuickCheck.Random.QCGen) (ds1 :: GHC.Types.Int) ->
                  x1)
                   `cast`
                 (Trans
                      (Sym (Test.QuickCheck.Gen.N:Gen[0]
                                (Test.QuickCheck.Property.N:Prop[0])))
                      (Sym (Test.QuickCheck.Property.N:Property[0])))) -}
fc6f7daefe8978c6765b241cfebea1e7
  $fEqPropTree ::
    GHC.Classes.Eq a =>
    Test.QuickCheck.Checkers.EqProp (TraversableInstances.Tree a)
  DFunId
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A)><L,1*U><L,1*U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (1, False, True)
                Main.$fEqPropTree_$c=-=
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Classes.Eq a>_R
                 ->_R Sym (Test.QuickCheck.Checkers.N:EqProp[0]
                               <TraversableInstances.Tree a>_N)) -}
0e6e3aaa79e5f5ed4ce22ae4dc7a5d32
  $fEqPropTree_$c=-= ::
    GHC.Classes.Eq a =>
    TraversableInstances.Tree a
    -> TraversableInstances.Tree a -> Test.QuickCheck.Property.Property
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A)><L,1*U><L,1*U>,
     Unfolding: (\ @ a
                   ($dEq :: GHC.Classes.Eq a)
                   (a1 :: TraversableInstances.Tree a)
                   (a' :: TraversableInstances.Tree a) ->
                 let {
                   x1 :: Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
                   = Test.QuickCheck.Property.protectResults
                       (Test.QuickCheck.Property.MkRose
                          @ Test.QuickCheck.Property.Result
                          (case TraversableInstances.$fEqTree_$c== @ a $dEq a1 a' of wild {
                             GHC.Types.False -> Test.QuickCheck.Property.counterexample1
                             GHC.Types.True -> Test.QuickCheck.Property.succeeded })
                          (GHC.Types.[]
                             @ (Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result)))
                 } in
                 (\ (ds :: Test.QuickCheck.Random.QCGen) (ds1 :: GHC.Types.Int) ->
                  x1)
                   `cast`
                 (Trans
                      (Sym (Test.QuickCheck.Gen.N:Gen[0]
                                (Test.QuickCheck.Property.N:Prop[0])))
                      (Sym (Test.QuickCheck.Property.N:Property[0])))) -}
16e8ed280fd257d966e790ac1f8f5b85
  $s$fFoldableS ::
    Data.Foldable.Foldable
      (TraversableInstances.S TraversableInstances.Optional)
  {- Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (TraversableInstances.S TraversableInstances.Optional)
                  Main.$s$fFoldableS_$s$fFoldableS_$cfold
                  (TraversableInstances.$fFoldableS_$cfoldMap
                     @ TraversableInstances.Optional
                     Main.$s$fFoldableS_$dFoldable)
                  Main.$s$fFoldableS_$s$fFoldableS_$cfoldr
                  (TraversableInstances.$fFoldableS_$cfoldr'
                     @ TraversableInstances.Optional
                     Main.$s$fFoldableS_$dFoldable)
                  (TraversableInstances.$fFoldableS_$cfoldl
                     @ TraversableInstances.Optional
                     Main.$s$fFoldableS_$dFoldable)
                  (TraversableInstances.$fFoldableS_$cfoldl'
                     @ TraversableInstances.Optional
                     Main.$s$fFoldableS_$dFoldable)
                  (TraversableInstances.$fFoldableS_$cfoldr1
                     @ TraversableInstances.Optional
                     Main.$s$fFoldableS_$dFoldable)
                  (TraversableInstances.$fFoldableS_$cfoldl1
                     @ TraversableInstances.Optional
                     Main.$s$fFoldableS_$dFoldable)
                  Main.$s$fFoldableS_$s$fFoldableS_$ctoList
                  Main.$s$fFoldableS1
                  (TraversableInstances.$fFoldableS_$clength
                     @ TraversableInstances.Optional
                     Main.$s$fFoldableS_$dFoldable)
                  (TraversableInstances.$fFoldableS_$celem
                     @ TraversableInstances.Optional
                     Main.$s$fFoldableS_$dFoldable)
                  (TraversableInstances.$fFoldableS_$cmaximum
                     @ TraversableInstances.Optional
                     Main.$s$fFoldableS_$dFoldable)
                  (TraversableInstances.$fFoldableS_$cminimum
                     @ TraversableInstances.Optional
                     Main.$s$fFoldableS_$dFoldable)
                  (TraversableInstances.$fFoldableS_$csum
                     @ TraversableInstances.Optional
                     Main.$s$fFoldableS_$dFoldable)
                  (TraversableInstances.$fFoldableS_$cproduct
                     @ TraversableInstances.Optional
                     Main.$s$fFoldableS_$dFoldable) -}
c20f54cfcb4d51c8a2acc019076e337a
  $s$fFoldableS1 ::
    TraversableInstances.S TraversableInstances.Optional a
    -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a
                   (eta :: TraversableInstances.S TraversableInstances.Optional a) ->
                 case eta of wild { TraversableInstances.S n1 a1 ->
                 case n1 of wild1 { DEFAULT -> GHC.Types.False } }) -}
33b2537640bf54be09958cda4bdbcac1
  $s$fFoldableS_$dFoldable ::
    Data.Foldable.Foldable TraversableInstances.Optional
  {- Unfolding: InlineRule (0, True, True)
                TraversableInstances.$fFoldableOptional -}
7db6d4c486405a34d46fc181719cc7e5
  $s$fFoldableS_$s$fFoldableS_$cfold ::
    GHC.Base.Monoid m =>
    TraversableInstances.S TraversableInstances.Optional m -> m
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LC(C(S))L),U(1*U,C(C1(U)),A)><S,1*U(1*U,U)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ m
                   ($dMonoid :: GHC.Base.Monoid m)
                   (ds :: TraversableInstances.S TraversableInstances.Optional m) ->
                 case ds of wild { TraversableInstances.S n1 a ->
                 GHC.Base.mappend
                   @ m
                   $dMonoid
                   (TraversableInstances.$fFoldableOptional_$cfoldr
                      @ m
                      @ m
                      (\ (x :: m)[OneShot] ->
                       GHC.Base.mappend @ m $dMonoid (GHC.Base.id @ m x))
                      (GHC.Base.mempty @ m $dMonoid)
                      n1)
                   a }) -}
f45c49be4d625cedb5b1b8719edd58ee
  $s$fFoldableS_$s$fFoldableS_$cfoldr ::
    (a -> b -> b)
    -> b -> TraversableInstances.S TraversableInstances.Optional a -> b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(C(S)),C(C1(U))><L,U><S(SL),1*U(1*U,U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ b
                   (f :: a -> b -> b)
                   (z :: b)
                   (t1 :: TraversableInstances.S TraversableInstances.Optional a) ->
                 case t1 of wild { TraversableInstances.S n1 a1 ->
                 (TraversableInstances.$fFoldableOptional_$cfoldr
                    @ a
                    @ (Data.Monoid.Endo b)
                    (\ (x :: a)[OneShot] ->
                     Data.Monoid.$fMonoidEndo_$cmappend
                       @ b
                       (f x) `cast` (Sym (Data.Monoid.N:Endo[0] <b>_R)))
                    (GHC.Base.id @ b) `cast` (Sym (Data.Monoid.N:Endo[0] <b>_R))
                    n1)
                   `cast`
                 (Data.Monoid.N:Endo[0] <b>_R)
                   (f a1 z) }) -}
a01e72dc4c9f08ef2a0dd4f16c6e4319
  $s$fFoldableS_$s$fFoldableS_$ctoList ::
    TraversableInstances.S TraversableInstances.Optional a -> [a]
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U,U)>m2,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ a
                   (t1 :: TraversableInstances.S TraversableInstances.Optional a) ->
                 GHC.Base.build
                   @ a
                   (\ @ b (c :: a -> b -> b)[OneShot] (n1 :: b)[OneShot] ->
                    Main.$s$fFoldableS_$s$fFoldableS_$cfoldr @ a @ b c n1 t1)) -}
10c53a8523fa8abc4d2e9991f1f16715
  $s$fFunctorS ::
    GHC.Base.Functor
      (TraversableInstances.S TraversableInstances.Optional)
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (TraversableInstances.S TraversableInstances.Optional)
                  Main.$s$fFunctorS2
                  Main.$s$fFunctorS1 -}
8194470966ada4208ef4aa6a8885117e
  $s$fFunctorS1 ::
    a
    -> TraversableInstances.S TraversableInstances.Optional b
    -> TraversableInstances.S TraversableInstances.Optional a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U(1*U,A)>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   @ b
                   (eta :: a)
                   (eta1 :: TraversableInstances.S TraversableInstances.Optional b) ->
                 case eta1 of wild { TraversableInstances.S n1 a1 ->
                 TraversableInstances.S
                   @ TraversableInstances.Optional
                   @ a
                   (case n1 of wild1 {
                      TraversableInstances.Nada -> TraversableInstances.Nada @ a
                      TraversableInstances.Yep a2 -> TraversableInstances.Yep @ a eta })
                   eta }) -}
f5fbfc82e406c571c2381d29c46417af
  $s$fFunctorS2 ::
    (a -> b)
    -> TraversableInstances.S TraversableInstances.Optional a
    -> TraversableInstances.S TraversableInstances.Optional b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U(1*U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   @ b
                   (f :: a -> b)
                   (ds :: TraversableInstances.S TraversableInstances.Optional a) ->
                 case ds of wild { TraversableInstances.S n1 a1 ->
                 TraversableInstances.S
                   @ TraversableInstances.Optional
                   @ b
                   (TraversableInstances.$fFunctorOptional_$cfmap @ a @ b f n1)
                   (f a1) }) -}
507bcb86145b30bcfa4f31de62fb34ec
  $s$fShow(,,) ::
    GHC.Show.Show (GHC.Types.Int, GHC.Types.Int, [GHC.Types.Int])
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (GHC.Types.Int, GHC.Types.Int, [GHC.Types.Int])
                  (GHC.Show.$fShow(,,)_$cshowsPrec
                     @ GHC.Types.Int
                     @ GHC.Types.Int
                     @ [GHC.Types.Int]
                     GHC.Show.$fShowInt
                     GHC.Show.$fShowInt
                     Main.$s$fShow(,,)1)
                  Main.$s$fShow(,,)_$s$fShow(,,)_$cshow
                  Main.$s$fShow(,,)_$s$fShow(,,)_$cshowList -}
ac5a6405ff2b427a57e0908153630407
  $s$fShow(,,)1 :: GHC.Show.Show [GHC.Types.Int]
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                GHC.Show.$fShow[]_$s$fShow[] -}
473f0dbb15984cd7116c08b9d2798e43
  $s$fShow(,,)2 ::
    GHC.Show.Show
      ([GHC.Types.Char], [GHC.Types.Char], [GHC.Types.Char])
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ ([GHC.Types.Char], [GHC.Types.Char], [GHC.Types.Char])
                  (GHC.Show.$fShow(,,)_$cshowsPrec
                     @ [GHC.Types.Char]
                     @ [GHC.Types.Char]
                     @ [GHC.Types.Char]
                     Main.$s$fShow(,,)3
                     Main.$s$fShow(,,)3
                     Main.$s$fShow(,,)3)
                  Main.$s$fShow(,,)_$s$fShow(,,)_$cshow1
                  Main.$s$fShow(,,)_$s$fShow(,,)_$cshowList1 -}
ad6813dd01cb90f69965734b31daa4b8
  $s$fShow(,,)3 :: GHC.Show.Show [GHC.Types.Char]
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                GHC.Show.$fShow[]_$s$fShow[]1 -}
a5ce8e528b4821684707cf778d590089
  $s$fShow(,,)_$s$fShow(,,)_$cshow ::
    (GHC.Types.Int, GHC.Types.Int, [GHC.Types.Int]) -> GHC.Base.String
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(1*U(U),U(U),U)>m2,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: (GHC.Types.Int, GHC.Types.Int, [GHC.Types.Int])) ->
                 GHC.Show.$fShow(,,)_$cshowsPrec
                   @ GHC.Types.Int
                   @ GHC.Types.Int
                   @ [GHC.Types.Int]
                   GHC.Show.$fShowInt
                   GHC.Show.$fShowInt
                   Main.$s$fShow(,,)1
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
16b4efa72ec15f9a31a0a41f47081bd9
  $s$fShow(,,)_$s$fShow(,,)_$cshow1 ::
    ([GHC.Types.Char], [GHC.Types.Char], [GHC.Types.Char])
    -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U,U,U)>m2,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: ([GHC.Types.Char], [GHC.Types.Char], [GHC.Types.Char])) ->
                 GHC.Show.$fShow(,,)_$cshowsPrec
                   @ [GHC.Types.Char]
                   @ [GHC.Types.Char]
                   @ [GHC.Types.Char]
                   Main.$s$fShow(,,)3
                   Main.$s$fShow(,,)3
                   Main.$s$fShow(,,)3
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
42b8640c47cdc1de96fa56e99a32a4d0
  $s$fShow(,,)_$s$fShow(,,)_$cshowList ::
    [(GHC.Types.Int, GHC.Types.Int, [GHC.Types.Int])] -> GHC.Show.ShowS
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: [(GHC.Types.Int, GHC.Types.Int, [GHC.Types.Int])])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (GHC.Types.Int, GHC.Types.Int, [GHC.Types.Int])
                   (GHC.Show.$fShow(,,)_$cshowsPrec
                      @ GHC.Types.Int
                      @ GHC.Types.Int
                      @ [GHC.Types.Int]
                      GHC.Show.$fShowInt
                      GHC.Show.$fShowInt
                      Main.$s$fShow(,,)1
                      GHC.Show.shows22)
                   eta
                   eta1) -}
ac3087fa1434a7c24a251ce324fd6c9d
  $s$fShow(,,)_$s$fShow(,,)_$cshowList1 ::
    [([GHC.Types.Char], [GHC.Types.Char], [GHC.Types.Char])]
    -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: [([GHC.Types.Char], [GHC.Types.Char],
                             [GHC.Types.Char])])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ ([GHC.Types.Char], [GHC.Types.Char], [GHC.Types.Char])
                   (GHC.Show.$fShow(,,)_$cshowsPrec
                      @ [GHC.Types.Char]
                      @ [GHC.Types.Char]
                      @ [GHC.Types.Char]
                      Main.$s$fShow(,,)3
                      Main.$s$fShow(,,)3
                      Main.$s$fShow(,,)3
                      GHC.Show.shows22)
                   eta
                   eta1) -}
32d85bcd52c740c8fb7ab072d4069f43
  $s$fShowConstant ::
    GHC.Show.Show
      (TraversableInstances.Constant
         (GHC.Types.Int, GHC.Types.Int, [GHC.Types.Int]) b)
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ b.
                  @ (TraversableInstances.Constant
                       (GHC.Types.Int, GHC.Types.Int, [GHC.Types.Int]) b)
                  (TraversableInstances.$fShowConstant_$cshowsPrec
                     @ (GHC.Types.Int, GHC.Types.Int, [GHC.Types.Int])
                     @ b
                     Main.$s$fShowConstant1)
                  (TraversableInstances.$fShowConstant_$cshow
                     @ (GHC.Types.Int, GHC.Types.Int, [GHC.Types.Int])
                     @ b
                     Main.$s$fShowConstant1)
                  (Main.$s$fShowConstant_$s$fShowConstant_$cshowList @ b) -}
8f36bb514924cabd32156c811aea3500
  $s$fShowConstant1 ::
    GHC.Show.Show (GHC.Types.Int, GHC.Types.Int, [GHC.Types.Int])
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True) Main.$s$fShow(,,) -}
fbd627c32e01a1fa7168921fea732c83
  $s$fShowConstant_$s$fShowConstant_$cshowList ::
    [TraversableInstances.Constant
       (GHC.Types.Int, GHC.Types.Int, [GHC.Types.Int]) b]
    -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ b
                   (eta :: [TraversableInstances.Constant
                              (GHC.Types.Int, GHC.Types.Int, [GHC.Types.Int]) b])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (TraversableInstances.Constant
                        (GHC.Types.Int, GHC.Types.Int, [GHC.Types.Int]) b)
                   (TraversableInstances.$fShowConstant_$cshowsPrec
                      @ (GHC.Types.Int, GHC.Types.Int, [GHC.Types.Int])
                      @ b
                      Main.$s$fShowConstant1
                      TraversableInstances.$fFoldableConstant1)
                   eta
                   eta1) -}
e0e644189bb60baea069e266017a68ae
  $s$fShowIdentity ::
    GHC.Show.Show (TraversableInstances.Identity GHC.Types.Int)
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (TraversableInstances.Identity GHC.Types.Int)
                  (TraversableInstances.$fShowIdentity_$cshowsPrec
                     @ GHC.Types.Int
                     GHC.Show.$fShowInt)
                  Main.$s$fShowIdentity_$s$fShowIdentity_$cshow
                  Main.$s$fShowIdentity_$s$fShowIdentity_$cshowList -}
464e96e9631c80388944e2192c293eb2
  $s$fShowIdentity_$s$fShowIdentity_$cshow ::
    TraversableInstances.Identity GHC.Types.Int -> GHC.Base.String
  {- Arity: 1, Strictness: <L,1*U(U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: TraversableInstances.Identity GHC.Types.Int) ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b
                      (c :: GHC.Types.Char -> b -> b)[OneShot]
                      (n :: b)[OneShot] ->
                    GHC.Base.foldr
                      @ GHC.Types.Char
                      @ b
                      c
                      n
                      TraversableInstances.$fShowIdentity1)
                   (GHC.Show.showSignedInt
                      TraversableInstances.$fShowBig2
                      x `cast` (TraversableInstances.N:Identity[0] <GHC.Types.Int>_R)
                      (GHC.Types.[] @ GHC.Types.Char))) -}
49fd546b92e10df585615418e60c49b2
  $s$fShowIdentity_$s$fShowIdentity_$cshowList ::
    [TraversableInstances.Identity GHC.Types.Int] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: [TraversableInstances.Identity GHC.Types.Int])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (TraversableInstances.Identity GHC.Types.Int)
                   (TraversableInstances.$fShowIdentity_$cshowsPrec
                      @ GHC.Types.Int
                      GHC.Show.$fShowInt
                      TraversableInstances.$fFoldableConstant1)
                   eta
                   eta1) -}
5d2e3f15933394208a51696097731e05
  $s$fShowList ::
    GHC.Show.Show (TraversableInstances.List GHC.Types.Int)
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (TraversableInstances.List GHC.Types.Int)
                  (TraversableInstances.$fShowList_$cshowsPrec
                     @ GHC.Types.Int
                     GHC.Show.$fShowInt)
                  Main.$s$fShowList_$s$fShowList_$cshow
                  Main.$s$fShowList_$s$fShowList_$cshowList -}
cf1891cc37cd89adbb0eaea44bf0cb00
  $s$fShowList_$s$fShowList_$cshow ::
    TraversableInstances.List GHC.Types.Int -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: TraversableInstances.List GHC.Types.Int) ->
                 TraversableInstances.$fShowList_$cshowsPrec
                   @ GHC.Types.Int
                   GHC.Show.$fShowInt
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
3e42a4df70e54d3ff921961dd6ad8287
  $s$fShowList_$s$fShowList_$cshowList ::
    [TraversableInstances.List GHC.Types.Int] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: [TraversableInstances.List GHC.Types.Int])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (TraversableInstances.List GHC.Types.Int)
                   (TraversableInstances.$fShowList_$cshowsPrec
                      @ GHC.Types.Int
                      GHC.Show.$fShowInt
                      TraversableInstances.$fFoldableConstant1)
                   eta
                   eta1) -}
3bcc7b441a5e99e9b1dcb27ace21a3e9
  $s$fShowMaybe :: GHC.Show.Show (GHC.Base.Maybe GHC.Types.Int)
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (GHC.Base.Maybe GHC.Types.Int)
                  (GHC.Show.$fShowMaybe_$cshowsPrec
                     @ GHC.Types.Int
                     GHC.Show.$fShowInt)
                  (GHC.Show.$fShowMaybe_$cshow @ GHC.Types.Int GHC.Show.$fShowInt)
                  Main.$s$fShowMaybe_$s$fShowMaybe_$cshowList -}
94e1a8285cab8934b829bd3a97915f53
  $s$fShowMaybe_$s$fShowMaybe_$cshowList ::
    [GHC.Base.Maybe GHC.Types.Int] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: [GHC.Base.Maybe GHC.Types.Int])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (GHC.Base.Maybe GHC.Types.Int)
                   (GHC.Show.$fShowMaybe_$cshowsPrec
                      @ GHC.Types.Int
                      GHC.Show.$fShowInt
                      GHC.Show.shows22)
                   eta
                   eta1) -}
69b18006a60cdec41dbade43336d79cb
  $s$fShowOptional ::
    GHC.Show.Show (TraversableInstances.Optional GHC.Types.Int)
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (TraversableInstances.Optional GHC.Types.Int)
                  (TraversableInstances.$fShowOptional_$cshowsPrec
                     @ GHC.Types.Int
                     GHC.Show.$fShowInt)
                  (TraversableInstances.$fShowOptional_$cshow
                     @ GHC.Types.Int
                     GHC.Show.$fShowInt)
                  Main.$s$fShowOptional_$s$fShowOptional_$cshowList -}
44ec091cf9302429b2dd49773c41f33d
  $s$fShowOptional_$s$fShowOptional_$cshowList ::
    [TraversableInstances.Optional GHC.Types.Int] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: [TraversableInstances.Optional GHC.Types.Int])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (TraversableInstances.Optional GHC.Types.Int)
                   (TraversableInstances.$fShowOptional_$cshowsPrec
                      @ GHC.Types.Int
                      GHC.Show.$fShowInt
                      TraversableInstances.$fFoldableConstant1)
                   eta
                   eta1) -}
3be3a02abd9271b36b1b98d990754666
  $s$fShowS ::
    GHC.Show.Show
      (TraversableInstances.S
         TraversableInstances.Optional GHC.Types.Int)
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (TraversableInstances.S
                       TraversableInstances.Optional GHC.Types.Int)
                  (TraversableInstances.$fShowS_$cshowsPrec
                     @ TraversableInstances.Optional
                     @ GHC.Types.Int
                     Main.$s$fShowS1
                     GHC.Show.$fShowInt)
                  Main.$s$fShowS_$s$fShowS_$cshow
                  Main.$s$fShowS_$s$fShowS_$cshowList -}
e842f97ba97205c9fcab3f934413195a
  $s$fShowS1 ::
    GHC.Show.Show (TraversableInstances.Optional GHC.Types.Int)
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True) Main.$s$fShowOptional -}
d3277373360c2279b1e7a6f11167cd52
  $s$fShowS_$s$fShowS_$cshow ::
    TraversableInstances.S TraversableInstances.Optional GHC.Types.Int
    -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U,1*U(U))>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: TraversableInstances.S
                           TraversableInstances.Optional GHC.Types.Int) ->
                 TraversableInstances.$fShowS_$cshowsPrec
                   @ TraversableInstances.Optional
                   @ GHC.Types.Int
                   Main.$s$fShowS1
                   GHC.Show.$fShowInt
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
ae6c16993256593cf254a3b87a51a6ef
  $s$fShowS_$s$fShowS_$cshowList ::
    [TraversableInstances.S
       TraversableInstances.Optional GHC.Types.Int]
    -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: [TraversableInstances.S
                              TraversableInstances.Optional GHC.Types.Int])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (TraversableInstances.S
                        TraversableInstances.Optional GHC.Types.Int)
                   (TraversableInstances.$fShowS_$cshowsPrec
                      @ TraversableInstances.Optional
                      @ GHC.Types.Int
                      Main.$s$fShowS1
                      GHC.Show.$fShowInt
                      TraversableInstances.$fFoldableConstant1)
                   eta
                   eta1) -}
73059c3fca9357531d59b19ecfd8056a
  $s$fShowThree ::
    GHC.Show.Show
      (TraversableInstances.Three
         (GHC.Types.Int, GHC.Types.Int, [GHC.Types.Int])
         (GHC.Base.String, GHC.Base.String, GHC.Base.String)
         (GHC.Base.Maybe GHC.Types.Int))
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (TraversableInstances.Three
                       (GHC.Types.Int, GHC.Types.Int, [GHC.Types.Int])
                       (GHC.Base.String, GHC.Base.String, GHC.Base.String)
                       (GHC.Base.Maybe GHC.Types.Int))
                  (TraversableInstances.$fShowThree_$cshowsPrec
                     @ (GHC.Types.Int, GHC.Types.Int, [GHC.Types.Int])
                     @ (GHC.Base.String, GHC.Base.String, GHC.Base.String)
                     @ (GHC.Base.Maybe GHC.Types.Int)
                     Main.$s$fShowThree_$dShow
                     Main.$s$fShowThree_$dShow1
                     Main.$s$fShowConstant1)
                  Main.$s$fShowThree_$s$fShowThree_$cshow
                  Main.$s$fShowThree_$s$fShowThree_$cshowList -}
782393469108cbdb2951ee88ece7a3d2
  $s$fShowThree_$dShow ::
    GHC.Show.Show (GHC.Base.Maybe GHC.Types.Int)
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True) Main.$s$fShowMaybe -}
36f26da88c9127575a4b85d30bb50bfa
  $s$fShowThree_$dShow1 ::
    GHC.Show.Show (GHC.Base.String, GHC.Base.String, GHC.Base.String)
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True) Main.$s$fShow(,,)2 -}
54fe8291e4789813a84823e8e6755ada
  $s$fShowThree_$s$fShowThree_$cshow ::
    TraversableInstances.Three
      (GHC.Types.Int, GHC.Types.Int, [GHC.Types.Int])
      (GHC.Base.String, GHC.Base.String, GHC.Base.String)
      (GHC.Base.Maybe GHC.Types.Int)
    -> GHC.Base.String
  {- Arity: 1,
     Strictness: <S,1*U(1*U(1*U(U),U(U),U),1*U(1*U,U,U),1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: TraversableInstances.Three
                           (GHC.Types.Int, GHC.Types.Int, [GHC.Types.Int])
                           (GHC.Base.String, GHC.Base.String, GHC.Base.String)
                           (GHC.Base.Maybe GHC.Types.Int)) ->
                 TraversableInstances.$fShowThree_$cshowsPrec
                   @ (GHC.Types.Int, GHC.Types.Int, [GHC.Types.Int])
                   @ (GHC.Base.String, GHC.Base.String, GHC.Base.String)
                   @ (GHC.Base.Maybe GHC.Types.Int)
                   Main.$s$fShowThree_$dShow
                   Main.$s$fShowThree_$dShow1
                   Main.$s$fShowConstant1
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
725e07673a27b4e5561ebb2f7d235454
  $s$fShowThree_$s$fShowThree_$cshowList ::
    [TraversableInstances.Three
       (GHC.Types.Int, GHC.Types.Int, [GHC.Types.Int])
       (GHC.Base.String, GHC.Base.String, GHC.Base.String)
       (GHC.Base.Maybe GHC.Types.Int)]
    -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: [TraversableInstances.Three
                              (GHC.Types.Int, GHC.Types.Int, [GHC.Types.Int])
                              (GHC.Base.String, GHC.Base.String, GHC.Base.String)
                              (GHC.Base.Maybe GHC.Types.Int)])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (TraversableInstances.Three
                        (GHC.Types.Int, GHC.Types.Int, [GHC.Types.Int])
                        (GHC.Base.String, GHC.Base.String, GHC.Base.String)
                        (GHC.Base.Maybe GHC.Types.Int))
                   (TraversableInstances.$fShowThree_$cshowsPrec
                      @ (GHC.Types.Int, GHC.Types.Int, [GHC.Types.Int])
                      @ (GHC.Base.String, GHC.Base.String, GHC.Base.String)
                      @ (GHC.Base.Maybe GHC.Types.Int)
                      Main.$s$fShowThree_$dShow
                      Main.$s$fShowThree_$dShow1
                      Main.$s$fShowConstant1
                      TraversableInstances.$fFoldableConstant1)
                   eta
                   eta1) -}
4f04b51a7d973d3fa9f33f9325bd6c18
  $s$fShowTree ::
    GHC.Show.Show (TraversableInstances.Tree GHC.Types.Int)
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (TraversableInstances.Tree GHC.Types.Int)
                  (TraversableInstances.$fShowTree_$cshowsPrec
                     @ GHC.Types.Int
                     GHC.Show.$fShowInt)
                  Main.$s$fShowTree_$s$fShowTree_$cshow
                  Main.$s$fShowTree_$s$fShowTree_$cshowList -}
e72105eca506e6bc5c2ca6be2524843b
  $s$fShowTree_$s$fShowTree_$cshow ::
    TraversableInstances.Tree GHC.Types.Int -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: TraversableInstances.Tree GHC.Types.Int) ->
                 TraversableInstances.$fShowTree_$cshowsPrec
                   @ GHC.Types.Int
                   GHC.Show.$fShowInt
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
04154c34356ab73d775f8753080823b4
  $s$fShowTree_$s$fShowTree_$cshowList ::
    [TraversableInstances.Tree GHC.Types.Int] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: [TraversableInstances.Tree GHC.Types.Int])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (TraversableInstances.Tree GHC.Types.Int)
                   (TraversableInstances.$fShowTree_$cshowsPrec
                      @ GHC.Types.Int
                      GHC.Show.$fShowInt
                      TraversableInstances.$fFoldableConstant1)
                   eta
                   eta1) -}
31c4d834dbe00604e348ba581d70c770
  $s$fTraversableS ::
    Data.Traversable.Traversable
      (TraversableInstances.S TraversableInstances.Optional)
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (TraversableInstances.S TraversableInstances.Optional)
                  Main.$s$fTraversableS_$s$fTraversableS_$cp1Traversable
                  Main.$s$fTraversableS_$s$fTraversableS_$cp2Traversable
                  (TraversableInstances.$fTraversableS_$ctraverse
                     @ TraversableInstances.Optional
                     TraversableInstances.$fTraversableOptional)
                  (TraversableInstances.$fTraversableS_$csequenceA
                     @ TraversableInstances.Optional
                     TraversableInstances.$fTraversableOptional)
                  Main.$s$fTraversableS_$s$fTraversableS_$cmapM
                  Main.$s$fTraversableS_$s$fTraversableS_$csequence -}
7e0d9ae64a2af6c7b813f5abe6d63eba
  $s$fTraversableS_$s$fTraversableS_$cmapM ::
    GHC.Base.Monad m =>
    (a -> m b)
    -> TraversableInstances.S TraversableInstances.Optional a
    -> m (TraversableInstances.S TraversableInstances.Optional b)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(SLLLL),1*U(1*U,A,A,A,A)><L,C(U)><S,1*U(1*U,U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ (m :: * -> *)
                   @ a
                   @ b
                   ($dMonad :: GHC.Base.Monad m)
                   (eta :: a -> m b)
                   (eta1 :: TraversableInstances.S TraversableInstances.Optional a) ->
                 TraversableInstances.$fTraversableS_$ctraverse
                   @ TraversableInstances.Optional
                   TraversableInstances.$fTraversableOptional
                   @ m
                   @ a
                   @ b
                   (GHC.Base.$p1Monad @ m $dMonad)
                   eta
                   eta1) -}
5ab626740146f31ea48074669dc6a651
  $s$fTraversableS_$s$fTraversableS_$cp1Traversable ::
    GHC.Base.Functor
      (TraversableInstances.S TraversableInstances.Optional)
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True) Main.$s$fFunctorS -}
899cbceb6f7e1016c0c221790b651487
  $s$fTraversableS_$s$fTraversableS_$cp2Traversable ::
    Data.Foldable.Foldable
      (TraversableInstances.S TraversableInstances.Optional)
  {- Unfolding: InlineRule (0, True, True) Main.$s$fFoldableS -}
1180985a31bc2dba209113fe5ac4c9df
  $s$fTraversableS_$s$fTraversableS_$csequence ::
    GHC.Base.Monad m =>
    TraversableInstances.S TraversableInstances.Optional (m a)
    -> m (TraversableInstances.S TraversableInstances.Optional a)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLLLL),1*U(1*U,A,A,A,A)><S,1*U(1*U,U)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ (m :: * -> *)
                   @ a
                   ($dMonad :: GHC.Base.Monad m)
                   (eta :: TraversableInstances.S
                             TraversableInstances.Optional (m a)) ->
                 TraversableInstances.$fTraversableS_$csequenceA
                   @ TraversableInstances.Optional
                   TraversableInstances.$fTraversableOptional
                   @ m
                   @ a
                   (GHC.Base.$p1Monad @ m $dMonad)
                   eta) -}
3ef1fd1aa519509051f5c9770070fc76
  $straversable1 ::
    [GHC.Types.Int]
    -> [GHC.Types.Int] -> Test.QuickCheck.Property.Property
  {- Arity: 2,
     Unfolding: (Test.QuickCheck.Checkers.$fEqProp[]_$c=-=
                   @ GHC.Types.Int
                   Test.QuickCheck.Checkers.$fEqPropInt_$c=-=
                     `cast`
                   (Sym (Test.QuickCheck.Checkers.N:EqProp[0] <GHC.Types.Int>_N))) -}
81d9fe691d9d03b86e4a42c5fec7de0b
  $straversable10 ::
    [GHC.Types.Char]
    -> Test.QuickCheck.Gen.Gen b -> Test.QuickCheck.Gen.Gen b
  {- Arity: 1,
     Unfolding: (Test.QuickCheck.Arbitrary.$fCoArbitrary(->)_$ccoarbitrary1
                   @ GHC.Types.Char
                   Test.QuickCheck.Arbitrary.$fCoArbitraryChar1
                     `cast`
                   (Trans
                        (forall (b2 :: <*>_N).
                         <GHC.Types.Char>_R
                         ->_R <Test.QuickCheck.Gen.Gen b2>_R
                         ->_R Sym (Test.QuickCheck.Gen.N:Gen[0] <b2>_R))
                        (Sym (Test.QuickCheck.Arbitrary.N:CoArbitrary[0]
                                  <GHC.Types.Char>_N)))) -}
669d67598717384a7bd32ac5e5399669
  $straversable13 ::
    GHC.Base.Maybe GHC.Types.Int
    -> Test.QuickCheck.Gen.Gen b2
    -> Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int
    -> b2
  {- Arity: 4,
     Strictness: <S,1*U><C(C(S)),1*C1(C1(U))><L,1*U(U,U,U,1*U,A,A)><L,U>,
     Unfolding: (\ @ b2
                   (ds1 :: GHC.Base.Maybe GHC.Types.Int)
                   (eta :: Test.QuickCheck.Gen.Gen b2)
                   (eta1 :: Test.QuickCheck.Random.QCGen)
                   (eta2 :: GHC.Types.Int) ->
                 case ds1 of wild {
                   GHC.Base.Nothing
                   -> Test.QuickCheck.Arbitrary.$fCoArbitraryFirst2 @ b2 eta eta1 eta2
                   GHC.Base.Just x
                   -> Test.QuickCheck.Arbitrary.$fCoArbitraryFirst1
                        @ b2
                        (Test.QuickCheck.Arbitrary.$fCoArbitraryChar2 @ b2 x eta)
                          `cast`
                        (Sym (Test.QuickCheck.Gen.N:Gen[0] <b2>_R))
                        eta1
                        eta2 }) -}
098fce8cf6bcfe7f89d7285899bad281
  $straversable8 ::
    [GHC.Types.Char]
    -> [GHC.Types.Char] -> Test.QuickCheck.Property.Property
  {- Arity: 2,
     Unfolding: (Test.QuickCheck.Checkers.$fEqProp[]_$c=-=
                   @ GHC.Types.Char
                   Test.QuickCheck.Checkers.$fEqPropChar_$c=-=
                     `cast`
                   (Sym (Test.QuickCheck.Checkers.N:EqProp[0] <GHC.Types.Char>_N))) -}
d6831ef04cb9301b090dfae6f7bb7ec7
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module Main.$trModule2 Main.$trModule1) -}
847d9fc3b8e6f0b424199f36b4999bb2
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Main"#) -}
24ef6042833e75ffd7aa98b83ecca98d
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "main"#) -}
dd1ec311dcb1a8accd67fdb2383fd1f9
  $w$carbitrary ::
    (Test.QuickCheck.Arbitrary.Arbitrary a,
     Test.QuickCheck.Arbitrary.Arbitrary b) =>
    Test.QuickCheck.Random.QCGen -> GHC.Types.Int -> (# a, b, b #)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><L,U(C(C1(U)),A)><L,1*U(U,U,U,1*U,A,A)><L,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   @ b
                   (w :: Test.QuickCheck.Arbitrary.Arbitrary a)
                   (w1 :: Test.QuickCheck.Arbitrary.Arbitrary b)
                   (w2 :: Test.QuickCheck.Random.QCGen)
                   (w3 :: GHC.Types.Int) ->
                 let {
                   ds1 :: (Test.QuickCheck.Random.QCGen, Test.QuickCheck.Random.QCGen)
                   = case w2
                            `cast`
                          (Test.QuickCheck.Random.N:QCGen[0]) of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                     case System.Random.TF.Gen.$wtfGenSplit
                            ww1
                            ww2
                            ww3
                            ww4 of ww7 { (#,#) ww8 ww9 ->
                     (ww8 `cast` (Sym (Test.QuickCheck.Random.N:QCGen[0])),
                      ww9 `cast` (Sym (Test.QuickCheck.Random.N:QCGen[0]))) } }
                 } in
                 let {
                   ds2 :: (Test.QuickCheck.Random.QCGen, Test.QuickCheck.Random.QCGen)
                   = case ds1 of wild { (,) r1 r2 ->
                     case r2
                            `cast`
                          (Test.QuickCheck.Random.N:QCGen[0]) of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                     case System.Random.TF.Gen.$wtfGenSplit
                            ww1
                            ww2
                            ww3
                            ww4 of ww7 { (#,#) ww8 ww9 ->
                     (ww8 `cast` (Sym (Test.QuickCheck.Random.N:QCGen[0])),
                      ww9 `cast` (Sym (Test.QuickCheck.Random.N:QCGen[0]))) } } }
                 } in
                 (# (Test.QuickCheck.Arbitrary.arbitrary @ a w)
                      `cast`
                    (Test.QuickCheck.Gen.N:Gen[0] <a>_R)
                      (case ds1 of wild { (,) r1 r2 -> r1 })
                      w3,
                    (Test.QuickCheck.Arbitrary.arbitrary @ b w1)
                      `cast`
                    (Test.QuickCheck.Gen.N:Gen[0] <b>_R)
                      (case ds2 of wild { (,) r1 r2 -> r1 })
                      w3,
                    (Test.QuickCheck.Arbitrary.arbitrary @ b w1)
                      `cast`
                    (Test.QuickCheck.Gen.N:Gen[0] <b>_R)
                      (case ds2 of wild { (,) r1 r2 ->
                       case r2
                              `cast`
                            (Test.QuickCheck.Random.N:QCGen[0]) of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                       case System.Random.TF.Gen.$wtfGenSplit
                              ww1
                              ww2
                              ww3
                              ww4 of ww7 { (#,#) ww8 ww9 ->
                       ww8 `cast` (Sym (Test.QuickCheck.Random.N:QCGen[0])) } } })
                      w3 #)) -}
e9cd1425b5ee6e75044b84bccdd4903b
  $w$carbitrary1 ::
    (Test.QuickCheck.Arbitrary.Arbitrary a,
     Test.QuickCheck.Arbitrary.Arbitrary b) =>
    Test.QuickCheck.Random.QCGen -> GHC.Types.Int -> (# a, b, b, b #)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><L,U(C(C1(U)),A)><L,1*U(U,U,U,1*U,A,A)><L,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   @ b
                   (w :: Test.QuickCheck.Arbitrary.Arbitrary a)
                   (w1 :: Test.QuickCheck.Arbitrary.Arbitrary b)
                   (w2 :: Test.QuickCheck.Random.QCGen)
                   (w3 :: GHC.Types.Int) ->
                 let {
                   ds1 :: (Test.QuickCheck.Random.QCGen, Test.QuickCheck.Random.QCGen)
                   = case w2
                            `cast`
                          (Test.QuickCheck.Random.N:QCGen[0]) of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                     case System.Random.TF.Gen.$wtfGenSplit
                            ww1
                            ww2
                            ww3
                            ww4 of ww7 { (#,#) ww8 ww9 ->
                     (ww8 `cast` (Sym (Test.QuickCheck.Random.N:QCGen[0])),
                      ww9 `cast` (Sym (Test.QuickCheck.Random.N:QCGen[0]))) } }
                 } in
                 let {
                   ds2 :: (Test.QuickCheck.Random.QCGen, Test.QuickCheck.Random.QCGen)
                   = case ds1 of wild { (,) r1 r2 ->
                     case r2
                            `cast`
                          (Test.QuickCheck.Random.N:QCGen[0]) of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                     case System.Random.TF.Gen.$wtfGenSplit
                            ww1
                            ww2
                            ww3
                            ww4 of ww7 { (#,#) ww8 ww9 ->
                     (ww8 `cast` (Sym (Test.QuickCheck.Random.N:QCGen[0])),
                      ww9 `cast` (Sym (Test.QuickCheck.Random.N:QCGen[0]))) } } }
                 } in
                 let {
                   ds3 :: (Test.QuickCheck.Random.QCGen, Test.QuickCheck.Random.QCGen)
                   = case ds2 of wild { (,) r1 r2 ->
                     case r2
                            `cast`
                          (Test.QuickCheck.Random.N:QCGen[0]) of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                     case System.Random.TF.Gen.$wtfGenSplit
                            ww1
                            ww2
                            ww3
                            ww4 of ww7 { (#,#) ww8 ww9 ->
                     (ww8 `cast` (Sym (Test.QuickCheck.Random.N:QCGen[0])),
                      ww9 `cast` (Sym (Test.QuickCheck.Random.N:QCGen[0]))) } } }
                 } in
                 (# (Test.QuickCheck.Arbitrary.arbitrary @ a w)
                      `cast`
                    (Test.QuickCheck.Gen.N:Gen[0] <a>_R)
                      (case ds1 of wild { (,) r1 r2 -> r1 })
                      w3,
                    (Test.QuickCheck.Arbitrary.arbitrary @ b w1)
                      `cast`
                    (Test.QuickCheck.Gen.N:Gen[0] <b>_R)
                      (case ds2 of wild { (,) r1 r2 -> r1 })
                      w3,
                    (Test.QuickCheck.Arbitrary.arbitrary @ b w1)
                      `cast`
                    (Test.QuickCheck.Gen.N:Gen[0] <b>_R)
                      (case ds3 of wild { (,) r1 r2 -> r1 })
                      w3,
                    (Test.QuickCheck.Arbitrary.arbitrary @ b w1)
                      `cast`
                    (Test.QuickCheck.Gen.N:Gen[0] <b>_R)
                      (case ds3 of wild { (,) r1 r2 ->
                       case r2
                              `cast`
                            (Test.QuickCheck.Random.N:QCGen[0]) of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                       case System.Random.TF.Gen.$wtfGenSplit
                              ww1
                              ww2
                              ww3
                              ww4 of ww7 { (#,#) ww8 ww9 ->
                       ww8 `cast` (Sym (Test.QuickCheck.Random.N:QCGen[0])) } } })
                      w3 #)) -}
740e1cc4c089e1819a822bec31dc02ef
  $w$carbitrary2 ::
    (Test.QuickCheck.Arbitrary.Arbitrary a,
     Test.QuickCheck.Arbitrary.Arbitrary b) =>
    Test.QuickCheck.Random.QCGen -> GHC.Types.Int -> (# a, b #)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(U,U,U,1*U,A,A)><L,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   @ b
                   (w :: Test.QuickCheck.Arbitrary.Arbitrary a)
                   (w1 :: Test.QuickCheck.Arbitrary.Arbitrary b)
                   (w2 :: Test.QuickCheck.Random.QCGen)
                   (w3 :: GHC.Types.Int) ->
                 let {
                   ds1 :: (Test.QuickCheck.Random.QCGen, Test.QuickCheck.Random.QCGen)
                   = case w2
                            `cast`
                          (Test.QuickCheck.Random.N:QCGen[0]) of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                     case System.Random.TF.Gen.$wtfGenSplit
                            ww1
                            ww2
                            ww3
                            ww4 of ww7 { (#,#) ww8 ww9 ->
                     (ww8 `cast` (Sym (Test.QuickCheck.Random.N:QCGen[0])),
                      ww9 `cast` (Sym (Test.QuickCheck.Random.N:QCGen[0]))) } }
                 } in
                 (# (Test.QuickCheck.Arbitrary.arbitrary @ a w)
                      `cast`
                    (Test.QuickCheck.Gen.N:Gen[0] <a>_R)
                      (case ds1 of wild { (,) r1 r2 -> r1 })
                      w3,
                    (Test.QuickCheck.Arbitrary.arbitrary @ b w1)
                      `cast`
                    (Test.QuickCheck.Gen.N:Gen[0] <b>_R)
                      (case ds1 of wild { (,) r1 r2 ->
                       case r2
                              `cast`
                            (Test.QuickCheck.Random.N:QCGen[0]) of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                       case System.Random.TF.Gen.$wtfGenSplit
                              ww1
                              ww2
                              ww3
                              ww4 of ww7 { (#,#) ww8 ww9 ->
                       ww8 `cast` (Sym (Test.QuickCheck.Random.N:QCGen[0])) } } })
                      w3 #)) -}
9ececc0bf5bcd355ef0835be1e9a475f
  $w$carbitrary3 ::
    (Test.QuickCheck.Arbitrary.Arbitrary (n a),
     Test.QuickCheck.Arbitrary.Arbitrary a) =>
    Test.QuickCheck.Random.QCGen -> GHC.Types.Int -> (# n a, a #)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(U,U,U,1*U,A,A)><L,U>,
     Inline: [0],
     Unfolding: (\ @ (n :: * -> *)
                   @ a
                   (w :: Test.QuickCheck.Arbitrary.Arbitrary (n a))
                   (w1 :: Test.QuickCheck.Arbitrary.Arbitrary a)
                   (w2 :: Test.QuickCheck.Random.QCGen)
                   (w3 :: GHC.Types.Int) ->
                 let {
                   ds1 :: (Test.QuickCheck.Random.QCGen, Test.QuickCheck.Random.QCGen)
                   = case w2
                            `cast`
                          (Test.QuickCheck.Random.N:QCGen[0]) of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                     case System.Random.TF.Gen.$wtfGenSplit
                            ww1
                            ww2
                            ww3
                            ww4 of ww7 { (#,#) ww8 ww9 ->
                     (ww8 `cast` (Sym (Test.QuickCheck.Random.N:QCGen[0])),
                      ww9 `cast` (Sym (Test.QuickCheck.Random.N:QCGen[0]))) } }
                 } in
                 (# (Test.QuickCheck.Arbitrary.arbitrary @ (n a) w)
                      `cast`
                    (Test.QuickCheck.Gen.N:Gen[0] <n a>_R)
                      (case ds1 of wild { (,) r1 r2 -> r1 })
                      w3,
                    (Test.QuickCheck.Arbitrary.arbitrary @ a w1)
                      `cast`
                    (Test.QuickCheck.Gen.N:Gen[0] <a>_R)
                      (case ds1 of wild { (,) r1 r2 ->
                       case r2
                              `cast`
                            (Test.QuickCheck.Random.N:QCGen[0]) of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                       case System.Random.TF.Gen.$wtfGenSplit
                              ww1
                              ww2
                              ww3
                              ww4 of ww7 { (#,#) ww8 ww9 ->
                       ww8 `cast` (Sym (Test.QuickCheck.Random.N:QCGen[0])) } } })
                      w3 #)) -}
d8bd002c8ff6592550fe3c87aa6550c1
  $w$carbitrary4 ::
    (Test.QuickCheck.Arbitrary.Arbitrary a,
     Test.QuickCheck.Arbitrary.Arbitrary b,
     Test.QuickCheck.Arbitrary.Arbitrary c) =>
    Test.QuickCheck.Random.QCGen -> GHC.Types.Int -> (# a, b, c #)
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(U,U,U,1*U,A,A)><L,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   @ b
                   @ c
                   (w :: Test.QuickCheck.Arbitrary.Arbitrary a)
                   (w1 :: Test.QuickCheck.Arbitrary.Arbitrary b)
                   (w2 :: Test.QuickCheck.Arbitrary.Arbitrary c)
                   (w3 :: Test.QuickCheck.Random.QCGen)
                   (w4 :: GHC.Types.Int) ->
                 let {
                   ds1 :: (Test.QuickCheck.Random.QCGen, Test.QuickCheck.Random.QCGen)
                   = case w3
                            `cast`
                          (Test.QuickCheck.Random.N:QCGen[0]) of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                     case System.Random.TF.Gen.$wtfGenSplit
                            ww1
                            ww2
                            ww3
                            ww4 of ww7 { (#,#) ww8 ww9 ->
                     (ww8 `cast` (Sym (Test.QuickCheck.Random.N:QCGen[0])),
                      ww9 `cast` (Sym (Test.QuickCheck.Random.N:QCGen[0]))) } }
                 } in
                 let {
                   ds2 :: (Test.QuickCheck.Random.QCGen, Test.QuickCheck.Random.QCGen)
                   = case ds1 of wild { (,) r1 r2 ->
                     case r2
                            `cast`
                          (Test.QuickCheck.Random.N:QCGen[0]) of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                     case System.Random.TF.Gen.$wtfGenSplit
                            ww1
                            ww2
                            ww3
                            ww4 of ww7 { (#,#) ww8 ww9 ->
                     (ww8 `cast` (Sym (Test.QuickCheck.Random.N:QCGen[0])),
                      ww9 `cast` (Sym (Test.QuickCheck.Random.N:QCGen[0]))) } } }
                 } in
                 (# (Test.QuickCheck.Arbitrary.arbitrary @ a w)
                      `cast`
                    (Test.QuickCheck.Gen.N:Gen[0] <a>_R)
                      (case ds1 of wild { (,) r1 r2 -> r1 })
                      w4,
                    (Test.QuickCheck.Arbitrary.arbitrary @ b w1)
                      `cast`
                    (Test.QuickCheck.Gen.N:Gen[0] <b>_R)
                      (case ds2 of wild { (,) r1 r2 -> r1 })
                      w4,
                    (Test.QuickCheck.Arbitrary.arbitrary @ c w2)
                      `cast`
                    (Test.QuickCheck.Gen.N:Gen[0] <c>_R)
                      (case ds2 of wild { (,) r1 r2 ->
                       case r2
                              `cast`
                            (Test.QuickCheck.Random.N:QCGen[0]) of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                       case System.Random.TF.Gen.$wtfGenSplit
                              ww1
                              ww2
                              ww3
                              ww4 of ww7 { (#,#) ww8 ww9 ->
                       ww8 `cast` (Sym (Test.QuickCheck.Random.N:QCGen[0])) } } })
                      w4 #)) -}
235f75a1246c28430bbfa7f9f8d71160
  type T1 = (GHC.Types.Int, GHC.Types.Int, [GHC.Types.Int])
0a68a565a9e691a957948ab0cfec997a
  type T2 = (GHC.Base.String, GHC.Base.String, GHC.Base.String)
3cc52b8c96814c7832b1bb9c9077a366
  type T3 =
    (GHC.Base.Maybe GHC.Types.Int, GHC.Types.Int, [GHC.Types.Int])
d9c0dee8a685c5ed422401aaa63f23bf
  main :: GHC.Types.IO ()
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (0, True, True)
                Main.main1 `cast` (Sym (GHC.Types.N:IO[0] <()>_R)) -}
01d62c2c484918d4b5d94b688c90c90e
  main1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1, Strictness: <S,U> -}
129a1a814fa667791781f32a098e848d
  main2 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1,
     Unfolding: (GHC.TopHandler.runMainIO1
                   @ ()
                   Main.main1 `cast` (Sym (GHC.Types.N:IO[0] <()>_R))) -}
instance Test.QuickCheck.Arbitrary.Arbitrary [TraversableInstances.Big]
  = Main.$fArbitraryBig
instance Test.QuickCheck.Arbitrary.Arbitrary [TraversableInstances.Bigger]
  = Main.$fArbitraryBigger
instance Test.QuickCheck.Arbitrary.Arbitrary [TraversableInstances.Constant]
  = Main.$fArbitraryConstant
instance Test.QuickCheck.Arbitrary.Arbitrary [TraversableInstances.Identity]
  = Main.$fArbitraryIdentity
instance Test.QuickCheck.Arbitrary.Arbitrary [TraversableInstances.List]
  = Main.$fArbitraryList
instance Test.QuickCheck.Arbitrary.Arbitrary [TraversableInstances.Optional]
  = Main.$fArbitraryOptional
instance Test.QuickCheck.Arbitrary.Arbitrary [TraversableInstances.Pair]
  = Main.$fArbitraryPair
instance Test.QuickCheck.Arbitrary.Arbitrary [TraversableInstances.S]
  = Main.$fArbitraryS
instance Test.QuickCheck.Arbitrary.Arbitrary [TraversableInstances.Three]
  = Main.$fArbitraryThree
instance Test.QuickCheck.Arbitrary.Arbitrary [TraversableInstances.Tree]
  = Main.$fArbitraryTree
instance Test.QuickCheck.Checkers.EqProp [TraversableInstances.Big]
  = Main.$fEqPropBig
instance Test.QuickCheck.Checkers.EqProp [TraversableInstances.Bigger]
  = Main.$fEqPropBigger
instance Test.QuickCheck.Checkers.EqProp [TraversableInstances.Constant]
  = Main.$fEqPropConstant
instance Test.QuickCheck.Checkers.EqProp [TraversableInstances.Identity]
  = Main.$fEqPropIdentity
instance Test.QuickCheck.Checkers.EqProp [TraversableInstances.List]
  = Main.$fEqPropList
instance Test.QuickCheck.Checkers.EqProp [TraversableInstances.Optional]
  = Main.$fEqPropOptional
instance Test.QuickCheck.Checkers.EqProp [TraversableInstances.Pair]
  = Main.$fEqPropPair
instance Test.QuickCheck.Checkers.EqProp [TraversableInstances.S]
  = Main.$fEqPropS
instance Test.QuickCheck.Checkers.EqProp [TraversableInstances.Three]
  = Main.$fEqPropThree
instance Test.QuickCheck.Checkers.EqProp [TraversableInstances.Tree]
  = Main.$fEqPropTree
"SPEC $cshrink @ (Int, Int, [Int]) @ (String, String,
                                     String) @ (Maybe Int)" [ALWAYS] forall ($dArbitrary :: Test.QuickCheck.Arbitrary.Arbitrary
                                                                                                                                                    (GHC.Base.Maybe
                                                                                                                                                       GHC.Types.Int))
                                                                                                                                  ($dArbitrary2 :: Test.QuickCheck.Arbitrary.Arbitrary
                                                                                                                                                     (GHC.Base.String,
                                                                                                                                                      GHC.Base.String,
                                                                                                                                                      GHC.Base.String))
                                                                                                                                  ($dArbitrary4 :: Test.QuickCheck.Arbitrary.Arbitrary
                                                                                                                                                     (GHC.Types.Int,
                                                                                                                                                      GHC.Types.Int,
                                                                                                                                                      [GHC.Types.Int]))
  Main.$fArbitraryThree_$cshrink @ (GHC.Types.Int, GHC.Types.Int,
                                    [GHC.Types.Int])
                                 @ (GHC.Base.String, GHC.Base.String, GHC.Base.String)
                                 @ (GHC.Base.Maybe GHC.Types.Int)
                                 $dArbitrary4
                                 $dArbitrary2
                                 $dArbitrary
  = Main.$fArbitraryThree_$s$cshrink
"SPEC $cshrink @ (Int, Int, [Int]) _" [ALWAYS] forall @ b
                                                      ($dArbitrary :: Test.QuickCheck.Arbitrary.Arbitrary
                                                                        (GHC.Types.Int,
                                                                         GHC.Types.Int,
                                                                         [GHC.Types.Int]))
  Main.$fArbitraryConstant_$cshrink @ (GHC.Types.Int, GHC.Types.Int,
                                       [GHC.Types.Int])
                                    @ b
                                    $dArbitrary
  = Main.$fArbitraryConstant_$s$cshrink @ b
"SPEC $cshrink @ Int" [ALWAYS] forall ($dArbitrary :: Test.QuickCheck.Arbitrary.Arbitrary
                                                        GHC.Types.Int)
  Main.$fArbitraryTree_$cshrink @ GHC.Types.Int $dArbitrary
  = Main.$fArbitraryTree_$s$cshrink
"SPEC $cshrink @ Int" [ALWAYS] forall ($dArbitrary :: Test.QuickCheck.Arbitrary.Arbitrary
                                                        GHC.Types.Int)
  Main.$fArbitraryList_$cshrink @ GHC.Types.Int $dArbitrary
  = Main.$fArbitraryList_$s$cshrink
"SPEC $cshrink @ Int" [ALWAYS] forall ($dArbitrary :: Test.QuickCheck.Arbitrary.Arbitrary
                                                        GHC.Types.Int)
  Main.$fArbitraryOptional_$cshrink @ GHC.Types.Int $dArbitrary
  = Main.$fArbitraryOptional_$s$cshrink
"SPEC $cshrink @ Int" [ALWAYS] forall ($dArbitrary :: Test.QuickCheck.Arbitrary.Arbitrary
                                                        GHC.Types.Int)
  Main.$fArbitraryIdentity_$cshrink @ GHC.Types.Int $dArbitrary
  = Main.$fArbitraryIdentity_$s$cshrink
"SPEC $cshrink @ Optional @ Int" [ALWAYS] forall ($dArbitrary :: Test.QuickCheck.Arbitrary.Arbitrary
                                                                   GHC.Types.Int)
                                                 ($dArbitrary2 :: Test.QuickCheck.Arbitrary.Arbitrary
                                                                    (TraversableInstances.Optional
                                                                       GHC.Types.Int))
  Main.$fArbitraryS_$cshrink @ TraversableInstances.Optional
                             @ GHC.Types.Int
                             $dArbitrary2
                             $dArbitrary
  = Main.$fArbitraryS_$s$cshrink
"SPEC $fArbitraryConstant @ (Int, Int, [Int]) _" [ALWAYS] forall @ b
                                                                 ($dArbitrary :: Test.QuickCheck.Arbitrary.Arbitrary
                                                                                   (GHC.Types.Int,
                                                                                    GHC.Types.Int,
                                                                                    [GHC.Types.Int]))
  Main.$fArbitraryConstant @ (GHC.Types.Int, GHC.Types.Int,
                              [GHC.Types.Int])
                           @ b
                           $dArbitrary
  = Main.$fArbitraryConstant_$s$fArbitraryConstant @ b
"SPEC $fArbitraryIdentity @ Int" [ALWAYS] forall ($dArbitrary :: Test.QuickCheck.Arbitrary.Arbitrary
                                                                   GHC.Types.Int)
  Main.$fArbitraryIdentity @ GHC.Types.Int $dArbitrary
  = Main.$fArbitraryIdentity_$s$fArbitraryIdentity
"SPEC $fArbitraryList @ Int" [ALWAYS] forall ($dArbitrary :: Test.QuickCheck.Arbitrary.Arbitrary
                                                               GHC.Types.Int)
  Main.$fArbitraryList @ GHC.Types.Int $dArbitrary
  = Main.$fArbitraryList_$s$fArbitraryList
"SPEC $fArbitraryOptional @ Int" [ALWAYS] forall ($dArbitrary :: Test.QuickCheck.Arbitrary.Arbitrary
                                                                   GHC.Types.Int)
  Main.$fArbitraryOptional @ GHC.Types.Int $dArbitrary
  = Main.$fArbitraryOptional_$s$fArbitraryOptional
"SPEC $fArbitraryS @ Optional @ Int" [ALWAYS] forall ($dArbitrary :: Test.QuickCheck.Arbitrary.Arbitrary
                                                                       GHC.Types.Int)
                                                     ($dArbitrary2 :: Test.QuickCheck.Arbitrary.Arbitrary
                                                                        (TraversableInstances.Optional
                                                                           GHC.Types.Int))
  Main.$fArbitraryS @ TraversableInstances.Optional
                    @ GHC.Types.Int
                    $dArbitrary2
                    $dArbitrary
  = Main.$fArbitraryS_$s$fArbitraryS
"SPEC $fArbitraryThree @ (Int, Int, [Int]) @ (String, String,
                                             String) @ (Maybe Int)" [ALWAYS] forall ($dArbitrary :: Test.QuickCheck.Arbitrary.Arbitrary
                                                                                                                                                                    (GHC.Base.Maybe
                                                                                                                                                                       GHC.Types.Int))
                                                                                                                                                  ($dArbitrary2 :: Test.QuickCheck.Arbitrary.Arbitrary
                                                                                                                                                                     (GHC.Base.String,
                                                                                                                                                                      GHC.Base.String,
                                                                                                                                                                      GHC.Base.String))
                                                                                                                                                  ($dArbitrary4 :: Test.QuickCheck.Arbitrary.Arbitrary
                                                                                                                                                                     (GHC.Types.Int,
                                                                                                                                                                      GHC.Types.Int,
                                                                                                                                                                      [GHC.Types.Int]))
  Main.$fArbitraryThree @ (GHC.Types.Int, GHC.Types.Int,
                           [GHC.Types.Int])
                        @ (GHC.Base.String, GHC.Base.String, GHC.Base.String)
                        @ (GHC.Base.Maybe GHC.Types.Int)
                        $dArbitrary4
                        $dArbitrary2
                        $dArbitrary
  = Main.$fArbitraryThree_$s$fArbitraryThree
"SPEC $fArbitraryTree @ Int" [ALWAYS] forall ($dArbitrary :: Test.QuickCheck.Arbitrary.Arbitrary
                                                               GHC.Types.Int)
  Main.$fArbitraryTree @ GHC.Types.Int $dArbitrary
  = Main.$fArbitraryTree_$s$fArbitraryTree
"SPEC/Main $fArbitrary(,,) @ Int @ Int @ [Int]" [ALWAYS] forall ($dArbitrary2 :: Test.QuickCheck.Arbitrary.Arbitrary
                                                                                   [GHC.Types.Int])
                                                                ($dArbitrary5 :: Test.QuickCheck.Arbitrary.Arbitrary
                                                                                   GHC.Types.Int)
                                                                ($dArbitrary :: Test.QuickCheck.Arbitrary.Arbitrary
                                                                                  GHC.Types.Int)
  Test.QuickCheck.Arbitrary.$fArbitrary(,,) @ GHC.Types.Int
                                            @ GHC.Types.Int
                                            @ [GHC.Types.Int]
                                            $dArbitrary
                                            $dArbitrary5
                                            $dArbitrary2
  = Main.$fArbitraryConstant_$s$fArbitrary(,,)
"SPEC/Main $fArbitrary(,,) @ [Char] @ [Char] @ [Char]" [ALWAYS] forall ($dArbitrary2 :: Test.QuickCheck.Arbitrary.Arbitrary
                                                                                          [GHC.Types.Char])
                                                                       ($dArbitrary5 :: Test.QuickCheck.Arbitrary.Arbitrary
                                                                                          [GHC.Types.Char])
                                                                       ($dArbitrary :: Test.QuickCheck.Arbitrary.Arbitrary
                                                                                         [GHC.Types.Char])
  Test.QuickCheck.Arbitrary.$fArbitrary(,,) @ [GHC.Types.Char]
                                            @ [GHC.Types.Char]
                                            @ [GHC.Types.Char]
                                            $dArbitrary
                                            $dArbitrary5
                                            $dArbitrary2
  = Main.$fArbitraryThree_$s$fArbitrary(,,)
"SPEC/Main $fArbitraryMaybe @ Int" [ALWAYS] forall ($dArbitrary :: Test.QuickCheck.Arbitrary.Arbitrary
                                                                     GHC.Types.Int)
  Test.QuickCheck.Arbitrary.$fArbitraryMaybe @ GHC.Types.Int
                                             $dArbitrary
  = Main.$fArbitraryThree_$s$fArbitraryMaybe
"SPEC/Main $fArbitrary[] @ Char" [ALWAYS] forall ($dArbitrary :: Test.QuickCheck.Arbitrary.Arbitrary
                                                                   GHC.Types.Char)
  Test.QuickCheck.Arbitrary.$fArbitrary[] @ GHC.Types.Char
                                          $dArbitrary
  = Main.$fArbitraryThree_$s$fArbitrary[]
"SPEC/Main $fArbitrary[] @ Int" [ALWAYS] forall ($dArbitrary :: Test.QuickCheck.Arbitrary.Arbitrary
                                                                  GHC.Types.Int)
  Test.QuickCheck.Arbitrary.$fArbitrary[] @ GHC.Types.Int $dArbitrary
  = Main.$fArbitraryConstant_$s$fArbitrary[]
"SPEC/Main $fArbitrary[]_$cshrink @ Char" [ALWAYS] forall ($dArbitrary :: Test.QuickCheck.Arbitrary.Arbitrary
                                                                            GHC.Types.Char)
  Test.QuickCheck.Arbitrary.$fArbitrary[]_$cshrink @ GHC.Types.Char
                                                   $dArbitrary
  = Main.$fArbitraryThree_$s$fArbitrary[]_$cshrink
"SPEC/Main $fArbitrary[]_$cshrink @ Int" [ALWAYS] forall ($dArbitrary :: Test.QuickCheck.Arbitrary.Arbitrary
                                                                           GHC.Types.Int)
  Test.QuickCheck.Arbitrary.$fArbitrary[]_$cshrink @ GHC.Types.Int
                                                   $dArbitrary
  = Main.$fArbitraryConstant_$s$fArbitrary[]_$cshrink
"SPEC/Main $fFoldableS @ Optional" [ALWAYS] forall ($dFoldable :: Data.Foldable.Foldable
                                                                    TraversableInstances.Optional)
  TraversableInstances.$fFoldableS @ TraversableInstances.Optional
                                   $dFoldable
  = Main.$s$fFoldableS
"SPEC/Main $fFoldableS_$cfold @ Optional" [ALWAYS] forall ($dFoldable :: Data.Foldable.Foldable
                                                                           TraversableInstances.Optional)
  TraversableInstances.$fFoldableS_$cfold @ TraversableInstances.Optional
                                          $dFoldable
  = Main.$s$fFoldableS_$s$fFoldableS_$cfold
"SPEC/Main $fFoldableS_$cfoldr @ Optional" [ALWAYS] forall ($dFoldable :: Data.Foldable.Foldable
                                                                            TraversableInstances.Optional)
  TraversableInstances.$fFoldableS_$cfoldr @ TraversableInstances.Optional
                                           $dFoldable
  = Main.$s$fFoldableS_$s$fFoldableS_$cfoldr
"SPEC/Main $fFoldableS_$ctoList @ Optional" [ALWAYS] forall ($dFoldable :: Data.Foldable.Foldable
                                                                             TraversableInstances.Optional)
  TraversableInstances.$fFoldableS_$ctoList @ TraversableInstances.Optional
                                            $dFoldable
  = Main.$s$fFoldableS_$s$fFoldableS_$ctoList
"SPEC/Main $fFunctorS @ Optional" [ALWAYS] forall ($dFunctor :: GHC.Base.Functor
                                                                  TraversableInstances.Optional)
  TraversableInstances.$fFunctorS @ TraversableInstances.Optional
                                  $dFunctor
  = Main.$s$fFunctorS
"SPEC/Main $fShow(,,) @ Int @ Int @ [Int]" [ALWAYS] forall ($dShow2 :: GHC.Show.Show
                                                                         [GHC.Types.Int])
                                                           ($dShow1 :: GHC.Show.Show GHC.Types.Int)
                                                           ($dShow :: GHC.Show.Show GHC.Types.Int)
  GHC.Show.$fShow(,,) @ GHC.Types.Int
                      @ GHC.Types.Int
                      @ [GHC.Types.Int]
                      $dShow
                      $dShow1
                      $dShow2
  = Main.$s$fShow(,,)
"SPEC/Main $fShow(,,) @ [Char] @ [Char] @ [Char]" [ALWAYS] forall ($dShow2 :: GHC.Show.Show
                                                                                [GHC.Types.Char])
                                                                  ($dShow1 :: GHC.Show.Show
                                                                                [GHC.Types.Char])
                                                                  ($dShow :: GHC.Show.Show
                                                                               [GHC.Types.Char])
  GHC.Show.$fShow(,,) @ [GHC.Types.Char]
                      @ [GHC.Types.Char]
                      @ [GHC.Types.Char]
                      $dShow
                      $dShow1
                      $dShow2
  = Main.$s$fShow(,,)2
"SPEC/Main $fShow(,,)_$cshow @ Int @ Int @ [Int]" [ALWAYS] forall ($dShow2 :: GHC.Show.Show
                                                                                [GHC.Types.Int])
                                                                  ($dShow1 :: GHC.Show.Show
                                                                                GHC.Types.Int)
                                                                  ($dShow :: GHC.Show.Show
                                                                               GHC.Types.Int)
  GHC.Show.$fShow(,,)_$cshow @ GHC.Types.Int
                             @ GHC.Types.Int
                             @ [GHC.Types.Int]
                             $dShow
                             $dShow1
                             $dShow2
  = Main.$s$fShow(,,)_$s$fShow(,,)_$cshow
"SPEC/Main $fShow(,,)_$cshow @ [Char] @ [Char] @ [Char]" [ALWAYS] forall ($dShow2 :: GHC.Show.Show
                                                                                       [GHC.Types.Char])
                                                                         ($dShow1 :: GHC.Show.Show
                                                                                       [GHC.Types.Char])
                                                                         ($dShow :: GHC.Show.Show
                                                                                      [GHC.Types.Char])
  GHC.Show.$fShow(,,)_$cshow @ [GHC.Types.Char]
                             @ [GHC.Types.Char]
                             @ [GHC.Types.Char]
                             $dShow
                             $dShow1
                             $dShow2
  = Main.$s$fShow(,,)_$s$fShow(,,)_$cshow1
"SPEC/Main $fShow(,,)_$cshowList @ Int @ Int @ [Int]" [ALWAYS] forall ($dShow2 :: GHC.Show.Show
                                                                                    [GHC.Types.Int])
                                                                      ($dShow1 :: GHC.Show.Show
                                                                                    GHC.Types.Int)
                                                                      ($dShow :: GHC.Show.Show
                                                                                   GHC.Types.Int)
  GHC.Show.$fShow(,,)_$cshowList @ GHC.Types.Int
                                 @ GHC.Types.Int
                                 @ [GHC.Types.Int]
                                 $dShow
                                 $dShow1
                                 $dShow2
  = Main.$s$fShow(,,)_$s$fShow(,,)_$cshowList
"SPEC/Main $fShow(,,)_$cshowList @ [Char] @ [Char] @ [Char]" [ALWAYS] forall ($dShow2 :: GHC.Show.Show
                                                                                           [GHC.Types.Char])
                                                                             ($dShow1 :: GHC.Show.Show
                                                                                           [GHC.Types.Char])
                                                                             ($dShow :: GHC.Show.Show
                                                                                          [GHC.Types.Char])
  GHC.Show.$fShow(,,)_$cshowList @ [GHC.Types.Char]
                                 @ [GHC.Types.Char]
                                 @ [GHC.Types.Char]
                                 $dShow
                                 $dShow1
                                 $dShow2
  = Main.$s$fShow(,,)_$s$fShow(,,)_$cshowList1
"SPEC/Main $fShowConstant @ (Int, Int, [Int]) _" [ALWAYS] forall @ b
                                                                 ($dShow :: GHC.Show.Show
                                                                              (GHC.Types.Int,
                                                                               GHC.Types.Int,
                                                                               [GHC.Types.Int]))
  TraversableInstances.$fShowConstant @ (GHC.Types.Int,
                                         GHC.Types.Int, [GHC.Types.Int])
                                      @ b
                                      $dShow
  = Main.$s$fShowConstant @ b
"SPEC/Main $fShowConstant_$cshowList @ (Int, Int, [Int]) _" [ALWAYS] forall @ b
                                                                            ($dShow :: GHC.Show.Show
                                                                                         (GHC.Types.Int,
                                                                                          GHC.Types.Int,
                                                                                          [GHC.Types.Int]))
  TraversableInstances.$fShowConstant_$cshowList @ (GHC.Types.Int,
                                                    GHC.Types.Int, [GHC.Types.Int])
                                                 @ b
                                                 $dShow
  = Main.$s$fShowConstant_$s$fShowConstant_$cshowList @ b
"SPEC/Main $fShowIdentity @ Int" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                              GHC.Types.Int)
  TraversableInstances.$fShowIdentity @ GHC.Types.Int $dShow
  = Main.$s$fShowIdentity
"SPEC/Main $fShowIdentity_$cshow @ Int" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                                     GHC.Types.Int)
  TraversableInstances.$fShowIdentity_$cshow @ GHC.Types.Int $dShow
  = Main.$s$fShowIdentity_$s$fShowIdentity_$cshow
"SPEC/Main $fShowIdentity_$cshowList @ Int" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                                         GHC.Types.Int)
  TraversableInstances.$fShowIdentity_$cshowList @ GHC.Types.Int
                                                 $dShow
  = Main.$s$fShowIdentity_$s$fShowIdentity_$cshowList
"SPEC/Main $fShowList @ Int" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                          GHC.Types.Int)
  TraversableInstances.$fShowList @ GHC.Types.Int $dShow
  = Main.$s$fShowList
"SPEC/Main $fShowList_$cshow @ Int" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                                 GHC.Types.Int)
  TraversableInstances.$fShowList_$cshow @ GHC.Types.Int $dShow
  = Main.$s$fShowList_$s$fShowList_$cshow
"SPEC/Main $fShowList_$cshowList @ Int" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                                     GHC.Types.Int)
  TraversableInstances.$fShowList_$cshowList @ GHC.Types.Int $dShow
  = Main.$s$fShowList_$s$fShowList_$cshowList
"SPEC/Main $fShowMaybe @ Int" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                           GHC.Types.Int)
  GHC.Show.$fShowMaybe @ GHC.Types.Int $dShow = Main.$s$fShowMaybe
"SPEC/Main $fShowMaybe_$cshowList @ Int" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                                      GHC.Types.Int)
  GHC.Show.$fShowMaybe_$cshowList @ GHC.Types.Int $dShow
  = Main.$s$fShowMaybe_$s$fShowMaybe_$cshowList
"SPEC/Main $fShowOptional @ Int" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                              GHC.Types.Int)
  TraversableInstances.$fShowOptional @ GHC.Types.Int $dShow
  = Main.$s$fShowOptional
"SPEC/Main $fShowOptional_$cshowList @ Int" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                                         GHC.Types.Int)
  TraversableInstances.$fShowOptional_$cshowList @ GHC.Types.Int
                                                 $dShow
  = Main.$s$fShowOptional_$s$fShowOptional_$cshowList
"SPEC/Main $fShowS @ Optional @ Int" [ALWAYS] forall ($dShow1 :: GHC.Show.Show
                                                                   GHC.Types.Int)
                                                     ($dShow :: GHC.Show.Show
                                                                  (TraversableInstances.Optional
                                                                     GHC.Types.Int))
  TraversableInstances.$fShowS @ TraversableInstances.Optional
                               @ GHC.Types.Int
                               $dShow
                               $dShow1
  = Main.$s$fShowS
"SPEC/Main $fShowS_$cshow @ Optional @ Int" [ALWAYS] forall ($dShow1 :: GHC.Show.Show
                                                                          GHC.Types.Int)
                                                            ($dShow :: GHC.Show.Show
                                                                         (TraversableInstances.Optional
                                                                            GHC.Types.Int))
  TraversableInstances.$fShowS_$cshow @ TraversableInstances.Optional
                                      @ GHC.Types.Int
                                      $dShow
                                      $dShow1
  = Main.$s$fShowS_$s$fShowS_$cshow
"SPEC/Main $fShowS_$cshowList @ Optional @ Int" [ALWAYS] forall ($dShow1 :: GHC.Show.Show
                                                                              GHC.Types.Int)
                                                                ($dShow :: GHC.Show.Show
                                                                             (TraversableInstances.Optional
                                                                                GHC.Types.Int))
  TraversableInstances.$fShowS_$cshowList @ TraversableInstances.Optional
                                          @ GHC.Types.Int
                                          $dShow
                                          $dShow1
  = Main.$s$fShowS_$s$fShowS_$cshowList
"SPEC/Main $fShowThree @ (Int, Int, [Int]) @ (String, String,
                                             String) @ (Maybe Int)" [ALWAYS] forall ($dShow2 :: GHC.Show.Show
                                                                                                                                                                (GHC.Types.Int,
                                                                                                                                                                 GHC.Types.Int,
                                                                                                                                                                 [GHC.Types.Int]))
                                                                                                                                                  ($dShow1 :: GHC.Show.Show
                                                                                                                                                                (GHC.Base.String,
                                                                                                                                                                 GHC.Base.String,
                                                                                                                                                                 GHC.Base.String))
                                                                                                                                                  ($dShow :: GHC.Show.Show
                                                                                                                                                               (GHC.Base.Maybe
                                                                                                                                                                  GHC.Types.Int))
  TraversableInstances.$fShowThree @ (GHC.Types.Int, GHC.Types.Int,
                                      [GHC.Types.Int])
                                   @ (GHC.Base.String, GHC.Base.String, GHC.Base.String)
                                   @ (GHC.Base.Maybe GHC.Types.Int)
                                   $dShow
                                   $dShow1
                                   $dShow2
  = Main.$s$fShowThree
"SPEC/Main $fShowThree_$cshow @ (Int, Int, [Int]) @ (String, String,
                                                    String) @ (Maybe Int)" [ALWAYS] forall ($dShow2 :: GHC.Show.Show
                                                                                                                                                                              (GHC.Types.Int,
                                                                                                                                                                               GHC.Types.Int,
                                                                                                                                                                               [GHC.Types.Int]))
                                                                                                                                                                ($dShow1 :: GHC.Show.Show
                                                                                                                                                                              (GHC.Base.String,
                                                                                                                                                                               GHC.Base.String,
                                                                                                                                                                               GHC.Base.String))
                                                                                                                                                                ($dShow :: GHC.Show.Show
                                                                                                                                                                             (GHC.Base.Maybe
                                                                                                                                                                                GHC.Types.Int))
  TraversableInstances.$fShowThree_$cshow @ (GHC.Types.Int,
                                             GHC.Types.Int, [GHC.Types.Int])
                                          @ (GHC.Base.String, GHC.Base.String, GHC.Base.String)
                                          @ (GHC.Base.Maybe GHC.Types.Int)
                                          $dShow
                                          $dShow1
                                          $dShow2
  = Main.$s$fShowThree_$s$fShowThree_$cshow
"SPEC/Main $fShowThree_$cshowList @ (Int, Int, [Int]) @ (String,
                                                        String, String) @ (Maybe Int)" [ALWAYS] forall ($dShow2 :: GHC.Show.Show
                                                                                                                                                                                      (GHC.Types.Int,
                                                                                                                                                                                       GHC.Types.Int,
                                                                                                                                                                                       [GHC.Types.Int]))
                                                                                                                                                                        ($dShow1 :: GHC.Show.Show
                                                                                                                                                                                      (GHC.Base.String,
                                                                                                                                                                                       GHC.Base.String,
                                                                                                                                                                                       GHC.Base.String))
                                                                                                                                                                        ($dShow :: GHC.Show.Show
                                                                                                                                                                                     (GHC.Base.Maybe
                                                                                                                                                                                        GHC.Types.Int))
  TraversableInstances.$fShowThree_$cshowList @ (GHC.Types.Int,
                                                 GHC.Types.Int, [GHC.Types.Int])
                                              @ (GHC.Base.String, GHC.Base.String, GHC.Base.String)
                                              @ (GHC.Base.Maybe GHC.Types.Int)
                                              $dShow
                                              $dShow1
                                              $dShow2
  = Main.$s$fShowThree_$s$fShowThree_$cshowList
"SPEC/Main $fShowTree @ Int" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                          GHC.Types.Int)
  TraversableInstances.$fShowTree @ GHC.Types.Int $dShow
  = Main.$s$fShowTree
"SPEC/Main $fShowTree_$cshow @ Int" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                                 GHC.Types.Int)
  TraversableInstances.$fShowTree_$cshow @ GHC.Types.Int $dShow
  = Main.$s$fShowTree_$s$fShowTree_$cshow
"SPEC/Main $fShowTree_$cshowList @ Int" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                                     GHC.Types.Int)
  TraversableInstances.$fShowTree_$cshowList @ GHC.Types.Int $dShow
  = Main.$s$fShowTree_$s$fShowTree_$cshowList
"SPEC/Main $fTraversableS @ Optional" [ALWAYS] forall ($dTraversable :: Data.Traversable.Traversable
                                                                          TraversableInstances.Optional)
  TraversableInstances.$fTraversableS @ TraversableInstances.Optional
                                      $dTraversable
  = Main.$s$fTraversableS
"SPEC/Main $fTraversableS_$cmapM @ Optional" [ALWAYS] forall ($dTraversable :: Data.Traversable.Traversable
                                                                                 TraversableInstances.Optional)
  TraversableInstances.$fTraversableS_$cmapM @ TraversableInstances.Optional
                                             $dTraversable
  = Main.$s$fTraversableS_$s$fTraversableS_$cmapM
"SPEC/Main $fTraversableS_$cp1Traversable @ Optional" [ALWAYS] forall ($dTraversable :: Data.Traversable.Traversable
                                                                                          TraversableInstances.Optional)
  TraversableInstances.$fTraversableS_$cp1Traversable @ TraversableInstances.Optional
                                                      $dTraversable
  = Main.$s$fTraversableS_$s$fTraversableS_$cp1Traversable
"SPEC/Main $fTraversableS_$cp2Traversable @ Optional" [ALWAYS] forall ($dTraversable :: Data.Traversable.Traversable
                                                                                          TraversableInstances.Optional)
  TraversableInstances.$fTraversableS_$cp2Traversable @ TraversableInstances.Optional
                                                      $dTraversable
  = Main.$s$fTraversableS_$s$fTraversableS_$cp2Traversable
"SPEC/Main $fTraversableS_$csequence @ Optional" [ALWAYS] forall ($dTraversable :: Data.Traversable.Traversable
                                                                                     TraversableInstances.Optional)
  TraversableInstances.$fTraversableS_$csequence @ TraversableInstances.Optional
                                                 $dTraversable
  = Main.$s$fTraversableS_$s$fTraversableS_$csequence
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

