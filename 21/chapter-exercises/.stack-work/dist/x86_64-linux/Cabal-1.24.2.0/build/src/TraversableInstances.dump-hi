
==================== FINAL INTERFACE ====================
2019-05-26 01:54:21.749396 UTC

interface chapter-exercises-0.1.0.0-MyTkAmxHPpEzugi6gUoOh:TraversableInstances 8002
  interface hash: a07bc34c3c51e087a60488f72e3b30b6
  ABI hash: 53464b372d99bd3f639eef1c441925a6
  export-list hash: 0bec4339f4814881d22b2390577dfc5d
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 91cd76246f60d900fce8e309e594df82
  sig of: Nothing
  used TH splices: False
  where
exports:
  TraversableInstances.Big{TraversableInstances.Big}
  TraversableInstances.Bigger{TraversableInstances.Bigger}
  TraversableInstances.Constant{TraversableInstances.Constant getConstant}
  TraversableInstances.Identity{TraversableInstances.Identity}
  TraversableInstances.List{TraversableInstances.Cons TraversableInstances.Nil}
  TraversableInstances.Optional{TraversableInstances.Nada TraversableInstances.Yep}
  TraversableInstances.Pair{TraversableInstances.Pair}
  TraversableInstances.S{TraversableInstances.S}
  TraversableInstances.Three{TraversableInstances.Three}
  TraversableInstances.Tree{TraversableInstances.Empty TraversableInstances.Leaf TraversableInstances.Node}
module dependencies:
package dependencies: base-4.9.1.0* ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1
orphans: base-4.9.1.0:GHC.Base base-4.9.1.0:GHC.Float
family instance modules: base-4.9.1.0:Control.Applicative
                         base-4.9.1.0:Data.Either base-4.9.1.0:Data.Functor.Const
                         base-4.9.1.0:Data.Monoid base-4.9.1.0:Data.Type.Equality
                         base-4.9.1.0:GHC.Generics base-4.9.1.0:GHC.IO.Exception
                         base-4.9.1.0:GHC.TypeLits
import  -/  base-4.9.1.0:Data.Foldable 3e0b6967a1da89945d0e2d47266337a2
import  -/  base-4.9.1.0:Data.Functor 5ab1dc703df5b482e77efb697833ca3c
import  -/  base-4.9.1.0:Data.Monoid 51cc9cd8c130d49ba96b7c2c2406022b
import  -/  base-4.9.1.0:Data.Traversable 556020d7cf3c4a34a774600512918a37
import  -/  base-4.9.1.0:GHC.Base c4231c43c07e46080a26bf94094c7aa1
import  -/  base-4.9.1.0:GHC.Show a027f5ac24879eaba752f44aa90fe511
import  -/  base-4.9.1.0:Prelude 22dd289b8469a8fa8dc81cab7b237771
import  -/  ghc-prim-0.5.0.0:GHC.Classes 0bdf3d057a415ec1b84a7b1994efbe47
import  -/  ghc-prim-0.5.0.0:GHC.Types 89f8de4f08018c9177c98d979eae0e45
cddb4f9513e650624772d2c687832791
  $fEqBig ::
    (GHC.Classes.Eq b, GHC.Classes.Eq a) =>
    GHC.Classes.Eq (TraversableInstances.Big a b)
  DFunId
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a
                      @ b
                      ($dEq :: GHC.Classes.Eq b)
                      ($dEq1 :: GHC.Classes.Eq a).
                  @ (TraversableInstances.Big a b)
                  (TraversableInstances.$fEqBig_$c== @ a @ b $dEq $dEq1)
                  (TraversableInstances.$fEqBig_$c/= @ a @ b $dEq $dEq1) -}
cddb4f9513e650624772d2c687832791
  $fEqBig_$c/= ::
    (GHC.Classes.Eq b, GHC.Classes.Eq a) =>
    TraversableInstances.Big a b
    -> TraversableInstances.Big a b -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S(C(C(S))L),1*U(1*C1(C1(U)),A)><S,1*U(U,U,U)><S,1*U(U,U,U)>,
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   @ b
                   ($dEq :: GHC.Classes.Eq b)
                   ($dEq1 :: GHC.Classes.Eq a)
                   (a1 :: TraversableInstances.Big a b)
                   (b1 :: TraversableInstances.Big a b) ->
                 case TraversableInstances.$fEqBig_$c==
                        @ a
                        @ b
                        $dEq
                        $dEq1
                        a1
                        b1 of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
cddb4f9513e650624772d2c687832791
  $fEqBig_$c== ::
    (GHC.Classes.Eq b, GHC.Classes.Eq a) =>
    TraversableInstances.Big a b
    -> TraversableInstances.Big a b -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S(C(C(S))L),1*U(1*C1(C1(U)),A)><S,1*U(U,U,U)><S,1*U(U,U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   @ b
                   (w :: GHC.Classes.Eq b)
                   (w1 :: GHC.Classes.Eq a)
                   (w2 :: TraversableInstances.Big a b)
                   (w3 :: TraversableInstances.Big a b) ->
                 case w2 of ww { TraversableInstances.Big ww1 ww2 ww3 ->
                 case w3 of ww4 { TraversableInstances.Big ww5 ww6 ww7 ->
                 TraversableInstances.$w$c==
                   @ a
                   @ b
                   w
                   w1
                   ww1
                   ww2
                   ww3
                   ww5
                   ww6
                   ww7 } }) -}
8373cb9b5cc904797ff1fb1bafd8cdce
  $fEqBigger ::
    (GHC.Classes.Eq b, GHC.Classes.Eq a) =>
    GHC.Classes.Eq (TraversableInstances.Bigger a b)
  DFunId
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a
                      @ b
                      ($dEq :: GHC.Classes.Eq b)
                      ($dEq1 :: GHC.Classes.Eq a).
                  @ (TraversableInstances.Bigger a b)
                  (TraversableInstances.$fEqBigger_$c== @ a @ b $dEq $dEq1)
                  (TraversableInstances.$fEqBigger_$c/= @ a @ b $dEq $dEq1) -}
8373cb9b5cc904797ff1fb1bafd8cdce
  $fEqBigger_$c/= ::
    (GHC.Classes.Eq b, GHC.Classes.Eq a) =>
    TraversableInstances.Bigger a b
    -> TraversableInstances.Bigger a b -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S(C(C(S))L),1*U(1*C1(C1(U)),A)><S,1*U(U,U,U,U)><S,1*U(U,U,U,U)>,
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   @ b
                   ($dEq :: GHC.Classes.Eq b)
                   ($dEq1 :: GHC.Classes.Eq a)
                   (a1 :: TraversableInstances.Bigger a b)
                   (b1 :: TraversableInstances.Bigger a b) ->
                 case TraversableInstances.$fEqBigger_$c==
                        @ a
                        @ b
                        $dEq
                        $dEq1
                        a1
                        b1 of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
8373cb9b5cc904797ff1fb1bafd8cdce
  $fEqBigger_$c== ::
    (GHC.Classes.Eq b, GHC.Classes.Eq a) =>
    TraversableInstances.Bigger a b
    -> TraversableInstances.Bigger a b -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S(C(C(S))L),1*U(1*C1(C1(U)),A)><S,1*U(U,U,U,U)><S,1*U(U,U,U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   @ b
                   (w :: GHC.Classes.Eq b)
                   (w1 :: GHC.Classes.Eq a)
                   (w2 :: TraversableInstances.Bigger a b)
                   (w3 :: TraversableInstances.Bigger a b) ->
                 case w2 of ww { TraversableInstances.Bigger ww1 ww2 ww3 ww4 ->
                 case w3 of ww5 { TraversableInstances.Bigger ww6 ww7 ww8 ww9 ->
                 TraversableInstances.$w$c==1
                   @ a
                   @ b
                   w
                   w1
                   ww1
                   ww2
                   ww3
                   ww4
                   ww6
                   ww7
                   ww8
                   ww9 } }) -}
a06a627f62d93f6fedbee61792bf9f78
  $fEqConstant ::
    GHC.Classes.Eq a =>
    GHC.Classes.Eq (TraversableInstances.Constant a b)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(1*U,1*U)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a @ b ($dEq :: GHC.Classes.Eq a).
                  @ (TraversableInstances.Constant a b)
                  (TraversableInstances.$fEqConstant_$c== @ a @ b $dEq)
                  (TraversableInstances.$fEqConstant_$c/= @ a @ b $dEq) -}
ea37c9a4b56b99029bffcb65cf864a7e
  $fEqConstant1 :: GHC.Classes.Eq a => a -> a -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),1*U(A,1*U)>,
     Unfolding: InlineRule (1, True, True)
                (\ @ a @ b ($dEq :: GHC.Classes.Eq a) ->
                 GHC.Classes./= @ a $dEq) -}
c593a0d9574c0dd097447cc1294e2178
  $fEqConstant2 :: GHC.Classes.Eq a => a -> a -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U,A)>,
     Unfolding: InlineRule (1, True, True)
                (\ @ a @ b ($dEq :: GHC.Classes.Eq a) ->
                 GHC.Classes.== @ a $dEq) -}
a06a627f62d93f6fedbee61792bf9f78
  $fEqConstant_$c/= ::
    GHC.Classes.Eq a =>
    TraversableInstances.Constant a b
    -> TraversableInstances.Constant a b -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),1*U(A,1*U)>,
     Unfolding: InlineRule (0, True, True)
                TraversableInstances.$fEqConstant1
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <GHC.Classes.Eq a>_R
                 ->_R Sym (TraversableInstances.N:Constant[0] <a>_R <b>_P)
                 ->_R Sym (TraversableInstances.N:Constant[0] <a>_R <b>_P)
                 ->_R <GHC.Types.Bool>_R) -}
a06a627f62d93f6fedbee61792bf9f78
  $fEqConstant_$c== ::
    GHC.Classes.Eq a =>
    TraversableInstances.Constant a b
    -> TraversableInstances.Constant a b -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U,A)>,
     Unfolding: InlineRule (0, True, True)
                TraversableInstances.$fEqConstant2
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <GHC.Classes.Eq a>_R
                 ->_R Sym (TraversableInstances.N:Constant[0] <a>_R <b>_P)
                 ->_R Sym (TraversableInstances.N:Constant[0] <a>_R <b>_P)
                 ->_R <GHC.Types.Bool>_R) -}
729de049f804209d218b6ac6412958e0
  $fEqIdentity ::
    GHC.Classes.Eq a =>
    GHC.Classes.Eq (TraversableInstances.Identity a)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(1*U,1*U)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dEq :: GHC.Classes.Eq a).
                  @ (TraversableInstances.Identity a)
                  (TraversableInstances.$fEqIdentity_$c== @ a $dEq)
                  (TraversableInstances.$fEqIdentity_$c/= @ a $dEq) -}
729de049f804209d218b6ac6412958e0
  $fEqIdentity_$c/= ::
    GHC.Classes.Eq a =>
    TraversableInstances.Identity a
    -> TraversableInstances.Identity a -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),U(A,U)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Classes./=
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Classes.Eq a>_R
                 ->_R Sym (TraversableInstances.N:Identity[0] <a>_R)
                 ->_R Sym (TraversableInstances.N:Identity[0] <a>_R)
                 ->_R <GHC.Types.Bool>_R) -}
729de049f804209d218b6ac6412958e0
  $fEqIdentity_$c== ::
    GHC.Classes.Eq a =>
    TraversableInstances.Identity a
    -> TraversableInstances.Identity a -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),U(U,A)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Classes.==
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Classes.Eq a>_R
                 ->_R Sym (TraversableInstances.N:Identity[0] <a>_R)
                 ->_R Sym (TraversableInstances.N:Identity[0] <a>_R)
                 ->_R <GHC.Types.Bool>_R) -}
b205c9375ec1b24a907de4864e47820f
  $fEqList ::
    GHC.Classes.Eq a => GHC.Classes.Eq (TraversableInstances.List a)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dEq :: GHC.Classes.Eq a).
                  @ (TraversableInstances.List a)
                  (TraversableInstances.$fEqList_$c== @ a $dEq)
                  (TraversableInstances.$fEqList_$c/= @ a $dEq) -}
b205c9375ec1b24a907de4864e47820f
  $fEqList_$c/= ::
    GHC.Classes.Eq a =>
    TraversableInstances.List a
    -> TraversableInstances.List a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dEq :: GHC.Classes.Eq a)
                   (a1 :: TraversableInstances.List a)
                   (b :: TraversableInstances.List a) ->
                 case TraversableInstances.$fEqList_$c== @ a $dEq a1 b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
b205c9375ec1b24a907de4864e47820f
  $fEqList_$c== ::
    GHC.Classes.Eq a =>
    TraversableInstances.List a
    -> TraversableInstances.List a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S,1*U><S,1*U> -}
9b0dc1c42b799f2c204b6c11f0bab139
  $fEqOptional ::
    GHC.Classes.Eq a =>
    GHC.Classes.Eq (TraversableInstances.Optional a)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dEq :: GHC.Classes.Eq a).
                  @ (TraversableInstances.Optional a)
                  (TraversableInstances.$fEqOptional_$c== @ a $dEq)
                  (TraversableInstances.$fEqOptional_$c/= @ a $dEq) -}
9b0dc1c42b799f2c204b6c11f0bab139
  $fEqOptional_$c/= ::
    GHC.Classes.Eq a =>
    TraversableInstances.Optional a
    -> TraversableInstances.Optional a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: (\ @ a
                   ($dEq :: GHC.Classes.Eq a)
                   (a1 :: TraversableInstances.Optional a)
                   (b :: TraversableInstances.Optional a) ->
                 case a1 of wild {
                   TraversableInstances.Nada
                   -> case b of wild1 {
                        TraversableInstances.Nada -> GHC.Types.False
                        TraversableInstances.Yep ipv -> GHC.Types.True }
                   TraversableInstances.Yep a2
                   -> case b of wild1 {
                        TraversableInstances.Nada -> GHC.Types.True
                        TraversableInstances.Yep b1
                        -> case GHC.Classes.== @ a $dEq a2 b1 of wild2 {
                             GHC.Types.False -> GHC.Types.True
                             GHC.Types.True -> GHC.Types.False } } }) -}
9b0dc1c42b799f2c204b6c11f0bab139
  $fEqOptional_$c== ::
    GHC.Classes.Eq a =>
    TraversableInstances.Optional a
    -> TraversableInstances.Optional a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dEq :: GHC.Classes.Eq a)
                   (ds :: TraversableInstances.Optional a)
                   (ds1 :: TraversableInstances.Optional a) ->
                 case ds of wild {
                   TraversableInstances.Nada
                   -> case ds1 of wild1 {
                        TraversableInstances.Nada -> GHC.Types.True
                        TraversableInstances.Yep ipv -> GHC.Types.False }
                   TraversableInstances.Yep a1
                   -> case ds1 of wild1 {
                        TraversableInstances.Nada -> GHC.Types.False
                        TraversableInstances.Yep b1
                        -> GHC.Classes.== @ a $dEq a1 b1 } }) -}
96406d61d01da17b40bba6954858f9d9
  $fEqPair ::
    (GHC.Classes.Eq b, GHC.Classes.Eq a) =>
    GHC.Classes.Eq (TraversableInstances.Pair a b)
  DFunId
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a
                      @ b
                      ($dEq :: GHC.Classes.Eq b)
                      ($dEq1 :: GHC.Classes.Eq a).
                  @ (TraversableInstances.Pair a b)
                  (TraversableInstances.$fEqPair_$c== @ a @ b $dEq $dEq1)
                  (TraversableInstances.$fEqPair_$c/= @ a @ b $dEq $dEq1) -}
96406d61d01da17b40bba6954858f9d9
  $fEqPair_$c/= ::
    (GHC.Classes.Eq b, GHC.Classes.Eq a) =>
    TraversableInstances.Pair a b
    -> TraversableInstances.Pair a b -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><S(C(C(S))L),1*U(1*C1(C1(U)),A)><S,1*U(U,U)><S,1*U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   @ b
                   (w :: GHC.Classes.Eq b)
                   (w1 :: GHC.Classes.Eq a)
                   (w2 :: TraversableInstances.Pair a b)
                   (w3 :: TraversableInstances.Pair a b) ->
                 case w2 of ww { TraversableInstances.Pair ww1 ww2 ->
                 case w3 of ww3 { TraversableInstances.Pair ww4 ww5 ->
                 TraversableInstances.$w$c/= @ a @ b w w1 ww1 ww2 ww4 ww5 } }) -}
96406d61d01da17b40bba6954858f9d9
  $fEqPair_$c== ::
    (GHC.Classes.Eq b, GHC.Classes.Eq a) =>
    TraversableInstances.Pair a b
    -> TraversableInstances.Pair a b -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><S(C(C(S))L),1*U(1*C1(C1(U)),A)><S,1*U(U,U)><S,1*U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   @ b
                   (w :: GHC.Classes.Eq b)
                   (w1 :: GHC.Classes.Eq a)
                   (w2 :: TraversableInstances.Pair a b)
                   (w3 :: TraversableInstances.Pair a b) ->
                 case w2 of ww { TraversableInstances.Pair ww1 ww2 ->
                 case w3 of ww3 { TraversableInstances.Pair ww4 ww5 ->
                 TraversableInstances.$w$c==2 @ a @ b w w1 ww1 ww2 ww4 ww5 } }) -}
830583bcd30f054061d98a8af9ec4905
  $fEqS ::
    (GHC.Classes.Eq (n a), GHC.Classes.Eq a) =>
    GHC.Classes.Eq (TraversableInstances.S n a)
  DFunId
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ (n :: * -> *)
                      @ a
                      ($dEq :: GHC.Classes.Eq (n a))
                      ($dEq1 :: GHC.Classes.Eq a).
                  @ (TraversableInstances.S n a)
                  (TraversableInstances.$fEqS_$c== @ n @ a $dEq $dEq1)
                  (TraversableInstances.$fEqS_$c/= @ n @ a $dEq $dEq1) -}
830583bcd30f054061d98a8af9ec4905
  $fEqS_$c/= ::
    (GHC.Classes.Eq (n a), GHC.Classes.Eq a) =>
    TraversableInstances.S n a
    -> TraversableInstances.S n a -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><S,1*U(U,U)><S,1*U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ @ (n :: * -> *)
                   @ a
                   (w :: GHC.Classes.Eq (n a))
                   (w1 :: GHC.Classes.Eq a)
                   (w2 :: TraversableInstances.S n a)
                   (w3 :: TraversableInstances.S n a) ->
                 case w2 of ww { TraversableInstances.S ww1 ww2 ->
                 case w3 of ww3 { TraversableInstances.S ww4 ww5 ->
                 TraversableInstances.$w$c/=1 @ n @ a w w1 ww1 ww2 ww4 ww5 } }) -}
830583bcd30f054061d98a8af9ec4905
  $fEqS_$c== ::
    (GHC.Classes.Eq (n a), GHC.Classes.Eq a) =>
    TraversableInstances.S n a
    -> TraversableInstances.S n a -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><S,1*U(U,U)><S,1*U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ @ (n :: * -> *)
                   @ a
                   (w :: GHC.Classes.Eq (n a))
                   (w1 :: GHC.Classes.Eq a)
                   (w2 :: TraversableInstances.S n a)
                   (w3 :: TraversableInstances.S n a) ->
                 case w2 of ww { TraversableInstances.S ww1 ww2 ->
                 case w3 of ww3 { TraversableInstances.S ww4 ww5 ->
                 TraversableInstances.$w$c==3 @ n @ a w w1 ww1 ww2 ww4 ww5 } }) -}
721a5d38cc38fed0984ecc96f773ca01
  $fEqThree ::
    (GHC.Classes.Eq c, GHC.Classes.Eq b, GHC.Classes.Eq a) =>
    GHC.Classes.Eq (TraversableInstances.Three a b c)
  DFunId
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><L,U(C(C1(U)),A)><L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a
                      @ b
                      @ c
                      ($dEq :: GHC.Classes.Eq c)
                      ($dEq1 :: GHC.Classes.Eq b)
                      ($dEq2 :: GHC.Classes.Eq a).
                  @ (TraversableInstances.Three a b c)
                  (TraversableInstances.$fEqThree_$c== @ a @ b @ c $dEq $dEq1 $dEq2)
                  (TraversableInstances.$fEqThree_$c/=
                     @ a
                     @ b
                     @ c
                     $dEq
                     $dEq1
                     $dEq2) -}
721a5d38cc38fed0984ecc96f773ca01
  $fEqThree_$c/= ::
    (GHC.Classes.Eq c, GHC.Classes.Eq b, GHC.Classes.Eq a) =>
    TraversableInstances.Three a b c
    -> TraversableInstances.Three a b c -> GHC.Types.Bool
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><S(C(C(S))L),1*U(1*C1(C1(U)),A)><S,1*U(U,U,U)><S,1*U(U,U,U)>,
     Unfolding: InlineRule (5, True, False)
                (\ @ a
                   @ b
                   @ c
                   ($dEq :: GHC.Classes.Eq c)
                   ($dEq1 :: GHC.Classes.Eq b)
                   ($dEq2 :: GHC.Classes.Eq a)
                   (a1 :: TraversableInstances.Three a b c)
                   (b1 :: TraversableInstances.Three a b c) ->
                 case TraversableInstances.$fEqThree_$c==
                        @ a
                        @ b
                        @ c
                        $dEq
                        $dEq1
                        $dEq2
                        a1
                        b1 of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
721a5d38cc38fed0984ecc96f773ca01
  $fEqThree_$c== ::
    (GHC.Classes.Eq c, GHC.Classes.Eq b, GHC.Classes.Eq a) =>
    TraversableInstances.Three a b c
    -> TraversableInstances.Three a b c -> GHC.Types.Bool
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><S(C(C(S))L),1*U(1*C1(C1(U)),A)><S,1*U(U,U,U)><S,1*U(U,U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (5, True, False)
                (\ @ a
                   @ b
                   @ c
                   (w :: GHC.Classes.Eq c)
                   (w1 :: GHC.Classes.Eq b)
                   (w2 :: GHC.Classes.Eq a)
                   (w3 :: TraversableInstances.Three a b c)
                   (w4 :: TraversableInstances.Three a b c) ->
                 case w3 of ww { TraversableInstances.Three ww1 ww2 ww3 ->
                 case w4 of ww4 { TraversableInstances.Three ww5 ww6 ww7 ->
                 TraversableInstances.$w$c==4
                   @ a
                   @ b
                   @ c
                   w
                   w1
                   w2
                   ww1
                   ww2
                   ww3
                   ww5
                   ww6
                   ww7 } }) -}
4ba7eb63788e9e9f6786ec57a70a2853
  $fEqTree ::
    GHC.Classes.Eq a => GHC.Classes.Eq (TraversableInstances.Tree a)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dEq :: GHC.Classes.Eq a).
                  @ (TraversableInstances.Tree a)
                  (TraversableInstances.$fEqTree_$c== @ a $dEq)
                  (TraversableInstances.$fEqTree_$c/= @ a $dEq) -}
4ba7eb63788e9e9f6786ec57a70a2853
  $fEqTree_$c/= ::
    GHC.Classes.Eq a =>
    TraversableInstances.Tree a
    -> TraversableInstances.Tree a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dEq :: GHC.Classes.Eq a)
                   (a1 :: TraversableInstances.Tree a)
                   (b :: TraversableInstances.Tree a) ->
                 case TraversableInstances.$fEqTree_$c== @ a $dEq a1 b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
4ba7eb63788e9e9f6786ec57a70a2853
  $fEqTree_$c== ::
    GHC.Classes.Eq a =>
    TraversableInstances.Tree a
    -> TraversableInstances.Tree a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S,1*U><S,1*U> -}
cddb4f9513e650624772d2c687832791
  $fFoldableBig ::
    Data.Foldable.Foldable (TraversableInstances.Big a)
  DFunId
  {- HasNoCafRefs, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a.
                  @ (TraversableInstances.Big a)
                  (TraversableInstances.$fFoldableBig_$cfold @ a)
                  (TraversableInstances.$fFoldableBig_$cfoldMap @ a)
                  (TraversableInstances.$fFoldableBig_$cfoldr @ a)
                  (TraversableInstances.$fFoldableBig_$cfoldr' @ a)
                  (TraversableInstances.$fFoldableBig_$cfoldl @ a)
                  (TraversableInstances.$fFoldableBig_$cfoldl' @ a)
                  (TraversableInstances.$fFoldableBig_$cfoldr1 @ a)
                  (TraversableInstances.$fFoldableBig_$cfoldr1 @ a)
                  (TraversableInstances.$fFoldableBig_$ctoList @ a)
                  (TraversableInstances.$fFoldableBig_$cnull @ a)
                  (TraversableInstances.$fFoldableBig_$clength @ a)
                  (TraversableInstances.$fFoldableBig_$celem @ a)
                  (TraversableInstances.$fFoldableBig_$cmaximum @ a)
                  (TraversableInstances.$fFoldableBig_$cminimum @ a)
                  (TraversableInstances.$fFoldableBig_$csum @ a)
                  (TraversableInstances.$fFoldableBig_$cproduct @ a) -}
cddb4f9513e650624772d2c687832791
  $fFoldableBig1 ::
    GHC.Num.Num a1 =>
    TraversableInstances.Big a a1 -> Data.Monoid.Product a1
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LLC(C(S))LLLL),1*U(A,A,1*C1(C1(U)),A,A,A,A)><S,1*U(A,U,U)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   @ a1
                   ($dNum :: GHC.Num.Num a1)
                   (ds :: TraversableInstances.Big a a1) ->
                 case ds of wild { TraversableInstances.Big ds1 b b' ->
                 (GHC.Num.* @ a1 $dNum b b')
                   `cast`
                 (Sym (Data.Monoid.N:Product[0] <a1>_R)) }) -}
cddb4f9513e650624772d2c687832791
  $fFoldableBig2 ::
    GHC.Num.Num a1 =>
    TraversableInstances.Big a a1 -> Data.Monoid.Sum a1
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(C(C(S))LLLLLL),1*U(1*C1(C1(U)),A,A,A,A,A,A)><S,1*U(A,U,U)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   @ a1
                   ($dNum :: GHC.Num.Num a1)
                   (ds :: TraversableInstances.Big a a1) ->
                 case ds of wild { TraversableInstances.Big ds1 b b' ->
                 (GHC.Num.+ @ a1 $dNum b b')
                   `cast`
                 (Sym (Data.Monoid.N:Sum[0] <a1>_R)) }) -}
cddb4f9513e650624772d2c687832791
  $fFoldableBig_$celem ::
    GHC.Classes.Eq a1 =>
    a1 -> TraversableInstances.Big a a1 -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(1*C1(U),A)><L,U>,
     Unfolding: (\ @ a @ a1 ($dEq :: GHC.Classes.Eq a1) (eta :: a1) ->
                 let {
                   f :: a1 -> GHC.Types.Bool = GHC.Classes.== @ a1 $dEq eta
                 } in
                 (\ (ds :: TraversableInstances.Big a a1) ->
                  case ds of wild { TraversableInstances.Big ds1 b b' ->
                  case f b of wild1 {
                    GHC.Types.False -> (f b') `cast` (Sym (Data.Monoid.N:Any[0]))
                    GHC.Types.True
                    -> GHC.Types.True `cast` (Sym (Data.Monoid.N:Any[0])) } })
                   `cast`
                 (<TraversableInstances.Big a a1>_R ->_R Data.Monoid.N:Any[0])) -}
cddb4f9513e650624772d2c687832791
  $fFoldableBig_$cfold ::
    GHC.Base.Monoid m => TraversableInstances.Big a m -> m
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LC(C(S))L),1*U(A,1*C1(C1(U)),A)><S,1*U(A,U,U)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   @ m
                   ($dMonoid :: GHC.Base.Monoid m)
                   (ds :: TraversableInstances.Big a m) ->
                 case ds of wild { TraversableInstances.Big ds1 b b' ->
                 GHC.Base.mappend @ m $dMonoid b b' }) -}
cddb4f9513e650624772d2c687832791
  $fFoldableBig_$cfoldMap ::
    GHC.Base.Monoid m =>
    (a1 -> m) -> TraversableInstances.Big a a1 -> m
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LC(C(S))L),1*U(A,1*C1(C1(U)),A)><L,C(U)><S,1*U(A,U,U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ m
                   @ a1
                   ($dMonoid :: GHC.Base.Monoid m)
                   (f :: a1 -> m)
                   (ds :: TraversableInstances.Big a a1) ->
                 case ds of wild { TraversableInstances.Big ds1 b b' ->
                 GHC.Base.mappend @ m $dMonoid (f b) (f b') }) -}
cddb4f9513e650624772d2c687832791
  $fFoldableBig_$cfoldl ::
    (b -> a1 -> b) -> b -> TraversableInstances.Big a a1 -> b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(C(S)),C(C1(U))><L,U><S,1*U(A,U,U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ b
                   @ a1
                   (f :: b -> a1 -> b)
                   (z :: b)
                   (t1 :: TraversableInstances.Big a a1) ->
                 case t1 of wild { TraversableInstances.Big ds b1 b' ->
                 f (f z b1) b' }) -}
cddb4f9513e650624772d2c687832791
  $fFoldableBig_$cfoldl' ::
    (b -> a1 -> b) -> b -> TraversableInstances.Big a a1 -> b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(C(S)),C(C1(U))><L,U><S,1*U(A,U,U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ b
                   @ a1
                   (f :: b -> a1 -> b)
                   (z0 :: b)
                   (xs :: TraversableInstances.Big a a1) ->
                 case xs of wild { TraversableInstances.Big ds b1 b' ->
                 case f z0 b1 of vx { DEFAULT -> f vx b' } }) -}
cddb4f9513e650624772d2c687832791
  $fFoldableBig_$cfoldr ::
    (a1 -> b -> b) -> b -> TraversableInstances.Big a a1 -> b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(C(S)),C(C1(U))><L,U><S,1*U(A,U,U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ a1
                   @ b
                   (f :: a1 -> b -> b)
                   (z :: b)
                   (t1 :: TraversableInstances.Big a a1) ->
                 case t1 of wild { TraversableInstances.Big ds b1 b' ->
                 f b1 (f b' z) }) -}
cddb4f9513e650624772d2c687832791
  $fFoldableBig_$cfoldr' ::
    (a1 -> b -> b) -> b -> TraversableInstances.Big a a1 -> b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(C(S)),C(C1(U))><L,U><S,1*U(A,U,U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ a1
                   @ b
                   (f :: a1 -> b -> b)
                   (z0 :: b)
                   (xs :: TraversableInstances.Big a a1) ->
                 case xs of wild { TraversableInstances.Big ds b1 b' ->
                 case f b' z0 of vx { DEFAULT -> f b1 vx } }) -}
cddb4f9513e650624772d2c687832791
  $fFoldableBig_$cfoldr1 ::
    (a1 -> a1 -> a1) -> TraversableInstances.Big a a1 -> a1
  {- Arity: 2, HasNoCafRefs,
     Strictness: <C(C(S)),1*C1(C1(U))><S,1*U(A,U,U)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   @ a1
                   (f :: a1 -> a1 -> a1)
                   (xs :: TraversableInstances.Big a a1) ->
                 case xs of wild { TraversableInstances.Big ds b b' -> f b b' }) -}
cddb4f9513e650624772d2c687832791
  $fFoldableBig_$clength ::
    TraversableInstances.Big a a1 -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*H>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ a @ a1 (xs :: TraversableInstances.Big a a1) ->
                 case xs of wild { TraversableInstances.Big ds b b' ->
                 GHC.Types.I# 2# }) -}
cddb4f9513e650624772d2c687832791
  $fFoldableBig_$cmaximum ::
    GHC.Classes.Ord a1 => TraversableInstances.Big a a1 -> a1
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LLLLLC(C(S))LL),1*U(A,A,A,A,A,1*C1(C1(U)),A,A)><S,1*U(A,U,U)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   @ a1
                   ($dOrd :: GHC.Classes.Ord a1)
                   (eta :: TraversableInstances.Big a a1) ->
                 case eta of wild { TraversableInstances.Big ds b b' ->
                 case GHC.Classes.>= @ a1 $dOrd b b' of wild2 {
                   GHC.Types.False -> b' GHC.Types.True -> b } }) -}
cddb4f9513e650624772d2c687832791
  $fFoldableBig_$cminimum ::
    GHC.Classes.Ord a1 => TraversableInstances.Big a a1 -> a1
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LLLC(C(S))LLLL),1*U(A,A,A,1*C1(C1(U)),A,A,A,A)><S,1*U(A,U,U)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   @ a1
                   ($dOrd :: GHC.Classes.Ord a1)
                   (eta :: TraversableInstances.Big a a1) ->
                 case eta of wild { TraversableInstances.Big ds b b' ->
                 case GHC.Classes.<= @ a1 $dOrd b b' of wild2 {
                   GHC.Types.False -> b' GHC.Types.True -> b } }) -}
cddb4f9513e650624772d2c687832791
  $fFoldableBig_$cnull ::
    TraversableInstances.Big a a1 -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*H>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a @ a1 (t1 :: TraversableInstances.Big a a1) ->
                 case t1 of wild { TraversableInstances.Big ds b b' ->
                 GHC.Types.False }) -}
cddb4f9513e650624772d2c687832791
  $fFoldableBig_$cproduct ::
    GHC.Num.Num a1 => TraversableInstances.Big a a1 -> a1
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LLC(C(S))LLLL),1*U(A,A,1*C1(C1(U)),A,A,A,A)><S,1*U(A,U,U)>,
     Unfolding: InlineRule (0, True, True)
                TraversableInstances.$fFoldableBig1
                  `cast`
                (forall (a :: <*>_N) (a1 :: <*>_N).
                 <GHC.Num.Num a1>_R
                 ->_R <TraversableInstances.Big a a1>_R
                 ->_R Data.Monoid.N:Product[0] <a1>_R) -}
cddb4f9513e650624772d2c687832791
  $fFoldableBig_$csum ::
    GHC.Num.Num a1 => TraversableInstances.Big a a1 -> a1
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(C(C(S))LLLLLL),1*U(1*C1(C1(U)),A,A,A,A,A,A)><S,1*U(A,U,U)>,
     Unfolding: InlineRule (0, True, True)
                TraversableInstances.$fFoldableBig2
                  `cast`
                (forall (a :: <*>_N) (a1 :: <*>_N).
                 <GHC.Num.Num a1>_R
                 ->_R <TraversableInstances.Big a a1>_R
                 ->_R Data.Monoid.N:Sum[0] <a1>_R) -}
cddb4f9513e650624772d2c687832791
  $fFoldableBig_$ctoList :: TraversableInstances.Big a a1 -> [a1]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ a @ a1 (t1 :: TraversableInstances.Big a a1) ->
                 GHC.Base.build
                   @ a1
                   (\ @ b (c :: a1 -> b -> b)[OneShot] (n :: b)[OneShot] ->
                    TraversableInstances.$fFoldableBig_$cfoldr @ a @ a1 @ b c n t1)) -}
8373cb9b5cc904797ff1fb1bafd8cdce
  $fFoldableBigger ::
    Data.Foldable.Foldable (TraversableInstances.Bigger a)
  DFunId
  {- HasNoCafRefs, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a.
                  @ (TraversableInstances.Bigger a)
                  (TraversableInstances.$fFoldableBigger_$cfold @ a)
                  (TraversableInstances.$fFoldableBigger_$cfoldMap @ a)
                  (TraversableInstances.$fFoldableBigger_$cfoldr @ a)
                  (TraversableInstances.$fFoldableBigger_$cfoldr' @ a)
                  (TraversableInstances.$fFoldableBigger_$cfoldl @ a)
                  (TraversableInstances.$fFoldableBigger_$cfoldl' @ a)
                  (TraversableInstances.$fFoldableBigger_$cfoldr1 @ a)
                  (TraversableInstances.$fFoldableBigger_$cfoldl1 @ a)
                  (TraversableInstances.$fFoldableBigger_$ctoList @ a)
                  (TraversableInstances.$fFoldableBigger_$cnull @ a)
                  (TraversableInstances.$fFoldableBigger_$clength @ a)
                  (TraversableInstances.$fFoldableBigger_$celem @ a)
                  (TraversableInstances.$fFoldableBigger_$cmaximum @ a)
                  (TraversableInstances.$fFoldableBigger_$cminimum @ a)
                  (TraversableInstances.$fFoldableBigger_$csum @ a)
                  (TraversableInstances.$fFoldableBigger_$cproduct @ a) -}
8373cb9b5cc904797ff1fb1bafd8cdce
  $fFoldableBigger1 ::
    GHC.Num.Num a1 =>
    TraversableInstances.Bigger a a1 -> Data.Monoid.Product a1
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LLC(C(S))LLLL),U(A,A,C(C1(U)),A,A,A,A)><S,1*U(A,U,U,U)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   @ a1
                   ($dNum :: GHC.Num.Num a1)
                   (ds :: TraversableInstances.Bigger a a1) ->
                 case ds of wild { TraversableInstances.Bigger ds1 b b' b'' ->
                 (GHC.Num.* @ a1 $dNum b (GHC.Num.* @ a1 $dNum b' b''))
                   `cast`
                 (Sym (Data.Monoid.N:Product[0] <a1>_R)) }) -}
8373cb9b5cc904797ff1fb1bafd8cdce
  $fFoldableBigger2 ::
    GHC.Num.Num a1 =>
    TraversableInstances.Bigger a a1 -> Data.Monoid.Sum a1
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(C(C(S))LLLLLL),U(C(C1(U)),A,A,A,A,A,A)><S,1*U(A,U,U,U)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   @ a1
                   ($dNum :: GHC.Num.Num a1)
                   (ds :: TraversableInstances.Bigger a a1) ->
                 case ds of wild { TraversableInstances.Bigger ds1 b b' b'' ->
                 (GHC.Num.+ @ a1 $dNum b (GHC.Num.+ @ a1 $dNum b' b''))
                   `cast`
                 (Sym (Data.Monoid.N:Sum[0] <a1>_R)) }) -}
8373cb9b5cc904797ff1fb1bafd8cdce
  $fFoldableBigger_$celem ::
    GHC.Classes.Eq a1 =>
    a1 -> TraversableInstances.Bigger a a1 -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(1*C1(U),A)><L,U>,
     Unfolding: (\ @ a @ a1 ($dEq :: GHC.Classes.Eq a1) (eta :: a1) ->
                 let {
                   f :: a1 -> GHC.Types.Bool = GHC.Classes.== @ a1 $dEq eta
                 } in
                 (\ (ds :: TraversableInstances.Bigger a a1) ->
                  case ds of wild { TraversableInstances.Bigger ds1 b b' b'' ->
                  case f b of wild1 {
                    GHC.Types.False
                    -> case f b' of wild2 {
                         GHC.Types.False -> (f b'') `cast` (Sym (Data.Monoid.N:Any[0]))
                         GHC.Types.True
                         -> GHC.Types.True `cast` (Sym (Data.Monoid.N:Any[0])) }
                    GHC.Types.True
                    -> GHC.Types.True `cast` (Sym (Data.Monoid.N:Any[0])) } })
                   `cast`
                 (<TraversableInstances.Bigger a a1>_R
                  ->_R Data.Monoid.N:Any[0])) -}
8373cb9b5cc904797ff1fb1bafd8cdce
  $fFoldableBigger_$cfold ::
    GHC.Base.Monoid m => TraversableInstances.Bigger a m -> m
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LC(C(S))L),U(A,C(C1(U)),A)><S,1*U(A,U,U,U)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   @ m
                   ($dMonoid :: GHC.Base.Monoid m)
                   (ds :: TraversableInstances.Bigger a m) ->
                 case ds of wild { TraversableInstances.Bigger ds1 b b' b'' ->
                 GHC.Base.mappend
                   @ m
                   $dMonoid
                   b
                   (GHC.Base.mappend @ m $dMonoid b' b'') }) -}
8373cb9b5cc904797ff1fb1bafd8cdce
  $fFoldableBigger_$cfoldMap ::
    GHC.Base.Monoid m =>
    (a1 -> m) -> TraversableInstances.Bigger a a1 -> m
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LC(C(S))L),U(A,C(C1(U)),A)><L,C(U)><S,1*U(A,U,U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ m
                   @ a1
                   (w :: GHC.Base.Monoid m)
                   (w1 :: a1 -> m)
                   (w2 :: TraversableInstances.Bigger a a1) ->
                 case w2 of ww { TraversableInstances.Bigger ww1 ww2 ww3 ww4 ->
                 TraversableInstances.$w$cfoldMap
                   @ a
                   @ m
                   @ a1
                   w
                   w1
                   ww2
                   ww3
                   ww4 }) -}
8373cb9b5cc904797ff1fb1bafd8cdce
  $fFoldableBigger_$cfoldl ::
    (b -> a1 -> b) -> b -> TraversableInstances.Bigger a a1 -> b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(C(S)),C(C1(U))><L,U><S,1*U(A,U,U,U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ b
                   @ a1
                   (f :: b -> a1 -> b)
                   (z :: b)
                   (t1 :: TraversableInstances.Bigger a a1) ->
                 case t1 of wild { TraversableInstances.Bigger ds b1 b' b'' ->
                 f (f (f z b1) b') b'' }) -}
8373cb9b5cc904797ff1fb1bafd8cdce
  $fFoldableBigger_$cfoldl' ::
    (b -> a1 -> b) -> b -> TraversableInstances.Bigger a a1 -> b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(C(S)),C(C1(U))><L,U><S,1*U(A,U,U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ b
                   @ a1
                   (w :: b -> a1 -> b)
                   (w1 :: b)
                   (w2 :: TraversableInstances.Bigger a a1) ->
                 case w2 of ww { TraversableInstances.Bigger ww1 ww2 ww3 ww4 ->
                 TraversableInstances.$w$cfoldl' @ a @ b @ a1 w w1 ww2 ww3 ww4 }) -}
8373cb9b5cc904797ff1fb1bafd8cdce
  $fFoldableBigger_$cfoldl1 ::
    (a1 -> a1 -> a1) -> TraversableInstances.Bigger a a1 -> a1
  {- Arity: 2, HasNoCafRefs,
     Strictness: <C(C(S)),C(C1(U))><S,1*U(A,U,U,U)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   @ a1
                   (f :: a1 -> a1 -> a1)
                   (xs :: TraversableInstances.Bigger a a1) ->
                 case xs of wild { TraversableInstances.Bigger ds b b' b'' ->
                 f (f b b') b'' }) -}
8373cb9b5cc904797ff1fb1bafd8cdce
  $fFoldableBigger_$cfoldr ::
    (a1 -> b -> b) -> b -> TraversableInstances.Bigger a a1 -> b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(C(S)),C(C1(U))><L,U><S,1*U(A,U,U,U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ a1
                   @ b
                   (f :: a1 -> b -> b)
                   (z :: b)
                   (t1 :: TraversableInstances.Bigger a a1) ->
                 case t1 of wild { TraversableInstances.Bigger ds b1 b' b'' ->
                 f b1 (f b' (f b'' z)) }) -}
8373cb9b5cc904797ff1fb1bafd8cdce
  $fFoldableBigger_$cfoldr' ::
    (a1 -> b -> b) -> b -> TraversableInstances.Bigger a a1 -> b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(C(S)),C(C1(U))><L,U><S,1*U(A,U,U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ a1
                   @ b
                   (w :: a1 -> b -> b)
                   (w1 :: b)
                   (w2 :: TraversableInstances.Bigger a a1) ->
                 case w2 of ww { TraversableInstances.Bigger ww1 ww2 ww3 ww4 ->
                 TraversableInstances.$w$cfoldr' @ a @ a1 @ b w w1 ww2 ww3 ww4 }) -}
8373cb9b5cc904797ff1fb1bafd8cdce
  $fFoldableBigger_$cfoldr1 ::
    (a1 -> a1 -> a1) -> TraversableInstances.Bigger a a1 -> a1
  {- Arity: 2, HasNoCafRefs,
     Strictness: <C(C(S)),C(C1(U))><S,1*U(A,U,U,U)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   @ a1
                   (f :: a1 -> a1 -> a1)
                   (xs :: TraversableInstances.Bigger a a1) ->
                 case xs of wild { TraversableInstances.Bigger ds b b' b'' ->
                 f b (f b' b'') }) -}
8373cb9b5cc904797ff1fb1bafd8cdce
  $fFoldableBigger_$clength ::
    TraversableInstances.Bigger a a1 -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*H>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ a @ a1 (xs :: TraversableInstances.Bigger a a1) ->
                 case xs of wild { TraversableInstances.Bigger ds b b' b'' ->
                 GHC.Types.I# 3# }) -}
8373cb9b5cc904797ff1fb1bafd8cdce
  $fFoldableBigger_$cmaximum ::
    GHC.Classes.Ord a1 => TraversableInstances.Bigger a a1 -> a1
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LLLLLC(C(S))LL),U(A,A,A,A,A,C(C1(U)),A,A)><S,1*U(A,U,U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   @ a1
                   (w :: GHC.Classes.Ord a1)
                   (w1 :: TraversableInstances.Bigger a a1) ->
                 case w1 of ww { TraversableInstances.Bigger ww1 ww2 ww3 ww4 ->
                 TraversableInstances.$w$cmaximum @ a @ a1 w ww2 ww3 ww4 }) -}
8373cb9b5cc904797ff1fb1bafd8cdce
  $fFoldableBigger_$cminimum ::
    GHC.Classes.Ord a1 => TraversableInstances.Bigger a a1 -> a1
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LLLC(C(S))LLLL),U(A,A,A,C(C1(U)),A,A,A,A)><S,1*U(A,U,U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   @ a1
                   (w :: GHC.Classes.Ord a1)
                   (w1 :: TraversableInstances.Bigger a a1) ->
                 case w1 of ww { TraversableInstances.Bigger ww1 ww2 ww3 ww4 ->
                 TraversableInstances.$w$cminimum @ a @ a1 w ww2 ww3 ww4 }) -}
8373cb9b5cc904797ff1fb1bafd8cdce
  $fFoldableBigger_$cnull ::
    TraversableInstances.Bigger a a1 -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*H>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a @ a1 (t1 :: TraversableInstances.Bigger a a1) ->
                 case t1 of wild { TraversableInstances.Bigger ds b b' b'' ->
                 GHC.Types.False }) -}
8373cb9b5cc904797ff1fb1bafd8cdce
  $fFoldableBigger_$cproduct ::
    GHC.Num.Num a1 => TraversableInstances.Bigger a a1 -> a1
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LLC(C(S))LLLL),U(A,A,C(C1(U)),A,A,A,A)><S,1*U(A,U,U,U)>,
     Unfolding: InlineRule (0, True, True)
                TraversableInstances.$fFoldableBigger1
                  `cast`
                (forall (a :: <*>_N) (a1 :: <*>_N).
                 <GHC.Num.Num a1>_R
                 ->_R <TraversableInstances.Bigger a a1>_R
                 ->_R Data.Monoid.N:Product[0] <a1>_R) -}
8373cb9b5cc904797ff1fb1bafd8cdce
  $fFoldableBigger_$csum ::
    GHC.Num.Num a1 => TraversableInstances.Bigger a a1 -> a1
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(C(C(S))LLLLLL),U(C(C1(U)),A,A,A,A,A,A)><S,1*U(A,U,U,U)>,
     Unfolding: InlineRule (0, True, True)
                TraversableInstances.$fFoldableBigger2
                  `cast`
                (forall (a :: <*>_N) (a1 :: <*>_N).
                 <GHC.Num.Num a1>_R
                 ->_R <TraversableInstances.Bigger a a1>_R
                 ->_R Data.Monoid.N:Sum[0] <a1>_R) -}
8373cb9b5cc904797ff1fb1bafd8cdce
  $fFoldableBigger_$ctoList ::
    TraversableInstances.Bigger a a1 -> [a1]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ a @ a1 (t1 :: TraversableInstances.Bigger a a1) ->
                 GHC.Base.build
                   @ a1
                   (\ @ b (c :: a1 -> b -> b)[OneShot] (n :: b)[OneShot] ->
                    TraversableInstances.$fFoldableBigger_$cfoldr
                      @ a
                      @ a1
                      @ b
                      c
                      n
                      t1)) -}
a06a627f62d93f6fedbee61792bf9f78
  $fFoldableConstant ::
    Data.Foldable.Foldable (TraversableInstances.Constant a)
  DFunId
  {- Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a.
                  @ (TraversableInstances.Constant a)
                  (TraversableInstances.$fFoldableConstant_$cfold @ a)
                  (TraversableInstances.$fFoldableConstant_$cfoldMap @ a)
                  (TraversableInstances.$fFoldableConstant_$cfoldr @ a)
                  (TraversableInstances.$fFoldableConstant_$cfoldr @ a)
                  (TraversableInstances.$fFoldableConstant_$cfoldl @ a)
                  (TraversableInstances.$fFoldableConstant_$cfoldl @ a)
                  (TraversableInstances.$fFoldableConstant_$cfoldr1 @ a)
                  (TraversableInstances.$fFoldableConstant_$cfoldl1 @ a)
                  (TraversableInstances.$fFoldableConstant_$ctoList @ a)
                  (TraversableInstances.$fFoldableConstant_$cnull @ a)
                  (TraversableInstances.$fFoldableConstant_$clength @ a)
                  (TraversableInstances.$fFoldableConstant_$celem @ a)
                  (TraversableInstances.$fFoldableConstant_$cmaximum @ a)
                  (TraversableInstances.$fFoldableConstant_$cminimum @ a)
                  (TraversableInstances.$fFoldableConstant_$csum @ a)
                  (TraversableInstances.$fFoldableConstant_$cproduct @ a) -}
d6cd20f446328d0bf66f719eef24caa8
  $fFoldableConstant1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
a06a627f62d93f6fedbee61792bf9f78
  $fFoldableConstant_$celem ::
    GHC.Classes.Eq a1 =>
    a1 -> TraversableInstances.Constant a a1 -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><L,A><L,A>,
     Unfolding: InlineRule (3, True, True)
                (\ @ a
                   @ a1
                   ($dEq :: GHC.Classes.Eq a1)
                   (eta :: a1)
                   (eta1 :: TraversableInstances.Constant a a1) ->
                 GHC.Types.False) -}
a06a627f62d93f6fedbee61792bf9f78
  $fFoldableConstant_$cfold ::
    GHC.Base.Monoid m => TraversableInstances.Constant a m -> m
  {- Arity: 2, HasNoCafRefs, Strictness: <S(SLL),1*U(1*U,A,A)><L,A>,
     Unfolding: InlineRule (2, True, True)
                (\ @ a
                   @ m
                   ($dMonoid :: GHC.Base.Monoid m)
                   (eta :: TraversableInstances.Constant a m) ->
                 GHC.Base.mempty @ m $dMonoid) -}
a06a627f62d93f6fedbee61792bf9f78
  $fFoldableConstant_$cfoldMap ::
    GHC.Base.Monoid m =>
    (a1 -> m) -> TraversableInstances.Constant a a1 -> m
  {- Arity: 2, Strictness: <L,U(1*U,1*U,A)><L,C(U)>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ a
                   @ m
                   @ a1
                   ($dMonoid :: GHC.Base.Monoid m)
                   (f :: a1 -> m)
                   (eta :: TraversableInstances.Constant a a1) ->
                 TraversableInstances.$fFoldableConstant_$cfoldr
                   @ a
                   @ a1
                   @ m
                   (let {
                      f1 :: m -> m -> m = GHC.Base.mappend @ m $dMonoid
                    } in
                    \ (x :: a1) -> f1 (f x))
                   (GHC.Base.mempty @ m $dMonoid)
                   eta) -}
a06a627f62d93f6fedbee61792bf9f78
  $fFoldableConstant_$cfoldl ::
    (b -> a1 -> b) -> b -> TraversableInstances.Constant a a1 -> b
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><S,1*U><L,A>,
     Unfolding: InlineRule (3, True, True)
                (\ @ a
                   @ b
                   @ a1
                   (f :: b -> a1 -> b)
                   (z :: b)
                   (t1 :: TraversableInstances.Constant a a1) ->
                 z) -}
a06a627f62d93f6fedbee61792bf9f78
  $fFoldableConstant_$cfoldl1 ::
    (a1 -> a1 -> a1) -> TraversableInstances.Constant a a1 -> a1
  {- Arity: 2, Strictness: <B,A><B,A>x, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, True)
                (\ @ a
                   @ a1
                   (w :: a1 -> a1 -> a1)
                   (w1 :: TraversableInstances.Constant a a1) ->
                 TraversableInstances.$w$cfoldl1 @ a @ a1 GHC.Prim.void#) -}
a06a627f62d93f6fedbee61792bf9f78
  $fFoldableConstant_$cfoldr ::
    (a1 -> b -> b) -> b -> TraversableInstances.Constant a a1 -> b
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><S,1*U><L,A>,
     Unfolding: InlineRule (3, True, True)
                (\ @ a
                   @ a1
                   @ b
                   (ds :: a1 -> b -> b)
                   (b1 :: b)
                   (ds1 :: TraversableInstances.Constant a a1) ->
                 b1) -}
a06a627f62d93f6fedbee61792bf9f78
  $fFoldableConstant_$cfoldr1 ::
    (a1 -> a1 -> a1) -> TraversableInstances.Constant a a1 -> a1
  {- Arity: 2, Strictness: <B,A><B,A>x, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, True)
                (\ @ a
                   @ a1
                   (w :: a1 -> a1 -> a1)
                   (w1 :: TraversableInstances.Constant a a1) ->
                 TraversableInstances.$w$cfoldr1 @ a @ a1 GHC.Prim.void#) -}
a06a627f62d93f6fedbee61792bf9f78
  $fFoldableConstant_$clength ::
    TraversableInstances.Constant a a1 -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>m,
     Unfolding: InlineRule (1, True, True)
                (\ @ a @ a1 (xs :: TraversableInstances.Constant a a1) ->
                 TraversableInstances.$fFoldableConstant1) -}
a06a627f62d93f6fedbee61792bf9f78
  $fFoldableConstant_$cmaximum ::
    GHC.Classes.Ord a1 => TraversableInstances.Constant a a1 -> a1
  {- Arity: 2, Strictness: <B,A><B,A>x, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, True)
                (\ @ a
                   @ a1
                   (w :: GHC.Classes.Ord a1)
                   (w1 :: TraversableInstances.Constant a a1) ->
                 TraversableInstances.$w$cmaximum1 @ a @ a1 GHC.Prim.void#) -}
a06a627f62d93f6fedbee61792bf9f78
  $fFoldableConstant_$cminimum ::
    GHC.Classes.Ord a1 => TraversableInstances.Constant a a1 -> a1
  {- Arity: 2, Strictness: <B,A><B,A>x, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, True)
                (\ @ a
                   @ a1
                   (w :: GHC.Classes.Ord a1)
                   (w1 :: TraversableInstances.Constant a a1) ->
                 TraversableInstances.$w$cminimum1 @ a @ a1 GHC.Prim.void#) -}
a06a627f62d93f6fedbee61792bf9f78
  $fFoldableConstant_$cnull ::
    TraversableInstances.Constant a a1 -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>,
     Unfolding: InlineRule (1, True, True)
                (\ @ a @ a1 (ds :: TraversableInstances.Constant a a1) ->
                 GHC.Types.True) -}
a06a627f62d93f6fedbee61792bf9f78
  $fFoldableConstant_$cproduct ::
    GHC.Num.Num a1 => TraversableInstances.Constant a a1 -> a1
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><L,A>,
     Unfolding: InlineRule (2, True, True)
                (\ @ a
                   @ a1
                   ($dNum :: GHC.Num.Num a1)
                   (eta :: TraversableInstances.Constant a a1) ->
                 Data.Monoid.$fMonoidProduct2 @ a1 $dNum) -}
a06a627f62d93f6fedbee61792bf9f78
  $fFoldableConstant_$csum ::
    GHC.Num.Num a1 => TraversableInstances.Constant a a1 -> a1
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><L,A>,
     Unfolding: InlineRule (2, True, True)
                (\ @ a
                   @ a1
                   ($dNum :: GHC.Num.Num a1)
                   (eta :: TraversableInstances.Constant a a1) ->
                 Data.Monoid.$fMonoidSum2 @ a1 $dNum) -}
a06a627f62d93f6fedbee61792bf9f78
  $fFoldableConstant_$ctoList ::
    TraversableInstances.Constant a a1 -> [a1]
  {- Arity: 1, Strictness: <L,U>, Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ a @ a1 (t1 :: TraversableInstances.Constant a a1) ->
                 GHC.Base.build
                   @ a1
                   (\ @ b (c :: a1 -> b -> b)[OneShot] (n :: b)[OneShot] ->
                    TraversableInstances.$fFoldableConstant_$cfoldr
                      @ a
                      @ a1
                      @ b
                      c
                      n
                      t1)) -}
729de049f804209d218b6ac6412958e0
  $fFoldableIdentity ::
    Data.Foldable.Foldable TraversableInstances.Identity
  DFunId
  {- HasNoCafRefs, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ TraversableInstances.Identity
                  TraversableInstances.$fFoldableIdentity_$cfold
                  TraversableInstances.$fFoldableIdentity_$cfoldMap
                  TraversableInstances.$fFoldableIdentity_$cfoldr
                  TraversableInstances.$fFoldableIdentity_$cfoldr
                  TraversableInstances.$fFoldableIdentity_$cfoldl
                  TraversableInstances.$fFoldableIdentity_$cfoldl
                  TraversableInstances.$fFoldableIdentity_$cfoldr1
                  TraversableInstances.$fFoldableIdentity_$cfoldr1
                  TraversableInstances.$fFoldableIdentity_$ctoList
                  TraversableInstances.$fFoldableIdentity_$cnull
                  TraversableInstances.$fFoldableIdentity_$clength
                  TraversableInstances.$fFoldableIdentity_$celem
                  TraversableInstances.$fFoldableIdentity_$cmaximum
                  TraversableInstances.$fFoldableIdentity_$cmaximum
                  TraversableInstances.$fFoldableIdentity_$csum
                  TraversableInstances.$fFoldableIdentity_$cproduct -}
729de049f804209d218b6ac6412958e0
  $fFoldableIdentity1 ::
    GHC.Num.Num a => TraversableInstances.Identity a -> a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LLC(C(S))LLLL),U(A,A,1*C1(C1(U)),A,A,A,1*C1(U))><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   ($dNum :: GHC.Num.Num a)
                   (eta :: TraversableInstances.Identity a) ->
                 GHC.Num.*
                   @ a
                   $dNum
                   eta `cast` (TraversableInstances.N:Identity[0] <a>_R)
                   (GHC.Num.fromInteger @ a $dNum Data.Monoid.$fMonoidProduct1)) -}
729de049f804209d218b6ac6412958e0
  $fFoldableIdentity2 ::
    GHC.Num.Num a => TraversableInstances.Identity a -> a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(C(C(S))LLLLLL),U(1*C1(C1(U)),A,A,A,A,A,1*C1(U))><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   ($dNum :: GHC.Num.Num a)
                   (eta :: TraversableInstances.Identity a) ->
                 GHC.Num.+
                   @ a
                   $dNum
                   eta `cast` (TraversableInstances.N:Identity[0] <a>_R)
                   (GHC.Num.fromInteger @ a $dNum Data.Monoid.$fMonoidSum1)) -}
729de049f804209d218b6ac6412958e0
  $fFoldableIdentity3 ::
    GHC.Classes.Ord a =>
    TraversableInstances.Identity a -> TraversableInstances.Identity a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><S,1*U>,
     Unfolding: InlineRule (2, True, True)
                (\ @ a
                   ($dOrd :: GHC.Classes.Ord a)
                   (x :: TraversableInstances.Identity a) ->
                 x) -}
729de049f804209d218b6ac6412958e0
  $fFoldableIdentity4 ::
    (a -> a -> a)
    -> TraversableInstances.Identity a
    -> TraversableInstances.Identity a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><S,1*U>,
     Unfolding: InlineRule (2, True, True)
                (\ @ a
                   (f :: a -> a -> a)
                   (xs :: TraversableInstances.Identity a) ->
                 xs) -}
729de049f804209d218b6ac6412958e0
  $fFoldableIdentity_$celem ::
    GHC.Classes.Eq a =>
    a -> TraversableInstances.Identity a -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(1*C1(U),A)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dEq :: GHC.Classes.Eq a) (eta :: a) ->
                 let {
                   f :: a -> GHC.Types.Bool = GHC.Classes.== @ a $dEq eta
                 } in
                 \ (eta1 :: TraversableInstances.Identity a) ->
                 f eta1 `cast` (TraversableInstances.N:Identity[0] <a>_R)) -}
729de049f804209d218b6ac6412958e0
  $fFoldableIdentity_$cfold ::
    GHC.Base.Monoid m => TraversableInstances.Identity m -> m
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LC(C(S))L),U(1*U,1*C1(C1(U)),A)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ m
                   ($dMonoid :: GHC.Base.Monoid m)
                   (eta :: TraversableInstances.Identity m) ->
                 GHC.Base.mappend
                   @ m
                   $dMonoid
                   eta `cast` (TraversableInstances.N:Identity[0] <m>_R)
                   (GHC.Base.mempty @ m $dMonoid)) -}
729de049f804209d218b6ac6412958e0
  $fFoldableIdentity_$cfoldMap ::
    GHC.Base.Monoid m =>
    (a -> m) -> TraversableInstances.Identity a -> m
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U(1*U,1*U,A)><L,C(U)>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ m
                   @ a
                   ($dMonoid :: GHC.Base.Monoid m)
                   (f :: a -> m)
                   (eta :: TraversableInstances.Identity a) ->
                 TraversableInstances.$fFoldableIdentity_$cfoldr
                   @ a
                   @ m
                   (\ (x :: a)[OneShot] -> GHC.Base.mappend @ m $dMonoid (f x))
                   (GHC.Base.mempty @ m $dMonoid)
                   eta) -}
729de049f804209d218b6ac6412958e0
  $fFoldableIdentity_$cfoldl ::
    (b -> a -> b) -> b -> TraversableInstances.Identity a -> b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(C(S)),1*C1(C1(U))><L,U><L,U>,
     Unfolding: InlineRule (3, True, True)
                (\ @ b
                   @ a
                   (f :: b -> a -> b)
                   (z :: b)
                   (t1 :: TraversableInstances.Identity a) ->
                 f z t1 `cast` (TraversableInstances.N:Identity[0] <a>_R)) -}
729de049f804209d218b6ac6412958e0
  $fFoldableIdentity_$cfoldr ::
    (a -> b -> b) -> b -> TraversableInstances.Identity a -> b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(C(S)),1*C1(C1(U))><L,U><L,U>,
     Unfolding: InlineRule (3, True, True)
                (\ @ a
                   @ b
                   (f :: a -> b -> b)
                   (b1 :: b)
                   (ds :: TraversableInstances.Identity a) ->
                 f ds `cast` (TraversableInstances.N:Identity[0] <a>_R) b1) -}
729de049f804209d218b6ac6412958e0
  $fFoldableIdentity_$cfoldr1 ::
    (a -> a -> a) -> TraversableInstances.Identity a -> a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                TraversableInstances.$fFoldableIdentity4
                  `cast`
                (forall (a :: <*>_N).
                 <a -> a -> a>_R
                 ->_R <TraversableInstances.Identity a>_R
                 ->_R TraversableInstances.N:Identity[0] <a>_R) -}
729de049f804209d218b6ac6412958e0
  $fFoldableIdentity_$clength ::
    TraversableInstances.Identity a -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>m,
     Unfolding: InlineRule (1, True, True)
                (\ @ a (xs :: TraversableInstances.Identity a) ->
                 GHC.Types.I# 1#) -}
729de049f804209d218b6ac6412958e0
  $fFoldableIdentity_$cmaximum ::
    GHC.Classes.Ord a => TraversableInstances.Identity a -> a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                TraversableInstances.$fFoldableIdentity3
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Classes.Ord a>_R
                 ->_R <TraversableInstances.Identity a>_R
                 ->_R TraversableInstances.N:Identity[0] <a>_R) -}
729de049f804209d218b6ac6412958e0
  $fFoldableIdentity_$cnull ::
    TraversableInstances.Identity a -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>,
     Unfolding: InlineRule (1, True, True)
                (\ @ a (ds :: TraversableInstances.Identity a) ->
                 GHC.Types.False) -}
729de049f804209d218b6ac6412958e0
  $fFoldableIdentity_$cproduct ::
    GHC.Num.Num a => TraversableInstances.Identity a -> a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LLC(C(S))LLLL),U(A,A,1*C1(C1(U)),A,A,A,1*C1(U))><L,U>,
     Unfolding: InlineRule (0, True, True)
                TraversableInstances.$fFoldableIdentity1 -}
729de049f804209d218b6ac6412958e0
  $fFoldableIdentity_$csum ::
    GHC.Num.Num a => TraversableInstances.Identity a -> a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(C(C(S))LLLLLL),U(1*C1(C1(U)),A,A,A,A,A,1*C1(U))><L,U>,
     Unfolding: InlineRule (0, True, True)
                TraversableInstances.$fFoldableIdentity2 -}
729de049f804209d218b6ac6412958e0
  $fFoldableIdentity_$ctoList ::
    TraversableInstances.Identity a -> [a]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ a (t1 :: TraversableInstances.Identity a) ->
                 GHC.Base.build
                   @ a
                   (\ @ b (c :: a -> b -> b)[OneShot] (n :: b)[OneShot] ->
                    TraversableInstances.$fFoldableIdentity_$cfoldr @ a @ b c n t1)) -}
b205c9375ec1b24a907de4864e47820f
  $fFoldableList :: Data.Foldable.Foldable TraversableInstances.List
  DFunId
  {- Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ TraversableInstances.List
                  TraversableInstances.$fFoldableList_$cfold
                  TraversableInstances.$fFoldableList_$cfoldMap
                  TraversableInstances.$fFoldableList_$cfoldr
                  TraversableInstances.$fFoldableList_$cfoldr'
                  TraversableInstances.$fFoldableList_$cfoldl
                  TraversableInstances.$fFoldableList_$cfoldl'
                  TraversableInstances.$fFoldableList_$cfoldr1
                  TraversableInstances.$fFoldableList_$cfoldl1
                  TraversableInstances.$fFoldableList_$ctoList
                  TraversableInstances.$fFoldableList_$cnull
                  TraversableInstances.$fFoldableList_$clength
                  TraversableInstances.$fFoldableList_$celem
                  TraversableInstances.$fFoldableList_$cmaximum
                  TraversableInstances.$fFoldableList_$cminimum
                  TraversableInstances.$fFoldableList_$csum
                  TraversableInstances.$fFoldableList_$cproduct -}
b205c9375ec1b24a907de4864e47820f
  $fFoldableList1 ::
    GHC.Num.Num a =>
    TraversableInstances.List a -> Data.Monoid.Product a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,1*U,A,A,A,1*C1(U))><S,1*U>,
     Unfolding: (\ @ a
                   ($dNum :: GHC.Num.Num a)
                   (eta :: TraversableInstances.List a) ->
                 TraversableInstances.$fFoldableList_$cfoldr
                   @ a
                   @ (Data.Monoid.Product a)
                   (let {
                      f1 :: a -> a -> a = GHC.Num.* @ a $dNum
                    } in
                    (\ (x :: a) -> f1 x)
                      `cast`
                    (<a>_R
                     ->_R Sym (Data.Monoid.N:Product[0] <a>_R)
                     ->_R Sym (Data.Monoid.N:Product[0] <a>_R)))
                   (Data.Monoid.$fMonoidProduct2 @ a $dNum)
                     `cast`
                   (Sym (Data.Monoid.N:Product[0] <a>_R))
                   eta) -}
b205c9375ec1b24a907de4864e47820f
  $fFoldableList2 ::
    GHC.Num.Num a => TraversableInstances.List a -> Data.Monoid.Sum a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(1*U,A,A,A,A,A,1*C1(U))><S,1*U>,
     Unfolding: (\ @ a
                   ($dNum :: GHC.Num.Num a)
                   (eta :: TraversableInstances.List a) ->
                 TraversableInstances.$fFoldableList_$cfoldr
                   @ a
                   @ (Data.Monoid.Sum a)
                   (let {
                      f1 :: a -> a -> a = GHC.Num.+ @ a $dNum
                    } in
                    (\ (x :: a) -> f1 x)
                      `cast`
                    (<a>_R
                     ->_R Sym (Data.Monoid.N:Sum[0] <a>_R)
                     ->_R Sym (Data.Monoid.N:Sum[0] <a>_R)))
                   (Data.Monoid.$fMonoidSum2 @ a $dNum)
                     `cast`
                   (Sym (Data.Monoid.N:Sum[0] <a>_R))
                   eta) -}
65a5dcba9b663a0531f231d3e05772bd
  $fFoldableList3 :: a
  {- Strictness: x -}
1844736fd1294809169b1c84795096a1
  $fFoldableList4 :: a
  {- Strictness: x -}
37d3e2eab97f09076a71421422045e0b
  $fFoldableList5 ::
    a
    -> (GHC.Types.Int -> GHC.Types.Int)
    -> GHC.Types.Int
    -> GHC.Types.Int
  {- Arity: 3, HasNoCafRefs,
     Unfolding: (\ @ a
                   (x :: a)
                   (k :: GHC.Types.Int -> GHC.Types.Int)[OneShot]
                   (z :: GHC.Types.Int) ->
                 case z of wild { GHC.Types.I# x1 ->
                 k (GHC.Types.I# (GHC.Prim.+# x1 1#)) }) -}
65596a182464cb6b4d321a6b6bb76842
  $fFoldableList6 :: a -> GHC.Types.Bool -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><L,A>,
     Unfolding: InlineRule (2, True, True)
                (\ @ a (ds :: a) (ds1 :: GHC.Types.Bool) -> GHC.Types.False) -}
89c98d6da506ea15b87d3c750a9c7dbd
  $fFoldableList7 :: a
  {- Strictness: x -}
7702a84f80c3543b8fc37aa0793a3693
  $fFoldableList8 :: a
  {- Strictness: x -}
b205c9375ec1b24a907de4864e47820f
  $fFoldableList_$celem ::
    GHC.Classes.Eq a =>
    a -> TraversableInstances.List a -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(1*C1(U),A)><L,U>,
     Unfolding: (\ @ a ($dEq :: GHC.Classes.Eq a) (eta :: a) ->
                 let {
                   f :: a -> GHC.Types.Bool = GHC.Classes.== @ a $dEq eta
                 } in
                 let {
                   lvl18 :: a -> GHC.Types.Bool -> GHC.Types.Bool {- Arity: 2 -}
                   = \ (x :: a) (ds1 :: GHC.Types.Bool)[OneShot] ->
                     case f x of wild {
                       GHC.Types.False -> ds1 GHC.Types.True -> GHC.Types.True }
                 } in
                 (\ (eta1 :: TraversableInstances.List a) ->
                  TraversableInstances.$fFoldableList_$cfoldr
                    @ a
                    @ Data.Monoid.Any
                    lvl18
                      `cast`
                    (<a>_R
                     ->_R Sym (Data.Monoid.N:Any[0])
                     ->_R Sym (Data.Monoid.N:Any[0]))
                    GHC.Types.False `cast` (Sym (Data.Monoid.N:Any[0]))
                    eta1)
                   `cast`
                 (<TraversableInstances.List a>_R ->_R Data.Monoid.N:Any[0])) -}
b205c9375ec1b24a907de4864e47820f
  $fFoldableList_$cfold ::
    GHC.Base.Monoid m => TraversableInstances.List m -> m
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U(1*U,1*U,A)><S,1*U>,
     Unfolding: (\ @ m
                   ($dMonoid :: GHC.Base.Monoid m)
                   (eta :: TraversableInstances.List m) ->
                 TraversableInstances.$fFoldableList_$cfoldr
                   @ m
                   @ m
                   (let {
                      f1 :: m -> m -> m = GHC.Base.mappend @ m $dMonoid
                    } in
                    \ (x :: m) -> f1 x)
                   (GHC.Base.mempty @ m $dMonoid)
                   eta) -}
b205c9375ec1b24a907de4864e47820f
  $fFoldableList_$cfoldMap ::
    GHC.Base.Monoid m => (a -> m) -> TraversableInstances.List a -> m
  {- Arity: 2, Strictness: <L,U(1*U,1*U,A)><L,C(U)>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ m
                   @ a
                   ($dMonoid :: GHC.Base.Monoid m)
                   (f :: a -> m)
                   (eta :: TraversableInstances.List a) ->
                 TraversableInstances.$fFoldableList_$cfoldr
                   @ a
                   @ m
                   (let {
                      f1 :: m -> m -> m = GHC.Base.mappend @ m $dMonoid
                    } in
                    \ (x :: a) -> f1 (f x))
                   (GHC.Base.mempty @ m $dMonoid)
                   eta) -}
b205c9375ec1b24a907de4864e47820f
  $fFoldableList_$cfoldl ::
    (b -> a -> b) -> b -> TraversableInstances.List a -> b
  {- Arity: 3, HasNoCafRefs, Strictness: <L,C(C1(U))><L,U><S,1*U>,
     Unfolding: (\ @ b
                   @ a
                   (f :: b -> a -> b)
                   (z :: b)
                   (t1 :: TraversableInstances.List a) ->
                 (TraversableInstances.$fFoldableList_$cfoldr
                    @ a
                    @ (Data.Monoid.Dual (Data.Monoid.Endo b))
                    (\ (x :: a)
                       (eta :: Data.Monoid.Dual (Data.Monoid.Endo b))[OneShot]
                       (eta1 :: b) ->
                     eta `cast` (Data.Monoid.N:Dual[0] (Data.Monoid.N:Endo[0] <b>_R))
                       (f eta1 x))
                      `cast`
                    (<a>_R
                     ->_R <Data.Monoid.Dual (Data.Monoid.Endo b)>_R
                     ->_R Sym (Data.Monoid.N:Dual[0] (Data.Monoid.N:Endo[0] <b>_R)))
                    (GHC.Base.id @ b)
                      `cast`
                    (Sym (Data.Monoid.N:Dual[0] (Data.Monoid.N:Endo[0] <b>_R)))
                    t1)
                   `cast`
                 (Data.Monoid.N:Dual[0] (Data.Monoid.N:Endo[0] <b>_R))
                   z) -}
b205c9375ec1b24a907de4864e47820f
  $fFoldableList_$cfoldl' ::
    (b -> a -> b) -> b -> TraversableInstances.List a -> b
  {- Arity: 3, HasNoCafRefs, Strictness: <L,C(C1(U))><L,U><S,1*U>,
     Unfolding: (\ @ b
                   @ a
                   (f :: b -> a -> b)
                   (z0 :: b)
                   (xs :: TraversableInstances.List a) ->
                 TraversableInstances.$fFoldableList_$cfoldr
                   @ a
                   @ (b -> b)
                   (\ (x :: a) (k :: b -> b)[OneShot] (z :: b) ->
                    case f z x of vx { DEFAULT -> k vx })
                   (GHC.Base.id @ b)
                   xs
                   z0) -}
b205c9375ec1b24a907de4864e47820f
  $fFoldableList_$cfoldl1 ::
    (a -> a -> a) -> TraversableInstances.List a -> a
  {- Arity: 2, Strictness: <L,C(C1(U))><S,1*U>,
     Unfolding: (\ @ a
                   (f :: a -> a -> a)
                   (xs :: TraversableInstances.List a) ->
                 case (TraversableInstances.$fFoldableList_$cfoldr
                         @ a
                         @ (Data.Monoid.Dual (Data.Monoid.Endo (GHC.Base.Maybe a)))
                         (\ (x :: a)
                            (eta :: Data.Monoid.Dual
                                      (Data.Monoid.Endo (GHC.Base.Maybe a)))[OneShot]
                            (eta1 :: GHC.Base.Maybe a) ->
                          eta
                            `cast`
                          (Data.Monoid.N:Dual[0]
                               (Data.Monoid.N:Endo[0] <GHC.Base.Maybe a>_R))
                            (GHC.Base.Just
                               @ a
                               (case eta1 of wild {
                                  GHC.Base.Nothing -> x GHC.Base.Just x1 -> f x1 x })))
                           `cast`
                         (<a>_R
                          ->_R <Data.Monoid.Dual (Data.Monoid.Endo (GHC.Base.Maybe a))>_R
                          ->_R Sym (Data.Monoid.N:Dual[0]
                                        (Data.Monoid.N:Endo[0] <GHC.Base.Maybe a>_R)))
                         (GHC.Base.id @ (GHC.Base.Maybe a))
                           `cast`
                         (Sym (Data.Monoid.N:Dual[0]
                                   (Data.Monoid.N:Endo[0] <GHC.Base.Maybe a>_R)))
                         xs)
                        `cast`
                      (Data.Monoid.N:Dual[0]
                           (Data.Monoid.N:Endo[0] <GHC.Base.Maybe a>_R))
                        (GHC.Base.Nothing @ a) of wild {
                   GHC.Base.Nothing -> TraversableInstances.$fFoldableList7 @ a
                   GHC.Base.Just v -> v }) -}
b205c9375ec1b24a907de4864e47820f
  $fFoldableList_$cfoldr ::
    (a -> b -> b) -> b -> TraversableInstances.List a -> b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,C(C1(U))><L,1*U><S,1*U> -}
b205c9375ec1b24a907de4864e47820f
  $fFoldableList_$cfoldr' ::
    (a -> b -> b) -> b -> TraversableInstances.List a -> b
  {- Arity: 3, HasNoCafRefs, Strictness: <L,C(C1(U))><L,U><S,1*U>,
     Unfolding: (\ @ a
                   @ b
                   (f :: a -> b -> b)
                   (z0 :: b)
                   (xs :: TraversableInstances.List a) ->
                 (TraversableInstances.$fFoldableList_$cfoldr
                    @ a
                    @ (Data.Monoid.Dual (Data.Monoid.Endo (b -> b)))
                    (\ (x :: a)
                       (eta :: Data.Monoid.Dual (Data.Monoid.Endo (b -> b)))[OneShot]
                       (eta1 :: b -> b) ->
                     eta
                       `cast`
                     (Data.Monoid.N:Dual[0] (Data.Monoid.N:Endo[0] <b -> b>_R))
                       (\ (z :: b) -> case f x z of vx { DEFAULT -> eta1 vx }))
                      `cast`
                    (<a>_R
                     ->_R <Data.Monoid.Dual (Data.Monoid.Endo (b -> b))>_R
                     ->_R Sym (Data.Monoid.N:Dual[0]
                                   (Data.Monoid.N:Endo[0] <b -> b>_R)))
                    (GHC.Base.id @ (b -> b))
                      `cast`
                    (Sym (Data.Monoid.N:Dual[0] (Data.Monoid.N:Endo[0] <b -> b>_R)))
                    xs)
                   `cast`
                 (Data.Monoid.N:Dual[0] (Data.Monoid.N:Endo[0] <b -> b>_R))
                   (GHC.Base.id @ b)
                   z0) -}
b205c9375ec1b24a907de4864e47820f
  $fFoldableList_$cfoldr1 ::
    (a -> a -> a) -> TraversableInstances.List a -> a
  {- Arity: 2, Strictness: <L,C(C1(U))><S,1*U>,
     Unfolding: (\ @ a
                   (f :: a -> a -> a)
                   (xs :: TraversableInstances.List a) ->
                 case TraversableInstances.$fFoldableList_$cfoldr
                        @ a
                        @ (GHC.Base.Maybe a)
                        (\ (x :: a) (m :: GHC.Base.Maybe a)[OneShot] ->
                         GHC.Base.Just
                           @ a
                           (case m of wild {
                              GHC.Base.Nothing -> x GHC.Base.Just y -> f x y }))
                        (GHC.Base.Nothing @ a)
                        xs of wild {
                   GHC.Base.Nothing -> TraversableInstances.$fFoldableList8 @ a
                   GHC.Base.Just v -> v }) -}
b205c9375ec1b24a907de4864e47820f
  $fFoldableList_$clength ::
    TraversableInstances.List a -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ @ a (xs :: TraversableInstances.List a) ->
                 TraversableInstances.$fFoldableList_$cfoldr
                   @ a
                   @ (GHC.Types.Int -> GHC.Types.Int)
                   (TraversableInstances.$fFoldableList5 @ a)
                   (GHC.Base.id @ GHC.Types.Int)
                   xs
                   TraversableInstances.$fFoldableConstant1) -}
b205c9375ec1b24a907de4864e47820f
  $fFoldableList_$cmaximum ::
    GHC.Classes.Ord a => TraversableInstances.List a -> a
  {- Arity: 2, Strictness: <L,U(A,A,A,A,A,C(C1(U)),A,A)><S,1*U>,
     Unfolding: (\ @ a
                   ($dOrd :: GHC.Classes.Ord a)
                   (eta :: TraversableInstances.List a) ->
                 case (TraversableInstances.$fFoldableList_$cfoldr
                         @ a
                         @ (Data.Foldable.Max a)
                         (\ (x :: a) (eta1 :: Data.Foldable.Max a)[OneShot] ->
                          case eta1 `cast` (Data.Foldable.N:Max[0] <a>_N) of wild {
                            GHC.Base.Nothing
                            -> (GHC.Base.Just @ a x)
                                 `cast`
                               (Sym (Data.Foldable.N:Max[0]) <a>_N)
                            GHC.Base.Just ipv
                            -> case GHC.Classes.>= @ a $dOrd x ipv of wild2 {
                                 GHC.Types.False -> wild `cast` (Sym (Data.Foldable.N:Max[0]) <a>_N)
                                 GHC.Types.True
                                 -> (GHC.Base.Just @ a x)
                                      `cast`
                                    (Sym (Data.Foldable.N:Max[0]) <a>_N) } })
                         (GHC.Base.Nothing @ a) `cast` (Sym (Data.Foldable.N:Max[0]) <a>_N)
                         eta)
                        `cast`
                      (Data.Foldable.N:Max[0] <a>_N) of wild {
                   GHC.Base.Nothing -> TraversableInstances.$fFoldableList4 @ a
                   GHC.Base.Just v -> v }) -}
b205c9375ec1b24a907de4864e47820f
  $fFoldableList_$cminimum ::
    GHC.Classes.Ord a => TraversableInstances.List a -> a
  {- Arity: 2, Strictness: <L,U(A,A,A,C(C1(U)),A,A,A,A)><S,1*U>,
     Unfolding: (\ @ a
                   ($dOrd :: GHC.Classes.Ord a)
                   (eta :: TraversableInstances.List a) ->
                 case (TraversableInstances.$fFoldableList_$cfoldr
                         @ a
                         @ (Data.Foldable.Min a)
                         (\ (x :: a) (eta1 :: Data.Foldable.Min a)[OneShot] ->
                          case eta1 `cast` (Data.Foldable.N:Min[0] <a>_N) of wild {
                            GHC.Base.Nothing
                            -> (GHC.Base.Just @ a x)
                                 `cast`
                               (Sym (Data.Foldable.N:Min[0]) <a>_N)
                            GHC.Base.Just ipv
                            -> case GHC.Classes.<= @ a $dOrd x ipv of wild2 {
                                 GHC.Types.False -> wild `cast` (Sym (Data.Foldable.N:Min[0]) <a>_N)
                                 GHC.Types.True
                                 -> (GHC.Base.Just @ a x)
                                      `cast`
                                    (Sym (Data.Foldable.N:Min[0]) <a>_N) } })
                         (GHC.Base.Nothing @ a) `cast` (Sym (Data.Foldable.N:Min[0]) <a>_N)
                         eta)
                        `cast`
                      (Data.Foldable.N:Min[0] <a>_N) of wild {
                   GHC.Base.Nothing -> TraversableInstances.$fFoldableList3 @ a
                   GHC.Base.Just v -> v }) -}
b205c9375ec1b24a907de4864e47820f
  $fFoldableList_$cnull ::
    TraversableInstances.List a -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs,
     Unfolding: (\ @ a ->
                 TraversableInstances.$fFoldableList_$cfoldr
                   @ a
                   @ GHC.Types.Bool
                   (TraversableInstances.$fFoldableList6 @ a)
                   GHC.Types.True) -}
b205c9375ec1b24a907de4864e47820f
  $fFoldableList_$cproduct ::
    GHC.Num.Num a => TraversableInstances.List a -> a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,1*U,A,A,A,1*C1(U))><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                TraversableInstances.$fFoldableList1
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Num.Num a>_R
                 ->_R <TraversableInstances.List a>_R
                 ->_R Data.Monoid.N:Product[0] <a>_R) -}
b205c9375ec1b24a907de4864e47820f
  $fFoldableList_$csum ::
    GHC.Num.Num a => TraversableInstances.List a -> a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(1*U,A,A,A,A,A,1*C1(U))><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                TraversableInstances.$fFoldableList2
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Num.Num a>_R
                 ->_R <TraversableInstances.List a>_R
                 ->_R Data.Monoid.N:Sum[0] <a>_R) -}
b205c9375ec1b24a907de4864e47820f
  $fFoldableList_$ctoList :: TraversableInstances.List a -> [a]
  {- Arity: 1, Strictness: <L,U>, Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ a (t1 :: TraversableInstances.List a) ->
                 GHC.Base.build
                   @ a
                   (\ @ b (c :: a -> b -> b)[OneShot] (n :: b)[OneShot] ->
                    TraversableInstances.$fFoldableList_$cfoldr @ a @ b c n t1)) -}
9b0dc1c42b799f2c204b6c11f0bab139
  $fFoldableOptional ::
    Data.Foldable.Foldable TraversableInstances.Optional
  DFunId
  {- Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ TraversableInstances.Optional
                  TraversableInstances.$fFoldableOptional_$cfold
                  TraversableInstances.$fFoldableOptional_$cfoldMap
                  TraversableInstances.$fFoldableOptional_$cfoldr
                  TraversableInstances.$fFoldableOptional_$cfoldr
                  TraversableInstances.$fFoldableOptional_$cfoldl
                  TraversableInstances.$fFoldableOptional_$cfoldl
                  TraversableInstances.$fFoldableOptional_$cfoldr1
                  TraversableInstances.$fFoldableOptional_$cfoldl1
                  TraversableInstances.$fFoldableOptional_$ctoList
                  TraversableInstances.$fFoldableOptional_$cnull
                  TraversableInstances.$fFoldableOptional_$clength
                  TraversableInstances.$fFoldableOptional_$celem
                  TraversableInstances.$fFoldableOptional_$cmaximum
                  TraversableInstances.$fFoldableOptional_$cminimum
                  TraversableInstances.$fFoldableOptional_$csum
                  TraversableInstances.$fFoldableOptional_$cproduct -}
9b0dc1c42b799f2c204b6c11f0bab139
  $fFoldableOptional1 ::
    GHC.Num.Num a =>
    TraversableInstances.Optional a -> Data.Monoid.Product a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,U(A,A,1*C1(C1(U)),A,A,A,1*C1(U))><S,1*U>,
     Unfolding: (\ @ a
                   ($dNum :: GHC.Num.Num a)
                   (eta :: TraversableInstances.Optional a) ->
                 case eta of wild {
                   TraversableInstances.Nada
                   -> (GHC.Num.fromInteger @ a $dNum Data.Monoid.$fMonoidProduct1)
                        `cast`
                      (Sym (Data.Monoid.N:Product[0] <a>_R))
                   TraversableInstances.Yep a1
                   -> (GHC.Num.*
                         @ a
                         $dNum
                         a1
                         (GHC.Num.fromInteger @ a $dNum Data.Monoid.$fMonoidProduct1))
                        `cast`
                      (Sym (Data.Monoid.N:Product[0] <a>_R)) }) -}
9b0dc1c42b799f2c204b6c11f0bab139
  $fFoldableOptional2 ::
    GHC.Num.Num a =>
    TraversableInstances.Optional a -> Data.Monoid.Sum a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,U(1*C1(C1(U)),A,A,A,A,A,1*C1(U))><S,1*U>,
     Unfolding: (\ @ a
                   ($dNum :: GHC.Num.Num a)
                   (eta :: TraversableInstances.Optional a) ->
                 case eta of wild {
                   TraversableInstances.Nada
                   -> (GHC.Num.fromInteger @ a $dNum Data.Monoid.$fMonoidSum1)
                        `cast`
                      (Sym (Data.Monoid.N:Sum[0] <a>_R))
                   TraversableInstances.Yep a1
                   -> (GHC.Num.+
                         @ a
                         $dNum
                         a1
                         (GHC.Num.fromInteger @ a $dNum Data.Monoid.$fMonoidSum1))
                        `cast`
                      (Sym (Data.Monoid.N:Sum[0] <a>_R)) }) -}
9b0dc1c42b799f2c204b6c11f0bab139
  $fFoldableOptional_$celem ::
    GHC.Classes.Eq a =>
    a -> TraversableInstances.Optional a -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(1*C1(U),A)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dEq :: GHC.Classes.Eq a) (eta :: a) ->
                 let {
                   f :: a -> GHC.Types.Bool = GHC.Classes.== @ a $dEq eta
                 } in
                 (\ (eta1 :: TraversableInstances.Optional a) ->
                  case eta1 of wild {
                    TraversableInstances.Nada
                    -> GHC.Types.False `cast` (Sym (Data.Monoid.N:Any[0]))
                    TraversableInstances.Yep a1
                    -> (f a1) `cast` (Sym (Data.Monoid.N:Any[0])) })
                   `cast`
                 (<TraversableInstances.Optional a>_R ->_R Data.Monoid.N:Any[0])) -}
9b0dc1c42b799f2c204b6c11f0bab139
  $fFoldableOptional_$cfold ::
    GHC.Base.Monoid m => TraversableInstances.Optional m -> m
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,U(1*U,1*C1(C1(U)),A)><S,1*U>,
     Unfolding: (\ @ m
                   ($dMonoid :: GHC.Base.Monoid m)
                   (eta :: TraversableInstances.Optional m) ->
                 case eta of wild {
                   TraversableInstances.Nada -> GHC.Base.mempty @ m $dMonoid
                   TraversableInstances.Yep a
                   -> GHC.Base.mappend
                        @ m
                        $dMonoid
                        a
                        (GHC.Base.mempty @ m $dMonoid) }) -}
9b0dc1c42b799f2c204b6c11f0bab139
  $fFoldableOptional_$cfoldMap ::
    GHC.Base.Monoid m =>
    (a -> m) -> TraversableInstances.Optional a -> m
  {- Arity: 2, Strictness: <L,U(1*U,1*U,A)><L,C(U)>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ m
                   @ a
                   ($dMonoid :: GHC.Base.Monoid m)
                   (f :: a -> m)
                   (eta :: TraversableInstances.Optional a) ->
                 TraversableInstances.$fFoldableOptional_$cfoldr
                   @ a
                   @ m
                   (\ (x :: a)[OneShot] -> GHC.Base.mappend @ m $dMonoid (f x))
                   (GHC.Base.mempty @ m $dMonoid)
                   eta) -}
9b0dc1c42b799f2c204b6c11f0bab139
  $fFoldableOptional_$cfoldl ::
    (b -> a -> b) -> b -> TraversableInstances.Optional a -> b
  {- Arity: 3, HasNoCafRefs, Strictness: <L,1*C1(C1(U))><L,U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ b
                   @ a
                   (f :: b -> a -> b)
                   (z :: b)
                   (t1 :: TraversableInstances.Optional a) ->
                 case t1 of wild {
                   TraversableInstances.Nada -> z
                   TraversableInstances.Yep a1 -> f z a1 }) -}
9b0dc1c42b799f2c204b6c11f0bab139
  $fFoldableOptional_$cfoldl1 ::
    (a -> a -> a) -> TraversableInstances.Optional a -> a
  {- Arity: 2, Strictness: <L,A><S,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   (w :: a -> a -> a)
                   (w1 :: TraversableInstances.Optional a) ->
                 case w1 of wild {
                   TraversableInstances.Nada
                   -> TraversableInstances.$fFoldableList7 @ a
                   TraversableInstances.Yep a1 -> a1 }) -}
9b0dc1c42b799f2c204b6c11f0bab139
  $fFoldableOptional_$cfoldr ::
    (a -> b -> b) -> b -> TraversableInstances.Optional a -> b
  {- Arity: 3, HasNoCafRefs, Strictness: <L,1*C1(C1(U))><L,U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ b
                   (ds :: a -> b -> b)
                   (b1 :: b)
                   (ds1 :: TraversableInstances.Optional a) ->
                 case ds1 of wild {
                   TraversableInstances.Nada -> b1
                   TraversableInstances.Yep a1 -> ds a1 b1 }) -}
9b0dc1c42b799f2c204b6c11f0bab139
  $fFoldableOptional_$cfoldr1 ::
    (a -> a -> a) -> TraversableInstances.Optional a -> a
  {- Arity: 2, Strictness: <L,A><S,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   (w :: a -> a -> a)
                   (w1 :: TraversableInstances.Optional a) ->
                 case w1 of wild {
                   TraversableInstances.Nada
                   -> TraversableInstances.$fFoldableList8 @ a
                   TraversableInstances.Yep a1 -> a1 }) -}
9b0dc1c42b799f2c204b6c11f0bab139
  $fFoldableOptional_$clength ::
    TraversableInstances.Optional a -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (xs :: TraversableInstances.Optional a) ->
                 case xs of wild {
                   TraversableInstances.Nada
                   -> TraversableInstances.$fFoldableConstant1
                   TraversableInstances.Yep a1 -> GHC.Types.I# 1# }) -}
9b0dc1c42b799f2c204b6c11f0bab139
  $fFoldableOptional_$cmaximum ::
    GHC.Classes.Ord a => TraversableInstances.Optional a -> a
  {- Arity: 2, Strictness: <L,A><S,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   (w :: GHC.Classes.Ord a)
                   (w1 :: TraversableInstances.Optional a) ->
                 case w1 of wild {
                   TraversableInstances.Nada
                   -> TraversableInstances.$fFoldableList4 @ a
                   TraversableInstances.Yep a1 -> a1 }) -}
9b0dc1c42b799f2c204b6c11f0bab139
  $fFoldableOptional_$cminimum ::
    GHC.Classes.Ord a => TraversableInstances.Optional a -> a
  {- Arity: 2, Strictness: <L,A><S,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   (w :: GHC.Classes.Ord a)
                   (w1 :: TraversableInstances.Optional a) ->
                 case w1 of wild {
                   TraversableInstances.Nada
                   -> TraversableInstances.$fFoldableList3 @ a
                   TraversableInstances.Yep a1 -> a1 }) -}
9b0dc1c42b799f2c204b6c11f0bab139
  $fFoldableOptional_$cnull ::
    TraversableInstances.Optional a -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: TraversableInstances.Optional a) ->
                 case ds of wild {
                   TraversableInstances.Nada -> GHC.Types.True
                   TraversableInstances.Yep a1 -> GHC.Types.False }) -}
9b0dc1c42b799f2c204b6c11f0bab139
  $fFoldableOptional_$cproduct ::
    GHC.Num.Num a => TraversableInstances.Optional a -> a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,U(A,A,1*C1(C1(U)),A,A,A,1*C1(U))><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                TraversableInstances.$fFoldableOptional1
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Num.Num a>_R
                 ->_R <TraversableInstances.Optional a>_R
                 ->_R Data.Monoid.N:Product[0] <a>_R) -}
9b0dc1c42b799f2c204b6c11f0bab139
  $fFoldableOptional_$csum ::
    GHC.Num.Num a => TraversableInstances.Optional a -> a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,U(1*C1(C1(U)),A,A,A,A,A,1*C1(U))><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                TraversableInstances.$fFoldableOptional2
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Num.Num a>_R
                 ->_R <TraversableInstances.Optional a>_R
                 ->_R Data.Monoid.N:Sum[0] <a>_R) -}
9b0dc1c42b799f2c204b6c11f0bab139
  $fFoldableOptional_$ctoList ::
    TraversableInstances.Optional a -> [a]
  {- Arity: 1, Strictness: <L,U>, Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ a (t1 :: TraversableInstances.Optional a) ->
                 GHC.Base.build
                   @ a
                   (\ @ b (c :: a -> b -> b)[OneShot] (n :: b)[OneShot] ->
                    TraversableInstances.$fFoldableOptional_$cfoldr @ a @ b c n t1)) -}
96406d61d01da17b40bba6954858f9d9
  $fFoldablePair ::
    Data.Foldable.Foldable (TraversableInstances.Pair a)
  DFunId
  {- HasNoCafRefs, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a.
                  @ (TraversableInstances.Pair a)
                  (TraversableInstances.$fFoldablePair_$cfold @ a)
                  (TraversableInstances.$fFoldablePair_$cfoldMap @ a)
                  (TraversableInstances.$fFoldablePair_$cfoldr @ a)
                  (TraversableInstances.$fFoldablePair_$cfoldr @ a)
                  (TraversableInstances.$fFoldablePair_$cfoldl @ a)
                  (TraversableInstances.$fFoldablePair_$cfoldl @ a)
                  (TraversableInstances.$fFoldablePair_$cfoldr1 @ a)
                  (TraversableInstances.$fFoldablePair_$cfoldr1 @ a)
                  (TraversableInstances.$fFoldablePair_$ctoList @ a)
                  (TraversableInstances.$fFoldablePair_$cnull @ a)
                  (TraversableInstances.$fFoldablePair_$clength @ a)
                  (TraversableInstances.$fFoldablePair_$celem @ a)
                  (TraversableInstances.$fFoldablePair_$cmaximum @ a)
                  (TraversableInstances.$fFoldablePair_$cmaximum @ a)
                  (TraversableInstances.$fFoldablePair_$csum @ a)
                  (TraversableInstances.$fFoldablePair_$cproduct @ a) -}
96406d61d01da17b40bba6954858f9d9
  $fFoldablePair1 ::
    GHC.Num.Num a1 =>
    TraversableInstances.Pair a a1 -> Data.Monoid.Product a1
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LLC(C(S))LLLL),U(A,A,1*C1(C1(U)),A,A,A,1*C1(U))><S,1*U(A,U)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   @ a1
                   ($dNum :: GHC.Num.Num a1)
                   (eta :: TraversableInstances.Pair a a1) ->
                 case eta of wild { TraversableInstances.Pair ds b ->
                 (GHC.Num.*
                    @ a1
                    $dNum
                    b
                    (GHC.Num.fromInteger @ a1 $dNum Data.Monoid.$fMonoidProduct1))
                   `cast`
                 (Sym (Data.Monoid.N:Product[0] <a1>_R)) }) -}
96406d61d01da17b40bba6954858f9d9
  $fFoldablePair2 ::
    GHC.Num.Num a1 =>
    TraversableInstances.Pair a a1 -> Data.Monoid.Sum a1
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(C(C(S))LLLLLL),U(1*C1(C1(U)),A,A,A,A,A,1*C1(U))><S,1*U(A,U)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   @ a1
                   ($dNum :: GHC.Num.Num a1)
                   (eta :: TraversableInstances.Pair a a1) ->
                 case eta of wild { TraversableInstances.Pair ds b ->
                 (GHC.Num.+
                    @ a1
                    $dNum
                    b
                    (GHC.Num.fromInteger @ a1 $dNum Data.Monoid.$fMonoidSum1))
                   `cast`
                 (Sym (Data.Monoid.N:Sum[0] <a1>_R)) }) -}
96406d61d01da17b40bba6954858f9d9
  $fFoldablePair_$celem ::
    GHC.Classes.Eq a1 =>
    a1 -> TraversableInstances.Pair a a1 -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(1*C1(U),A)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ a1 ($dEq :: GHC.Classes.Eq a1) (eta :: a1) ->
                 let {
                   f :: a1 -> GHC.Types.Bool = GHC.Classes.== @ a1 $dEq eta
                 } in
                 (\ (eta1 :: TraversableInstances.Pair a a1) ->
                  case eta1 of wild { TraversableInstances.Pair ds b ->
                  (f b) `cast` (Sym (Data.Monoid.N:Any[0])) })
                   `cast`
                 (<TraversableInstances.Pair a a1>_R ->_R Data.Monoid.N:Any[0])) -}
96406d61d01da17b40bba6954858f9d9
  $fFoldablePair_$cfold ::
    GHC.Base.Monoid m => TraversableInstances.Pair a m -> m
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LC(C(S))L),U(1*U,1*C1(C1(U)),A)><S,1*U(A,U)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   @ m
                   ($dMonoid :: GHC.Base.Monoid m)
                   (eta :: TraversableInstances.Pair a m) ->
                 case eta of wild { TraversableInstances.Pair ds b ->
                 GHC.Base.mappend
                   @ m
                   $dMonoid
                   b
                   (GHC.Base.mempty @ m $dMonoid) }) -}
96406d61d01da17b40bba6954858f9d9
  $fFoldablePair_$cfoldMap ::
    GHC.Base.Monoid m =>
    (a1 -> m) -> TraversableInstances.Pair a a1 -> m
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U(1*U,1*U,A)><L,C(U)>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ a
                   @ m
                   @ a1
                   ($dMonoid :: GHC.Base.Monoid m)
                   (f :: a1 -> m)
                   (eta :: TraversableInstances.Pair a a1) ->
                 TraversableInstances.$fFoldablePair_$cfoldr
                   @ a
                   @ a1
                   @ m
                   (\ (x :: a1)[OneShot] -> GHC.Base.mappend @ m $dMonoid (f x))
                   (GHC.Base.mempty @ m $dMonoid)
                   eta) -}
96406d61d01da17b40bba6954858f9d9
  $fFoldablePair_$cfoldl ::
    (b -> a1 -> b) -> b -> TraversableInstances.Pair a a1 -> b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(C(S)),1*C1(C1(U))><L,U><S,1*U(A,U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ b
                   @ a1
                   (f :: b -> a1 -> b)
                   (z :: b)
                   (t1 :: TraversableInstances.Pair a a1) ->
                 case t1 of wild { TraversableInstances.Pair ds b1 -> f z b1 }) -}
96406d61d01da17b40bba6954858f9d9
  $fFoldablePair_$cfoldr ::
    (a1 -> b -> b) -> b -> TraversableInstances.Pair a a1 -> b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(C(S)),1*C1(C1(U))><L,U><S,1*U(A,U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ a1
                   @ b
                   (f :: a1 -> b -> b)
                   (b' :: b)
                   (ds :: TraversableInstances.Pair a a1) ->
                 case ds of wild { TraversableInstances.Pair ds1 b1 -> f b1 b' }) -}
96406d61d01da17b40bba6954858f9d9
  $fFoldablePair_$cfoldr1 ::
    (a1 -> a1 -> a1) -> TraversableInstances.Pair a a1 -> a1
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><S(LS),1*U(A,1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   @ a1
                   (f :: a1 -> a1 -> a1)
                   (xs :: TraversableInstances.Pair a a1) ->
                 case xs of wild { TraversableInstances.Pair ds b -> b }) -}
96406d61d01da17b40bba6954858f9d9
  $fFoldablePair_$clength ::
    TraversableInstances.Pair a a1 -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*H>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ a @ a1 (xs :: TraversableInstances.Pair a a1) ->
                 case xs of wild { TraversableInstances.Pair ds b ->
                 GHC.Types.I# 1# }) -}
96406d61d01da17b40bba6954858f9d9
  $fFoldablePair_$cmaximum ::
    GHC.Classes.Ord a1 => TraversableInstances.Pair a a1 -> a1
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><S(LS),1*U(A,1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   @ a1
                   ($dOrd :: GHC.Classes.Ord a1)
                   (x :: TraversableInstances.Pair a a1) ->
                 case x of wild { TraversableInstances.Pair ds b -> b }) -}
96406d61d01da17b40bba6954858f9d9
  $fFoldablePair_$cnull ::
    TraversableInstances.Pair a a1 -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*H>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a @ a1 (ds :: TraversableInstances.Pair a a1) ->
                 case ds of wild { TraversableInstances.Pair ds1 b ->
                 GHC.Types.False }) -}
96406d61d01da17b40bba6954858f9d9
  $fFoldablePair_$cproduct ::
    GHC.Num.Num a1 => TraversableInstances.Pair a a1 -> a1
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LLC(C(S))LLLL),U(A,A,1*C1(C1(U)),A,A,A,1*C1(U))><S,1*U(A,U)>,
     Unfolding: InlineRule (0, True, True)
                TraversableInstances.$fFoldablePair1
                  `cast`
                (forall (a :: <*>_N) (a1 :: <*>_N).
                 <GHC.Num.Num a1>_R
                 ->_R <TraversableInstances.Pair a a1>_R
                 ->_R Data.Monoid.N:Product[0] <a1>_R) -}
96406d61d01da17b40bba6954858f9d9
  $fFoldablePair_$csum ::
    GHC.Num.Num a1 => TraversableInstances.Pair a a1 -> a1
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(C(C(S))LLLLLL),U(1*C1(C1(U)),A,A,A,A,A,1*C1(U))><S,1*U(A,U)>,
     Unfolding: InlineRule (0, True, True)
                TraversableInstances.$fFoldablePair2
                  `cast`
                (forall (a :: <*>_N) (a1 :: <*>_N).
                 <GHC.Num.Num a1>_R
                 ->_R <TraversableInstances.Pair a a1>_R
                 ->_R Data.Monoid.N:Sum[0] <a1>_R) -}
96406d61d01da17b40bba6954858f9d9
  $fFoldablePair_$ctoList :: TraversableInstances.Pair a a1 -> [a1]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ a @ a1 (t1 :: TraversableInstances.Pair a a1) ->
                 GHC.Base.build
                   @ a1
                   (\ @ b (c :: a1 -> b -> b)[OneShot] (n :: b)[OneShot] ->
                    TraversableInstances.$fFoldablePair_$cfoldr
                      @ a
                      @ a1
                      @ b
                      c
                      n
                      t1)) -}
830583bcd30f054061d98a8af9ec4905
  $fFoldableS ::
    Data.Foldable.Foldable n =>
    Data.Foldable.Foldable (TraversableInstances.S n)
  DFunId
  {- Arity: 1,
     Strictness: <L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ (n :: * -> *)
                      ($dFoldable :: Data.Foldable.Foldable n).
                  @ (TraversableInstances.S n)
                  (TraversableInstances.$fFoldableS_$cfold @ n $dFoldable)
                  (TraversableInstances.$fFoldableS_$cfoldMap @ n $dFoldable)
                  (TraversableInstances.$fFoldableS_$cfoldr @ n $dFoldable)
                  (TraversableInstances.$fFoldableS_$cfoldr' @ n $dFoldable)
                  (TraversableInstances.$fFoldableS_$cfoldl @ n $dFoldable)
                  (TraversableInstances.$fFoldableS_$cfoldl' @ n $dFoldable)
                  (TraversableInstances.$fFoldableS_$cfoldr1 @ n $dFoldable)
                  (TraversableInstances.$fFoldableS_$cfoldl1 @ n $dFoldable)
                  (TraversableInstances.$fFoldableS_$ctoList @ n $dFoldable)
                  (TraversableInstances.$fFoldableS_$cnull @ n $dFoldable)
                  (TraversableInstances.$fFoldableS_$clength @ n $dFoldable)
                  (TraversableInstances.$fFoldableS_$celem @ n $dFoldable)
                  (TraversableInstances.$fFoldableS_$cmaximum @ n $dFoldable)
                  (TraversableInstances.$fFoldableS_$cminimum @ n $dFoldable)
                  (TraversableInstances.$fFoldableS_$csum @ n $dFoldable)
                  (TraversableInstances.$fFoldableS_$cproduct @ n $dFoldable) -}
02cc5172d87f038817809dce2d3a02b2
  $fFoldableS1 :: b -> b
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, True) (\ @ b (tpl :: b) -> tpl) -}
5d9783b47d2d9b1b572d0f57e678be58
  $fFoldableS2 :: GHC.Types.Int -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs,
     Unfolding: (\ (z :: GHC.Types.Int) ->
                 case z of wild { GHC.Types.I# x ->
                 GHC.Types.I# (GHC.Prim.+# x 1#) }) -}
4f265f407143ab1032c2a9b583193cd5
  $fFoldableS3 ::
    GHC.Base.Monoid (Data.Monoid.Dual (Data.Monoid.Endo b))
  {- Unfolding: (\ @ b ->
                 Data.Monoid.$fMonoidDual
                   @ (Data.Monoid.Endo b)
                   (Data.Monoid.$fMonoidEndo @ b)) -}
830583bcd30f054061d98a8af9ec4905
  $fFoldableS_$celem ::
    Data.Foldable.Foldable n =>
    forall a.
    GHC.Classes.Eq a =>
    a -> TraversableInstances.S n a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,1*U(1*C1(U),A)><L,U>,
     Unfolding: (\ @ (n :: * -> *)
                   ($dFoldable :: Data.Foldable.Foldable n)
                   @ a
                   ($dEq :: GHC.Classes.Eq a)
                   (eta :: a) ->
                 let {
                   f :: a -> GHC.Types.Bool = GHC.Classes.== @ a $dEq eta
                 } in
                 (\ (ds :: TraversableInstances.S n a) ->
                  case ds of wild { TraversableInstances.S n1 a1 ->
                  case (Data.Foldable.foldMap
                          @ n
                          $dFoldable
                          @ Data.Monoid.Any
                          @ a
                          Data.Monoid.$fMonoidAny
                          f `cast` (<a>_R ->_R Sym (Data.Monoid.N:Any[0]))
                          n1)
                         `cast`
                       (Data.Monoid.N:Any[0]) of wild1 {
                    GHC.Types.False -> (f a1) `cast` (Sym (Data.Monoid.N:Any[0]))
                    GHC.Types.True
                    -> GHC.Types.True `cast` (Sym (Data.Monoid.N:Any[0])) } })
                   `cast`
                 (<TraversableInstances.S n a>_R ->_R Data.Monoid.N:Any[0])) -}
830583bcd30f054061d98a8af9ec4905
  $fFoldableS_$cfold ::
    Data.Foldable.Foldable n =>
    forall m. GHC.Base.Monoid m => TraversableInstances.S n m -> m
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LC(C(S))L),U(U,U,U)><S,1*U(U,U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ (n :: * -> *)
                   ($dFoldable :: Data.Foldable.Foldable n)
                   @ m
                   ($dMonoid :: GHC.Base.Monoid m)
                   (ds :: TraversableInstances.S n m) ->
                 case ds of wild { TraversableInstances.S n1 a ->
                 GHC.Base.mappend
                   @ m
                   $dMonoid
                   (Data.Foldable.foldMap
                      @ n
                      $dFoldable
                      @ m
                      @ m
                      $dMonoid
                      (GHC.Base.id @ m)
                      n1)
                   a }) -}
830583bcd30f054061d98a8af9ec4905
  $fFoldableS_$cfoldMap ::
    Data.Foldable.Foldable n =>
    forall m a.
    GHC.Base.Monoid m =>
    (a -> m) -> TraversableInstances.S n a -> m
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LC(C(S))L),U(U,U,U)><L,U><S,1*U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ @ (n :: * -> *)
                   (w :: Data.Foldable.Foldable n)
                   @ m
                   @ a
                   (w1 :: GHC.Base.Monoid m)
                   (w2 :: a -> m)
                   (w3 :: TraversableInstances.S n a) ->
                 case w3 of ww { TraversableInstances.S ww1 ww2 ->
                 TraversableInstances.$w$cfoldMap1 @ n w @ m @ a w1 w2 ww1 ww2 }) -}
830583bcd30f054061d98a8af9ec4905
  $fFoldableS_$cfoldl ::
    Data.Foldable.Foldable n =>
    forall b a. (b -> a -> b) -> b -> TraversableInstances.S n a -> b
  {- Arity: 4,
     Strictness: <L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: (\ @ (n :: * -> *)
                   ($dFoldable :: Data.Foldable.Foldable n)
                   @ b
                   @ a
                   (f :: b -> a -> b)
                   (z :: b)
                   (t1 :: TraversableInstances.S n a) ->
                 case t1 of wild { TraversableInstances.S n1 a1 ->
                 f ((Data.Foldable.foldMap
                       @ n
                       $dFoldable
                       @ (Data.Monoid.Dual (Data.Monoid.Endo b))
                       @ a
                       (TraversableInstances.$fFoldableS3 @ b)
                       (\ (x :: a) (eta :: b) -> f eta x)
                         `cast`
                       (<a>_R
                        ->_R Sym (Data.Monoid.N:Dual[0] (Data.Monoid.N:Endo[0] <b>_R)))
                       n1)
                      `cast`
                    (Data.Monoid.N:Dual[0] (Data.Monoid.N:Endo[0] <b>_R))
                      z)
                   a1 }) -}
830583bcd30f054061d98a8af9ec4905
  $fFoldableS_$cfoldl' ::
    Data.Foldable.Foldable n =>
    forall b a. (b -> a -> b) -> b -> TraversableInstances.S n a -> b
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><S,1*U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ @ (n :: * -> *)
                   (w :: Data.Foldable.Foldable n)
                   @ b
                   @ a
                   (w1 :: b -> a -> b)
                   (w2 :: b)
                   (w3 :: TraversableInstances.S n a) ->
                 case w3 of ww { TraversableInstances.S ww1 ww2 ->
                 TraversableInstances.$w$cfoldl'1 @ n w @ b @ a w1 w2 ww1 ww2 }) -}
830583bcd30f054061d98a8af9ec4905
  $fFoldableS_$cfoldl1 ::
    Data.Foldable.Foldable n =>
    forall a. (a -> a -> a) -> TraversableInstances.S n a -> a
  {- Arity: 3,
     Strictness: <L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ (n :: * -> *)
                   ($dFoldable :: Data.Foldable.Foldable n)
                   @ a
                   (f :: a -> a -> a)
                   (xs :: TraversableInstances.S n a) ->
                 case xs of wild { TraversableInstances.S n1 a1 ->
                 case (Data.Foldable.foldMap
                         @ n
                         $dFoldable
                         @ (Data.Monoid.Dual (Data.Monoid.Endo (GHC.Base.Maybe a)))
                         @ a
                         (TraversableInstances.$fFoldableS3 @ (GHC.Base.Maybe a))
                         (\ (x :: a) (eta :: GHC.Base.Maybe a) ->
                          GHC.Base.Just
                            @ a
                            (case eta of wild1 {
                               GHC.Base.Nothing -> x GHC.Base.Just x1 -> f x1 x }))
                           `cast`
                         (<a>_R
                          ->_R Sym (Data.Monoid.N:Dual[0]
                                        (Data.Monoid.N:Endo[0] <GHC.Base.Maybe a>_R)))
                         n1)
                        `cast`
                      (Data.Monoid.N:Dual[0]
                           (Data.Monoid.N:Endo[0] <GHC.Base.Maybe a>_R))
                        (GHC.Base.Nothing @ a) of wild1 {
                   GHC.Base.Nothing -> a1 GHC.Base.Just x -> f x a1 } }) -}
830583bcd30f054061d98a8af9ec4905
  $fFoldableS_$cfoldr ::
    Data.Foldable.Foldable n =>
    forall a b. (a -> b -> b) -> b -> TraversableInstances.S n a -> b
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U><S,1*U(U,U)>,
     Unfolding: InlineRule (4, True, False)
                (\ @ (n :: * -> *)
                   ($dFoldable :: Data.Foldable.Foldable n)
                   @ a
                   @ b
                   (f :: a -> b -> b)
                   (z :: b)
                   (t1 :: TraversableInstances.S n a) ->
                 case t1 of wild { TraversableInstances.S n1 a1 ->
                 (Data.Foldable.foldMap
                    @ n
                    $dFoldable
                    @ (Data.Monoid.Endo b)
                    @ a
                    (Data.Monoid.$fMonoidEndo @ b)
                    f `cast` (<a>_R ->_R Sym (Data.Monoid.N:Endo[0] <b>_R))
                    n1)
                   `cast`
                 (Data.Monoid.N:Endo[0] <b>_R)
                   (f a1 z) }) -}
830583bcd30f054061d98a8af9ec4905
  $fFoldableS_$cfoldr' ::
    Data.Foldable.Foldable n =>
    forall a b. (a -> b -> b) -> b -> TraversableInstances.S n a -> b
  {- Arity: 4,
     Strictness: <L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
     Unfolding: (\ @ (n :: * -> *)
                   ($dFoldable :: Data.Foldable.Foldable n)
                   @ a
                   @ b
                   (f :: a -> b -> b)
                   (z0 :: b)
                   (xs :: TraversableInstances.S n a) ->
                 case xs of wild { TraversableInstances.S n1 a1 ->
                 case f a1 z0 of vx { DEFAULT ->
                 (Data.Foldable.foldMap
                    @ n
                    $dFoldable
                    @ (Data.Monoid.Dual (Data.Monoid.Endo (b -> b)))
                    @ a
                    (TraversableInstances.$fFoldableS3 @ (b -> b))
                    (\ (x :: a) (eta :: b -> b) (eta1 :: b) ->
                     case f x eta1 of vx1 { DEFAULT -> eta vx1 })
                      `cast`
                    (<a>_R
                     ->_R Sym (Data.Monoid.N:Dual[0]
                                   (Data.Monoid.N:Endo[0] <b -> b>_R)))
                    n1)
                   `cast`
                 (Data.Monoid.N:Dual[0] (Data.Monoid.N:Endo[0] <b -> b>_R))
                   (GHC.Base.id @ b)
                   vx } }) -}
830583bcd30f054061d98a8af9ec4905
  $fFoldableS_$cfoldr1 ::
    Data.Foldable.Foldable n =>
    forall a. (a -> a -> a) -> TraversableInstances.S n a -> a
  {- Arity: 3,
     Strictness: <S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><S,1*U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ (n :: * -> *)
                   (w :: Data.Foldable.Foldable n)
                   @ a
                   (w1 :: a -> a -> a)
                   (w2 :: TraversableInstances.S n a) ->
                 case w2 of ww { TraversableInstances.S ww1 ww2 ->
                 TraversableInstances.$w$cfoldr2 @ n w @ a w1 ww1 ww2 }) -}
830583bcd30f054061d98a8af9ec4905
  $fFoldableS_$clength ::
    Data.Foldable.Foldable n =>
    forall a. TraversableInstances.S n a -> GHC.Types.Int
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ (n :: * -> *)
                   (w :: Data.Foldable.Foldable n)
                   @ a
                   (w1 :: TraversableInstances.S n a) ->
                 case w1 of ww { TraversableInstances.S ww1 ww2 ->
                 TraversableInstances.$w$clength @ n w @ a ww1 ww2 }) -}
830583bcd30f054061d98a8af9ec4905
  $fFoldableS_$cmaximum ::
    Data.Foldable.Foldable n =>
    forall a. GHC.Classes.Ord a => TraversableInstances.S n a -> a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,A,A,C(C1(U)),A,A)>,
     Unfolding: (\ @ (n :: * -> *)
                   ($dFoldable :: Data.Foldable.Foldable n)
                   @ a
                   ($dOrd :: GHC.Classes.Ord a) ->
                 let {
                   $dMonoid :: GHC.Base.Monoid (Data.Foldable.Max a)
                   = Data.Foldable.$fMonoidMax @ a $dOrd
                 } in
                 \ (x :: TraversableInstances.S n a) ->
                 case x of wild { TraversableInstances.S n1 a1 ->
                 case (Data.Foldable.foldMap
                         @ n
                         $dFoldable
                         @ (Data.Foldable.Max a)
                         @ a
                         $dMonoid
                         (GHC.Base.Just @ a)
                           `cast`
                         (<a>_R ->_R Sym (Data.Foldable.N:Max[0]) <a>_N)
                         n1)
                        `cast`
                      (Data.Foldable.N:Max[0] <a>_N) of wild1 {
                   GHC.Base.Nothing -> a1
                   GHC.Base.Just x1
                   -> case GHC.Classes.>= @ a $dOrd x1 a1 of wild2 {
                        GHC.Types.False -> a1 GHC.Types.True -> x1 } } }) -}
830583bcd30f054061d98a8af9ec4905
  $fFoldableS_$cminimum ::
    Data.Foldable.Foldable n =>
    forall a. GHC.Classes.Ord a => TraversableInstances.S n a -> a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,A,C(C1(U)),A,A,A,A)>,
     Unfolding: (\ @ (n :: * -> *)
                   ($dFoldable :: Data.Foldable.Foldable n)
                   @ a
                   ($dOrd :: GHC.Classes.Ord a) ->
                 let {
                   $dMonoid :: GHC.Base.Monoid (Data.Foldable.Min a)
                   = Data.Foldable.$fMonoidMin @ a $dOrd
                 } in
                 \ (x :: TraversableInstances.S n a) ->
                 case x of wild { TraversableInstances.S n1 a1 ->
                 case (Data.Foldable.foldMap
                         @ n
                         $dFoldable
                         @ (Data.Foldable.Min a)
                         @ a
                         $dMonoid
                         (GHC.Base.Just @ a)
                           `cast`
                         (<a>_R ->_R Sym (Data.Foldable.N:Min[0]) <a>_N)
                         n1)
                        `cast`
                      (Data.Foldable.N:Min[0] <a>_N) of wild1 {
                   GHC.Base.Nothing -> a1
                   GHC.Base.Just x1
                   -> case GHC.Classes.<= @ a $dOrd x1 a1 of wild2 {
                        GHC.Types.False -> a1 GHC.Types.True -> x1 } } }) -}
830583bcd30f054061d98a8af9ec4905
  $fFoldableS_$cnull ::
    Data.Foldable.Foldable n =>
    forall a. TraversableInstances.S n a -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U(U,A)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ (n :: * -> *)
                   ($dFoldable :: Data.Foldable.Foldable n)
                   @ a
                   (eta :: TraversableInstances.S n a) ->
                 case eta of wild { TraversableInstances.S n1 a1 ->
                 (Data.Foldable.foldMap
                    @ n
                    $dFoldable
                    @ (Data.Monoid.Endo GHC.Types.Bool)
                    @ a
                    (Data.Monoid.$fMonoidEndo @ GHC.Types.Bool)
                    (\ (ds :: a) (ds1 :: GHC.Types.Bool) -> GHC.Types.False)
                      `cast`
                    (<a>_R ->_R Sym (Data.Monoid.N:Endo[0] <GHC.Types.Bool>_R))
                    n1)
                   `cast`
                 (Data.Monoid.N:Endo[0] <GHC.Types.Bool>_R)
                   GHC.Types.False }) -}
830583bcd30f054061d98a8af9ec4905
  $fFoldableS_$cproduct ::
    Data.Foldable.Foldable n =>
    forall a. GHC.Num.Num a => TraversableInstances.S n a -> a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(A,A,U,A,A,A,C(U))>,
     Unfolding: (\ @ (n :: * -> *)
                   ($dFoldable :: Data.Foldable.Foldable n)
                   @ a
                   ($dNum :: GHC.Num.Num a) ->
                 let {
                   $dMonoid :: GHC.Base.Monoid (Data.Monoid.Product a)
                   = Data.Monoid.$fMonoidProduct @ a $dNum
                 } in
                 (\ (ds :: TraversableInstances.S n a) ->
                  case ds of wild { TraversableInstances.S n1 a1 ->
                  (GHC.Num.*
                     @ a
                     $dNum
                     (Data.Foldable.foldMap
                        @ n
                        $dFoldable
                        @ (Data.Monoid.Product a)
                        @ a
                        $dMonoid
                        (TraversableInstances.$fFoldableS1 @ a)
                          `cast`
                        (<a>_R ->_R Sym (Data.Monoid.N:Product[0] <a>_R))
                        n1)
                       `cast`
                     (Data.Monoid.N:Product[0] <a>_R)
                     a1)
                    `cast`
                  (Sym (Data.Monoid.N:Product[0] <a>_R)) })
                   `cast`
                 (<TraversableInstances.S n a>_R
                  ->_R Data.Monoid.N:Product[0] <a>_R)) -}
830583bcd30f054061d98a8af9ec4905
  $fFoldableS_$csum ::
    Data.Foldable.Foldable n =>
    forall a. GHC.Num.Num a => TraversableInstances.S n a -> a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U(U,A,A,A,A,A,C(U))>,
     Unfolding: (\ @ (n :: * -> *)
                   ($dFoldable :: Data.Foldable.Foldable n)
                   @ a
                   ($dNum :: GHC.Num.Num a) ->
                 let {
                   $dMonoid :: GHC.Base.Monoid (Data.Monoid.Sum a)
                   = Data.Monoid.$fMonoidSum @ a $dNum
                 } in
                 (\ (ds :: TraversableInstances.S n a) ->
                  case ds of wild { TraversableInstances.S n1 a1 ->
                  (GHC.Num.+
                     @ a
                     $dNum
                     (Data.Foldable.foldMap
                        @ n
                        $dFoldable
                        @ (Data.Monoid.Sum a)
                        @ a
                        $dMonoid
                        (TraversableInstances.$fFoldableS1 @ a)
                          `cast`
                        (<a>_R ->_R Sym (Data.Monoid.N:Sum[0] <a>_R))
                        n1)
                       `cast`
                     (Data.Monoid.N:Sum[0] <a>_R)
                     a1)
                    `cast`
                  (Sym (Data.Monoid.N:Sum[0] <a>_R)) })
                   `cast`
                 (<TraversableInstances.S n a>_R
                  ->_R Data.Monoid.N:Sum[0] <a>_R)) -}
830583bcd30f054061d98a8af9ec4905
  $fFoldableS_$ctoList ::
    Data.Foldable.Foldable n =>
    forall a. TraversableInstances.S n a -> [a]
  {- Arity: 2,
     Strictness: <L,U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (2, False, False)
                (\ @ (n :: * -> *)
                   ($dFoldable :: Data.Foldable.Foldable n)
                   @ a
                   (t1 :: TraversableInstances.S n a) ->
                 GHC.Base.build
                   @ a
                   (\ @ b (c :: a -> b -> b)[OneShot] (n1 :: b)[OneShot] ->
                    TraversableInstances.$fFoldableS_$cfoldr
                      @ n
                      $dFoldable
                      @ a
                      @ b
                      c
                      n1
                      t1)) -}
721a5d38cc38fed0984ecc96f773ca01
  $fFoldableThree ::
    Data.Foldable.Foldable (TraversableInstances.Three a b)
  DFunId
  {- HasNoCafRefs, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a @ b.
                  @ (TraversableInstances.Three a b)
                  (TraversableInstances.$fFoldableThree_$cfold @ a @ b)
                  (TraversableInstances.$fFoldableThree_$cfoldMap @ a @ b)
                  (TraversableInstances.$fFoldableThree_$cfoldr @ a @ b)
                  (TraversableInstances.$fFoldableThree_$cfoldr @ a @ b)
                  (TraversableInstances.$fFoldableThree_$cfoldl @ a @ b)
                  (TraversableInstances.$fFoldableThree_$cfoldl @ a @ b)
                  (TraversableInstances.$fFoldableThree_$cfoldr1 @ a @ b)
                  (TraversableInstances.$fFoldableThree_$cfoldr1 @ a @ b)
                  (TraversableInstances.$fFoldableThree_$ctoList @ a @ b)
                  (TraversableInstances.$fFoldableThree_$cnull @ a @ b)
                  (TraversableInstances.$fFoldableThree_$clength @ a @ b)
                  (TraversableInstances.$fFoldableThree_$celem @ a @ b)
                  (TraversableInstances.$fFoldableThree_$cmaximum @ a @ b)
                  (TraversableInstances.$fFoldableThree_$cmaximum @ a @ b)
                  (TraversableInstances.$fFoldableThree_$csum @ a @ b)
                  (TraversableInstances.$fFoldableThree_$cproduct @ a @ b) -}
721a5d38cc38fed0984ecc96f773ca01
  $fFoldableThree1 ::
    GHC.Num.Num a1 =>
    TraversableInstances.Three a b a1 -> Data.Monoid.Product a1
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LLC(C(S))LLLL),U(A,A,1*C1(C1(U)),A,A,A,1*C1(U))><S,1*U(A,A,U)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   @ b
                   @ a1
                   ($dNum :: GHC.Num.Num a1)
                   (eta :: TraversableInstances.Three a b a1) ->
                 case eta of wild { TraversableInstances.Three ds ds1 c ->
                 (GHC.Num.*
                    @ a1
                    $dNum
                    c
                    (GHC.Num.fromInteger @ a1 $dNum Data.Monoid.$fMonoidProduct1))
                   `cast`
                 (Sym (Data.Monoid.N:Product[0] <a1>_R)) }) -}
721a5d38cc38fed0984ecc96f773ca01
  $fFoldableThree2 ::
    GHC.Num.Num a1 =>
    TraversableInstances.Three a b a1 -> Data.Monoid.Sum a1
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(C(C(S))LLLLLL),U(1*C1(C1(U)),A,A,A,A,A,1*C1(U))><S,1*U(A,A,U)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   @ b
                   @ a1
                   ($dNum :: GHC.Num.Num a1)
                   (eta :: TraversableInstances.Three a b a1) ->
                 case eta of wild { TraversableInstances.Three ds ds1 c ->
                 (GHC.Num.+
                    @ a1
                    $dNum
                    c
                    (GHC.Num.fromInteger @ a1 $dNum Data.Monoid.$fMonoidSum1))
                   `cast`
                 (Sym (Data.Monoid.N:Sum[0] <a1>_R)) }) -}
721a5d38cc38fed0984ecc96f773ca01
  $fFoldableThree_$celem ::
    GHC.Classes.Eq a1 =>
    a1 -> TraversableInstances.Three a b a1 -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(1*C1(U),A)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b @ a1 ($dEq :: GHC.Classes.Eq a1) (eta :: a1) ->
                 let {
                   f :: a1 -> GHC.Types.Bool = GHC.Classes.== @ a1 $dEq eta
                 } in
                 (\ (eta1 :: TraversableInstances.Three a b a1) ->
                  case eta1 of wild { TraversableInstances.Three ds ds1 c ->
                  (f c) `cast` (Sym (Data.Monoid.N:Any[0])) })
                   `cast`
                 (<TraversableInstances.Three a b a1>_R
                  ->_R Data.Monoid.N:Any[0])) -}
721a5d38cc38fed0984ecc96f773ca01
  $fFoldableThree_$cfold ::
    GHC.Base.Monoid m => TraversableInstances.Three a b m -> m
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LC(C(S))L),U(1*U,1*C1(C1(U)),A)><S,1*U(A,A,U)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   @ b
                   @ m
                   ($dMonoid :: GHC.Base.Monoid m)
                   (eta :: TraversableInstances.Three a b m) ->
                 case eta of wild { TraversableInstances.Three ds ds1 c ->
                 GHC.Base.mappend
                   @ m
                   $dMonoid
                   c
                   (GHC.Base.mempty @ m $dMonoid) }) -}
721a5d38cc38fed0984ecc96f773ca01
  $fFoldableThree_$cfoldMap ::
    GHC.Base.Monoid m =>
    (a1 -> m) -> TraversableInstances.Three a b a1 -> m
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U(1*U,1*U,A)><L,C(U)>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ a
                   @ b
                   @ m
                   @ a1
                   ($dMonoid :: GHC.Base.Monoid m)
                   (f :: a1 -> m)
                   (eta :: TraversableInstances.Three a b a1) ->
                 TraversableInstances.$fFoldableThree_$cfoldr
                   @ a
                   @ b
                   @ a1
                   @ m
                   (\ (x :: a1)[OneShot] -> GHC.Base.mappend @ m $dMonoid (f x))
                   (GHC.Base.mempty @ m $dMonoid)
                   eta) -}
721a5d38cc38fed0984ecc96f773ca01
  $fFoldableThree_$cfoldl ::
    (b1 -> a1 -> b1) -> b1 -> TraversableInstances.Three a b a1 -> b1
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(C(S)),1*C1(C1(U))><L,U><S,1*U(A,A,U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ b
                   @ b1
                   @ a1
                   (f :: b1 -> a1 -> b1)
                   (z :: b1)
                   (t1 :: TraversableInstances.Three a b a1) ->
                 case t1 of wild { TraversableInstances.Three ds ds1 c ->
                 f z c }) -}
721a5d38cc38fed0984ecc96f773ca01
  $fFoldableThree_$cfoldr ::
    (a1 -> b1 -> b1) -> b1 -> TraversableInstances.Three a b a1 -> b1
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(C(S)),1*C1(C1(U))><L,U><S,1*U(A,A,U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ b
                   @ a1
                   @ b1
                   (f :: a1 -> b1 -> b1)
                   (b2 :: b1)
                   (ds :: TraversableInstances.Three a b a1) ->
                 case ds of wild { TraversableInstances.Three ds1 ds2 c ->
                 f c b2 }) -}
721a5d38cc38fed0984ecc96f773ca01
  $fFoldableThree_$cfoldr1 ::
    (a1 -> a1 -> a1) -> TraversableInstances.Three a b a1 -> a1
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><S(LLS),1*U(A,A,1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   @ b
                   @ a1
                   (f :: a1 -> a1 -> a1)
                   (xs :: TraversableInstances.Three a b a1) ->
                 case xs of wild { TraversableInstances.Three ds ds1 c -> c }) -}
721a5d38cc38fed0984ecc96f773ca01
  $fFoldableThree_$clength ::
    TraversableInstances.Three a b a1 -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*H>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ a @ b @ a1 (xs :: TraversableInstances.Three a b a1) ->
                 case xs of wild { TraversableInstances.Three ds ds1 c ->
                 GHC.Types.I# 1# }) -}
721a5d38cc38fed0984ecc96f773ca01
  $fFoldableThree_$cmaximum ::
    GHC.Classes.Ord a1 => TraversableInstances.Three a b a1 -> a1
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><S(LLS),1*U(A,A,1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   @ b
                   @ a1
                   ($dOrd :: GHC.Classes.Ord a1)
                   (x :: TraversableInstances.Three a b a1) ->
                 case x of wild { TraversableInstances.Three ds ds1 c -> c }) -}
721a5d38cc38fed0984ecc96f773ca01
  $fFoldableThree_$cnull ::
    TraversableInstances.Three a b a1 -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*H>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a @ b @ a1 (ds :: TraversableInstances.Three a b a1) ->
                 case ds of wild { TraversableInstances.Three ds1 ds2 c ->
                 GHC.Types.False }) -}
721a5d38cc38fed0984ecc96f773ca01
  $fFoldableThree_$cproduct ::
    GHC.Num.Num a1 => TraversableInstances.Three a b a1 -> a1
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LLC(C(S))LLLL),U(A,A,1*C1(C1(U)),A,A,A,1*C1(U))><S,1*U(A,A,U)>,
     Unfolding: InlineRule (0, True, True)
                TraversableInstances.$fFoldableThree1
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N) (a1 :: <*>_N).
                 <GHC.Num.Num a1>_R
                 ->_R <TraversableInstances.Three a b a1>_R
                 ->_R Data.Monoid.N:Product[0] <a1>_R) -}
721a5d38cc38fed0984ecc96f773ca01
  $fFoldableThree_$csum ::
    GHC.Num.Num a1 => TraversableInstances.Three a b a1 -> a1
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(C(C(S))LLLLLL),U(1*C1(C1(U)),A,A,A,A,A,1*C1(U))><S,1*U(A,A,U)>,
     Unfolding: InlineRule (0, True, True)
                TraversableInstances.$fFoldableThree2
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N) (a1 :: <*>_N).
                 <GHC.Num.Num a1>_R
                 ->_R <TraversableInstances.Three a b a1>_R
                 ->_R Data.Monoid.N:Sum[0] <a1>_R) -}
721a5d38cc38fed0984ecc96f773ca01
  $fFoldableThree_$ctoList ::
    TraversableInstances.Three a b a1 -> [a1]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ a @ b @ a1 (t1 :: TraversableInstances.Three a b a1) ->
                 GHC.Base.build
                   @ a1
                   (\ @ b1 (c :: a1 -> b1 -> b1)[OneShot] (n :: b1)[OneShot] ->
                    TraversableInstances.$fFoldableThree_$cfoldr
                      @ a
                      @ b
                      @ a1
                      @ b1
                      c
                      n
                      t1)) -}
4ba7eb63788e9e9f6786ec57a70a2853
  $fFoldableTree :: Data.Foldable.Foldable TraversableInstances.Tree
  DFunId
  {- Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ TraversableInstances.Tree
                  TraversableInstances.$fFoldableTree_$cfold
                  TraversableInstances.$fFoldableTree_$cfoldMap
                  TraversableInstances.$fFoldableTree_$cfoldr
                  TraversableInstances.$fFoldableTree_$cfoldr'
                  TraversableInstances.$fFoldableTree_$cfoldl
                  TraversableInstances.$fFoldableTree_$cfoldl'
                  TraversableInstances.$fFoldableTree_$cfoldr1
                  TraversableInstances.$fFoldableTree_$cfoldl1
                  TraversableInstances.$fFoldableTree_$ctoList
                  TraversableInstances.$fFoldableTree_$cnull
                  TraversableInstances.$fFoldableTree_$clength
                  TraversableInstances.$fFoldableTree_$celem
                  TraversableInstances.$fFoldableTree_$cmaximum
                  TraversableInstances.$fFoldableTree_$cminimum
                  TraversableInstances.$fFoldableTree_$csum
                  TraversableInstances.$fFoldableTree_$cproduct -}
4ba7eb63788e9e9f6786ec57a70a2853
  $fFoldableTree1 ::
    GHC.Num.Num a =>
    TraversableInstances.Tree a -> Data.Monoid.Product a
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(A,A,U,A,A,A,C(U))>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a ($dNum :: GHC.Num.Num a) ->
                 TraversableInstances.$fFoldableTree_$cfoldMap
                   @ (Data.Monoid.Product a)
                   @ a
                   (Data.Monoid.$fMonoidProduct @ a $dNum)
                   (\ (tpl :: a) -> tpl)
                     `cast`
                   (<a>_R ->_R Sym (Data.Monoid.N:Product[0] <a>_R))) -}
4ba7eb63788e9e9f6786ec57a70a2853
  $fFoldableTree2 ::
    GHC.Num.Num a => TraversableInstances.Tree a -> Data.Monoid.Sum a
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(U,A,A,A,A,A,C(U))>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a ($dNum :: GHC.Num.Num a) ->
                 TraversableInstances.$fFoldableTree_$cfoldMap
                   @ (Data.Monoid.Sum a)
                   @ a
                   (Data.Monoid.$fMonoidSum @ a $dNum)
                   (\ (tpl :: a) -> tpl)
                     `cast`
                   (<a>_R ->_R Sym (Data.Monoid.N:Sum[0] <a>_R))) -}
4ba7eb63788e9e9f6786ec57a70a2853
  $fFoldableTree3 ::
    GHC.Classes.Eq a =>
    a -> TraversableInstances.Tree a -> Data.Monoid.Any
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(1*C1(C(U)),A)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dEq :: GHC.Classes.Eq a) (eta :: a) ->
                 TraversableInstances.$fFoldableTree_$cfoldMap
                   @ Data.Monoid.Any
                   @ a
                   Data.Monoid.$fMonoidAny
                   (GHC.Classes.== @ a $dEq eta)
                     `cast`
                   (<a>_R ->_R Sym (Data.Monoid.N:Any[0]))) -}
4ba7eb63788e9e9f6786ec57a70a2853
  $fFoldableTree_$celem ::
    GHC.Classes.Eq a =>
    a -> TraversableInstances.Tree a -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(1*C1(C(U)),A)><L,U>,
     Unfolding: InlineRule (0, True, True)
                TraversableInstances.$fFoldableTree3
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Classes.Eq a>_R
                 ->_R <a>_R
                 ->_R <TraversableInstances.Tree a>_R
                 ->_R Data.Monoid.N:Any[0]) -}
4ba7eb63788e9e9f6786ec57a70a2853
  $fFoldableTree_$cfold ::
    GHC.Base.Monoid m => TraversableInstances.Tree m -> m
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U(U,C(C1(U)),A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ m
                   ($dMonoid :: GHC.Base.Monoid m)
                   (eta :: TraversableInstances.Tree m) ->
                 TraversableInstances.$fFoldableTree_$cfoldMap
                   @ m
                   @ m
                   $dMonoid
                   (GHC.Base.id @ m)
                   eta) -}
4ba7eb63788e9e9f6786ec57a70a2853
  $fFoldableTree_$cfoldMap ::
    GHC.Base.Monoid m => (a -> m) -> TraversableInstances.Tree a -> m
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(U,C(C1(U)),A)><L,C(U)><S,1*U> -}
4ba7eb63788e9e9f6786ec57a70a2853
  $fFoldableTree_$cfoldl ::
    (b -> a -> b) -> b -> TraversableInstances.Tree a -> b
  {- Arity: 3, Strictness: <L,C(C1(U))><L,U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ b
                   @ a
                   (f :: b -> a -> b)
                   (z :: b)
                   (t1 :: TraversableInstances.Tree a) ->
                 (TraversableInstances.$fFoldableTree_$cfoldMap
                    @ (Data.Monoid.Dual (Data.Monoid.Endo b))
                    @ a
                    (TraversableInstances.$fFoldableS3 @ b)
                    (\ (x :: a) (eta :: b) -> f eta x)
                      `cast`
                    (<a>_R
                     ->_R Sym (Data.Monoid.N:Dual[0] (Data.Monoid.N:Endo[0] <b>_R)))
                    t1)
                   `cast`
                 (Data.Monoid.N:Dual[0] (Data.Monoid.N:Endo[0] <b>_R))
                   z) -}
4ba7eb63788e9e9f6786ec57a70a2853
  $fFoldableTree_$cfoldl' ::
    (b -> a -> b) -> b -> TraversableInstances.Tree a -> b
  {- Arity: 3, HasNoCafRefs, Strictness: <L,C(C1(U))><L,U><S,1*U>,
     Unfolding: (\ @ b
                   @ a
                   (f :: b -> a -> b)
                   (z0 :: b)
                   (xs :: TraversableInstances.Tree a) ->
                 (TraversableInstances.$fFoldableTree_$cfoldMap
                    @ (Data.Monoid.Endo (b -> b))
                    @ a
                    (Data.Monoid.$fMonoidEndo @ (b -> b))
                    (\ (x :: a) (k :: b -> b) (z :: b) ->
                     case f z x of vx { DEFAULT -> k vx })
                      `cast`
                    (<a>_R ->_R Sym (Data.Monoid.N:Endo[0] <b -> b>_R))
                    xs)
                   `cast`
                 (Data.Monoid.N:Endo[0] <b -> b>_R)
                   (GHC.Base.id @ b)
                   z0) -}
4ba7eb63788e9e9f6786ec57a70a2853
  $fFoldableTree_$cfoldl1 ::
    (a -> a -> a) -> TraversableInstances.Tree a -> a
  {- Arity: 2, Strictness: <L,C(C1(U))><S,1*U>,
     Unfolding: (\ @ a
                   (f :: a -> a -> a)
                   (xs :: TraversableInstances.Tree a) ->
                 case (TraversableInstances.$fFoldableTree_$cfoldMap
                         @ (Data.Monoid.Dual (Data.Monoid.Endo (GHC.Base.Maybe a)))
                         @ a
                         (TraversableInstances.$fFoldableS3 @ (GHC.Base.Maybe a))
                         (\ (x :: a) (eta :: GHC.Base.Maybe a) ->
                          GHC.Base.Just
                            @ a
                            (case eta of wild {
                               GHC.Base.Nothing -> x GHC.Base.Just x1 -> f x1 x }))
                           `cast`
                         (<a>_R
                          ->_R Sym (Data.Monoid.N:Dual[0]
                                        (Data.Monoid.N:Endo[0] <GHC.Base.Maybe a>_R)))
                         xs)
                        `cast`
                      (Data.Monoid.N:Dual[0]
                           (Data.Monoid.N:Endo[0] <GHC.Base.Maybe a>_R))
                        (GHC.Base.Nothing @ a) of wild {
                   GHC.Base.Nothing -> TraversableInstances.$fFoldableList7 @ a
                   GHC.Base.Just v -> v }) -}
4ba7eb63788e9e9f6786ec57a70a2853
  $fFoldableTree_$cfoldr ::
    (a -> b -> b) -> b -> TraversableInstances.Tree a -> b
  {- Arity: 3, HasNoCafRefs, Strictness: <L,C(U)><L,U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ b
                   (f :: a -> b -> b)
                   (z :: b)
                   (t1 :: TraversableInstances.Tree a) ->
                 (TraversableInstances.$fFoldableTree_$cfoldMap
                    @ (Data.Monoid.Endo b)
                    @ a
                    (Data.Monoid.$fMonoidEndo @ b)
                    f `cast` (<a>_R ->_R Sym (Data.Monoid.N:Endo[0] <b>_R))
                    t1)
                   `cast`
                 (Data.Monoid.N:Endo[0] <b>_R)
                   z) -}
4ba7eb63788e9e9f6786ec57a70a2853
  $fFoldableTree_$cfoldr' ::
    (a -> b -> b) -> b -> TraversableInstances.Tree a -> b
  {- Arity: 3, Strictness: <L,C(C1(U))><L,U><S,1*U>,
     Unfolding: (\ @ a
                   @ b
                   (f :: a -> b -> b)
                   (z0 :: b)
                   (xs :: TraversableInstances.Tree a) ->
                 (TraversableInstances.$fFoldableTree_$cfoldMap
                    @ (Data.Monoid.Dual (Data.Monoid.Endo (b -> b)))
                    @ a
                    (TraversableInstances.$fFoldableS3 @ (b -> b))
                    (\ (x :: a) (eta :: b -> b) (z :: b) ->
                     case f x z of vx { DEFAULT -> eta vx })
                      `cast`
                    (<a>_R
                     ->_R Sym (Data.Monoid.N:Dual[0]
                                   (Data.Monoid.N:Endo[0] <b -> b>_R)))
                    xs)
                   `cast`
                 (Data.Monoid.N:Dual[0] (Data.Monoid.N:Endo[0] <b -> b>_R))
                   (GHC.Base.id @ b)
                   z0) -}
4ba7eb63788e9e9f6786ec57a70a2853
  $fFoldableTree_$cfoldr1 ::
    (a -> a -> a) -> TraversableInstances.Tree a -> a
  {- Arity: 2, Strictness: <L,C(C1(U))><S,1*U>,
     Unfolding: (\ @ a
                   (f :: a -> a -> a)
                   (xs :: TraversableInstances.Tree a) ->
                 case (TraversableInstances.$fFoldableTree_$cfoldMap
                         @ (Data.Monoid.Endo (GHC.Base.Maybe a))
                         @ a
                         (Data.Monoid.$fMonoidEndo @ (GHC.Base.Maybe a))
                         (\ (x :: a) (m :: GHC.Base.Maybe a) ->
                          GHC.Base.Just
                            @ a
                            (case m of wild {
                               GHC.Base.Nothing -> x GHC.Base.Just y -> f x y }))
                           `cast`
                         (<a>_R ->_R Sym (Data.Monoid.N:Endo[0] <GHC.Base.Maybe a>_R))
                         xs)
                        `cast`
                      (Data.Monoid.N:Endo[0] <GHC.Base.Maybe a>_R)
                        (GHC.Base.Nothing @ a) of wild {
                   GHC.Base.Nothing -> TraversableInstances.$fFoldableList8 @ a
                   GHC.Base.Just v -> v }) -}
4ba7eb63788e9e9f6786ec57a70a2853
  $fFoldableTree_$clength ::
    TraversableInstances.Tree a -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ @ a (xs :: TraversableInstances.Tree a) ->
                 (TraversableInstances.$fFoldableTree_$cfoldMap
                    @ (Data.Monoid.Endo (GHC.Types.Int -> GHC.Types.Int))
                    @ a
                    (Data.Monoid.$fMonoidEndo @ (GHC.Types.Int -> GHC.Types.Int))
                    (TraversableInstances.$fFoldableList5 @ a)
                      `cast`
                    (<a>_R
                     ->_R Sym (Data.Monoid.N:Endo[0]
                                   <GHC.Types.Int -> GHC.Types.Int>_R))
                    xs)
                   `cast`
                 (Data.Monoid.N:Endo[0] <GHC.Types.Int -> GHC.Types.Int>_R)
                   (GHC.Base.id @ GHC.Types.Int)
                   TraversableInstances.$fFoldableConstant1) -}
4ba7eb63788e9e9f6786ec57a70a2853
  $fFoldableTree_$cmaximum ::
    GHC.Classes.Ord a => TraversableInstances.Tree a -> a
  {- Arity: 1, Strictness: <L,U(A,A,A,A,A,C(C1(U)),A,A)>,
     Unfolding: (\ @ a ($dOrd :: GHC.Classes.Ord a) ->
                 let {
                   g :: GHC.Base.Monoid (Data.Foldable.Max a)
                   = Data.Foldable.$fMonoidMax @ a $dOrd
                 } in
                 \ (x :: TraversableInstances.Tree a) ->
                 case (TraversableInstances.$fFoldableTree_$cfoldMap
                         @ (Data.Foldable.Max a)
                         @ a
                         g
                         (GHC.Base.Just @ a)
                           `cast`
                         (<a>_R ->_R Sym (Data.Foldable.N:Max[0]) <a>_N)
                         x)
                        `cast`
                      (Data.Foldable.N:Max[0] <a>_N) of wild {
                   GHC.Base.Nothing -> TraversableInstances.$fFoldableList4 @ a
                   GHC.Base.Just v -> v }) -}
4ba7eb63788e9e9f6786ec57a70a2853
  $fFoldableTree_$cminimum ::
    GHC.Classes.Ord a => TraversableInstances.Tree a -> a
  {- Arity: 1, Strictness: <L,U(A,A,A,C(C1(U)),A,A,A,A)>,
     Unfolding: (\ @ a ($dOrd :: GHC.Classes.Ord a) ->
                 let {
                   g :: GHC.Base.Monoid (Data.Foldable.Min a)
                   = Data.Foldable.$fMonoidMin @ a $dOrd
                 } in
                 \ (x :: TraversableInstances.Tree a) ->
                 case (TraversableInstances.$fFoldableTree_$cfoldMap
                         @ (Data.Foldable.Min a)
                         @ a
                         g
                         (GHC.Base.Just @ a)
                           `cast`
                         (<a>_R ->_R Sym (Data.Foldable.N:Min[0]) <a>_N)
                         x)
                        `cast`
                      (Data.Foldable.N:Min[0] <a>_N) of wild {
                   GHC.Base.Nothing -> TraversableInstances.$fFoldableList3 @ a
                   GHC.Base.Just v -> v }) -}
4ba7eb63788e9e9f6786ec57a70a2853
  $fFoldableTree_$cnull ::
    TraversableInstances.Tree a -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (t1 :: TraversableInstances.Tree a) ->
                 (TraversableInstances.$fFoldableTree_$cfoldMap
                    @ (Data.Monoid.Endo GHC.Types.Bool)
                    @ a
                    (Data.Monoid.$fMonoidEndo @ GHC.Types.Bool)
                    (TraversableInstances.$fFoldableList6 @ a)
                      `cast`
                    (<a>_R ->_R Sym (Data.Monoid.N:Endo[0] <GHC.Types.Bool>_R))
                    t1)
                   `cast`
                 (Data.Monoid.N:Endo[0] <GHC.Types.Bool>_R)
                   GHC.Types.True) -}
4ba7eb63788e9e9f6786ec57a70a2853
  $fFoldableTree_$cproduct ::
    GHC.Num.Num a => TraversableInstances.Tree a -> a
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(A,A,U,A,A,A,C(U))>,
     Unfolding: InlineRule (0, True, True)
                TraversableInstances.$fFoldableTree1
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Num.Num a>_R
                 ->_R <TraversableInstances.Tree a>_R
                 ->_R Data.Monoid.N:Product[0] <a>_R) -}
4ba7eb63788e9e9f6786ec57a70a2853
  $fFoldableTree_$csum ::
    GHC.Num.Num a => TraversableInstances.Tree a -> a
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(U,A,A,A,A,A,C(U))>,
     Unfolding: InlineRule (0, True, True)
                TraversableInstances.$fFoldableTree2
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Num.Num a>_R
                 ->_R <TraversableInstances.Tree a>_R
                 ->_R Data.Monoid.N:Sum[0] <a>_R) -}
4ba7eb63788e9e9f6786ec57a70a2853
  $fFoldableTree_$ctoList :: TraversableInstances.Tree a -> [a]
  {- Arity: 1, Strictness: <L,U>, Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ a (t1 :: TraversableInstances.Tree a) ->
                 GHC.Base.build
                   @ a
                   (\ @ b (c :: a -> b -> b)[OneShot] (n :: b)[OneShot] ->
                    TraversableInstances.$fFoldableTree_$cfoldr @ a @ b c n t1)) -}
cddb4f9513e650624772d2c687832791
  $fFunctorBig :: GHC.Base.Functor (TraversableInstances.Big a)
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a.
                  @ (TraversableInstances.Big a)
                  (TraversableInstances.$fFunctorBig_$cfmap @ a)
                  (TraversableInstances.$fFunctorBig_$c<$ @ a) -}
cddb4f9513e650624772d2c687832791
  $fFunctorBig_$c<$ ::
    a1 -> TraversableInstances.Big a b -> TraversableInstances.Big a a1
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U(U,A,A)>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   @ a1
                   @ b
                   (eta :: a1)
                   (eta1 :: TraversableInstances.Big a b) ->
                 case eta1 of wild { TraversableInstances.Big a2 b1 b' ->
                 TraversableInstances.Big @ a @ a1 a2 eta eta }) -}
cddb4f9513e650624772d2c687832791
  $fFunctorBig_$cfmap ::
    (a1 -> b)
    -> TraversableInstances.Big a a1 -> TraversableInstances.Big a b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U(U,U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   @ a1
                   @ b
                   (f :: a1 -> b)
                   (ds :: TraversableInstances.Big a a1) ->
                 case ds of wild { TraversableInstances.Big a2 b1 b' ->
                 TraversableInstances.Big @ a @ b a2 (f b1) (f b') }) -}
8373cb9b5cc904797ff1fb1bafd8cdce
  $fFunctorBigger :: GHC.Base.Functor (TraversableInstances.Bigger a)
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a.
                  @ (TraversableInstances.Bigger a)
                  (TraversableInstances.$fFunctorBigger_$cfmap @ a)
                  (TraversableInstances.$fFunctorBigger_$c<$ @ a) -}
8373cb9b5cc904797ff1fb1bafd8cdce
  $fFunctorBigger_$c<$ ::
    a1
    -> TraversableInstances.Bigger a b
    -> TraversableInstances.Bigger a a1
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U(U,A,A,A)>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   @ a1
                   @ b
                   (eta :: a1)
                   (eta1 :: TraversableInstances.Bigger a b) ->
                 case eta1 of wild { TraversableInstances.Bigger a2 b1 b' b'' ->
                 TraversableInstances.Bigger @ a @ a1 a2 eta eta eta }) -}
8373cb9b5cc904797ff1fb1bafd8cdce
  $fFunctorBigger_$cfmap ::
    (a1 -> b)
    -> TraversableInstances.Bigger a a1
    -> TraversableInstances.Bigger a b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U(U,U,U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   @ a1
                   @ b
                   (f :: a1 -> b)
                   (ds :: TraversableInstances.Bigger a a1) ->
                 case ds of wild { TraversableInstances.Bigger a2 b1 b' b'' ->
                 TraversableInstances.Bigger @ a @ b a2 (f b1) (f b') (f b'') }) -}
a06a627f62d93f6fedbee61792bf9f78
  $fFunctorConstant ::
    GHC.Base.Functor (TraversableInstances.Constant a)
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a.
                  @ (TraversableInstances.Constant a)
                  (TraversableInstances.$fFunctorConstant_$cfmap @ a)
                  (TraversableInstances.$fFunctorConstant_$c<$ @ a) -}
a06a627f62d93f6fedbee61792bf9f78
  $fFunctorConstant1 ::
    a1
    -> TraversableInstances.Constant a b
    -> TraversableInstances.Constant a b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><S,1*U>,
     Unfolding: InlineRule (2, True, True)
                (\ @ b
                   @ a
                   @ a1
                   (eta :: a1)
                   (ds :: TraversableInstances.Constant a b) ->
                 ds) -}
a06a627f62d93f6fedbee61792bf9f78
  $fFunctorConstant2 ::
    (a1 -> b)
    -> TraversableInstances.Constant a a1
    -> TraversableInstances.Constant a a1
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><S,1*U>,
     Unfolding: InlineRule (2, True, True)
                (\ @ a
                   @ a1
                   @ b
                   (ds :: a1 -> b)
                   (ds1 :: TraversableInstances.Constant a a1) ->
                 ds1) -}
a06a627f62d93f6fedbee61792bf9f78
  $fFunctorConstant_$c<$ ::
    a1
    -> TraversableInstances.Constant a b
    -> TraversableInstances.Constant a a1
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                (\ @ a @ a1 @ b ->
                 TraversableInstances.$fFunctorConstant1 @ b @ a @ a1)
                  `cast`
                (forall (a :: <*>_N) (a1 :: <*>_N) (b :: <*>_N).
                 <a1>_R
                 ->_R <TraversableInstances.Constant a b>_R
                 ->_R Trans
                          (TraversableInstances.N:Constant[0] <a>_R <b>_P)
                          (Sym (TraversableInstances.N:Constant[0] <a>_R <a1>_P))) -}
a06a627f62d93f6fedbee61792bf9f78
  $fFunctorConstant_$cfmap ::
    (a1 -> b)
    -> TraversableInstances.Constant a a1
    -> TraversableInstances.Constant a b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                TraversableInstances.$fFunctorConstant2
                  `cast`
                (forall (a :: <*>_N) (a1 :: <*>_N) (b :: <*>_N).
                 <a1 -> b>_R
                 ->_R <TraversableInstances.Constant a a1>_R
                 ->_R Trans
                          (TraversableInstances.N:Constant[0] <a>_R <a1>_P)
                          (Sym (TraversableInstances.N:Constant[0] <a>_R <b>_P))) -}
729de049f804209d218b6ac6412958e0
  $fFunctorIdentity :: GHC.Base.Functor TraversableInstances.Identity
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ TraversableInstances.Identity
                  TraversableInstances.$fFunctorIdentity_$cfmap
                  TraversableInstances.$fFunctorIdentity_$c<$ -}
729de049f804209d218b6ac6412958e0
  $fFunctorIdentity1 :: a -> TraversableInstances.Identity b -> a
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,A>,
     Unfolding: InlineRule (2, True, True)
                (\ @ b @ a (eta :: a) (ds :: TraversableInstances.Identity b) ->
                 eta) -}
729de049f804209d218b6ac6412958e0
  $fFunctorIdentity2 ::
    (a -> b) -> TraversableInstances.Identity a -> b
  {- Arity: 2, HasNoCafRefs, Strictness: <C(S),1*C1(U)><L,U>,
     Unfolding: InlineRule (2, True, True)
                (\ @ a @ b (f :: a -> b) (ds :: TraversableInstances.Identity a) ->
                 f ds `cast` (TraversableInstances.N:Identity[0] <a>_R)) -}
729de049f804209d218b6ac6412958e0
  $fFunctorIdentity_$c<$ ::
    a
    -> TraversableInstances.Identity b
    -> TraversableInstances.Identity a
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,A>,
     Unfolding: InlineRule (0, True, True)
                (\ @ a @ b -> TraversableInstances.$fFunctorIdentity1 @ b @ a)
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <a>_R
                 ->_R <TraversableInstances.Identity b>_R
                 ->_R Sym (TraversableInstances.N:Identity[0] <a>_R)) -}
729de049f804209d218b6ac6412958e0
  $fFunctorIdentity_$cfmap ::
    (a -> b)
    -> TraversableInstances.Identity a
    -> TraversableInstances.Identity b
  {- Arity: 2, HasNoCafRefs, Strictness: <C(S),1*C1(U)><L,U>,
     Unfolding: InlineRule (0, True, True)
                TraversableInstances.$fFunctorIdentity2
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <a -> b>_R
                 ->_R <TraversableInstances.Identity a>_R
                 ->_R Sym (TraversableInstances.N:Identity[0] <b>_R)) -}
b205c9375ec1b24a907de4864e47820f
  $fFunctorList :: GHC.Base.Functor TraversableInstances.List
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ TraversableInstances.List
                  TraversableInstances.$fFunctorList_$cfmap
                  TraversableInstances.$fFunctorList_$c<$ -}
b205c9375ec1b24a907de4864e47820f
  $fFunctorList_$c<$ ::
    a -> TraversableInstances.List b -> TraversableInstances.List a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (eta :: a) (eta1 :: TraversableInstances.List b) ->
                 TraversableInstances.$fFunctorList_$cfmap
                   @ b
                   @ a
                   (\ (ds :: b) -> eta)
                   eta1) -}
b205c9375ec1b24a907de4864e47820f
  $fFunctorList_$cfmap ::
    (a -> b)
    -> TraversableInstances.List a -> TraversableInstances.List b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U> -}
9b0dc1c42b799f2c204b6c11f0bab139
  $fFunctorOptional :: GHC.Base.Functor TraversableInstances.Optional
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ TraversableInstances.Optional
                  TraversableInstances.$fFunctorOptional_$cfmap
                  TraversableInstances.$fFunctorOptional_$c<$ -}
9b0dc1c42b799f2c204b6c11f0bab139
  $fFunctorOptional_$c<$ ::
    a
    -> TraversableInstances.Optional b
    -> TraversableInstances.Optional a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (eta :: a) (ds :: TraversableInstances.Optional b) ->
                 case ds of wild {
                   TraversableInstances.Nada -> TraversableInstances.Nada @ a
                   TraversableInstances.Yep a1
                   -> TraversableInstances.Yep @ a eta }) -}
9b0dc1c42b799f2c204b6c11f0bab139
  $fFunctorOptional_$cfmap ::
    (a -> b)
    -> TraversableInstances.Optional a
    -> TraversableInstances.Optional b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*C1(U)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   @ b
                   (ds :: a -> b)
                   (ds1 :: TraversableInstances.Optional a) ->
                 case ds1 of wild {
                   TraversableInstances.Nada -> TraversableInstances.Nada @ b
                   TraversableInstances.Yep a1
                   -> TraversableInstances.Yep @ b (ds a1) }) -}
96406d61d01da17b40bba6954858f9d9
  $fFunctorPair :: GHC.Base.Functor (TraversableInstances.Pair a)
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a.
                  @ (TraversableInstances.Pair a)
                  (TraversableInstances.$fFunctorPair_$cfmap @ a)
                  (TraversableInstances.$fFunctorPair_$c<$ @ a) -}
96406d61d01da17b40bba6954858f9d9
  $fFunctorPair_$c<$ ::
    a1
    -> TraversableInstances.Pair a b -> TraversableInstances.Pair a a1
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U(U,A)>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   @ a1
                   @ b
                   (eta :: a1)
                   (ds :: TraversableInstances.Pair a b) ->
                 case ds of wild { TraversableInstances.Pair a2 b1 ->
                 TraversableInstances.Pair @ a @ a1 a2 eta }) -}
96406d61d01da17b40bba6954858f9d9
  $fFunctorPair_$cfmap ::
    (a1 -> b)
    -> TraversableInstances.Pair a a1 -> TraversableInstances.Pair a b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*C1(U)><S,1*U(U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   @ a1
                   @ b
                   (f :: a1 -> b)
                   (ds :: TraversableInstances.Pair a a1) ->
                 case ds of wild { TraversableInstances.Pair a2 b1 ->
                 TraversableInstances.Pair @ a @ b a2 (f b1) }) -}
830583bcd30f054061d98a8af9ec4905
  $fFunctorS ::
    GHC.Base.Functor n => GHC.Base.Functor (TraversableInstances.S n)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ (n :: * -> *) ($dFunctor :: GHC.Base.Functor n).
                  @ (TraversableInstances.S n)
                  (TraversableInstances.$fFunctorS_$cfmap @ n $dFunctor)
                  (TraversableInstances.$fFunctorS_$c<$ @ n $dFunctor) -}
830583bcd30f054061d98a8af9ec4905
  $fFunctorS_$c<$ ::
    GHC.Base.Functor n =>
    forall a b.
    a -> TraversableInstances.S n b -> TraversableInstances.S n a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><L,U><S,1*U(U,A)>m,
     Unfolding: InlineRule (3, True, False)
                (\ @ (n :: * -> *)
                   ($dFunctor :: GHC.Base.Functor n)
                   @ a
                   @ b
                   (eta :: a)
                   (eta1 :: TraversableInstances.S n b) ->
                 case eta1 of wild { TraversableInstances.S n1 a1 ->
                 TraversableInstances.S
                   @ n
                   @ a
                   (GHC.Base.fmap @ n $dFunctor @ b @ a (\ (ds :: b) -> eta) n1)
                   eta }) -}
830583bcd30f054061d98a8af9ec4905
  $fFunctorS_$cfmap ::
    GHC.Base.Functor n =>
    forall a b.
    (a -> b)
    -> TraversableInstances.S n a -> TraversableInstances.S n b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><L,U><S,1*U(U,U)>m,
     Unfolding: InlineRule (3, True, False)
                (\ @ (n :: * -> *)
                   ($dFunctor :: GHC.Base.Functor n)
                   @ a
                   @ b
                   (f :: a -> b)
                   (ds :: TraversableInstances.S n a) ->
                 case ds of wild { TraversableInstances.S n1 a1 ->
                 TraversableInstances.S
                   @ n
                   @ b
                   (GHC.Base.fmap @ n $dFunctor @ a @ b f n1)
                   (f a1) }) -}
721a5d38cc38fed0984ecc96f773ca01
  $fFunctorThree :: GHC.Base.Functor (TraversableInstances.Three a b)
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a @ b.
                  @ (TraversableInstances.Three a b)
                  (TraversableInstances.$fFunctorThree_$cfmap @ a @ b)
                  (TraversableInstances.$fFunctorThree_$c<$ @ a @ b) -}
721a5d38cc38fed0984ecc96f773ca01
  $fFunctorThree_$c<$ ::
    a1
    -> TraversableInstances.Three a b b1
    -> TraversableInstances.Three a b a1
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U(U,U,A)>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   @ b
                   @ a1
                   @ b1
                   (eta :: a1)
                   (ds :: TraversableInstances.Three a b b1) ->
                 case ds of wild { TraversableInstances.Three a2 b2 c ->
                 TraversableInstances.Three @ a @ b @ a1 a2 b2 eta }) -}
721a5d38cc38fed0984ecc96f773ca01
  $fFunctorThree_$cfmap ::
    (a1 -> b1)
    -> TraversableInstances.Three a b a1
    -> TraversableInstances.Three a b b1
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*C1(U)><S,1*U(U,U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   @ b
                   @ a1
                   @ b1
                   (f :: a1 -> b1)
                   (ds :: TraversableInstances.Three a b a1) ->
                 case ds of wild { TraversableInstances.Three a2 b2 c ->
                 TraversableInstances.Three @ a @ b @ b1 a2 b2 (f c) }) -}
4ba7eb63788e9e9f6786ec57a70a2853
  $fFunctorTree :: GHC.Base.Functor TraversableInstances.Tree
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ TraversableInstances.Tree
                  TraversableInstances.$fFunctorTree_$cfmap
                  TraversableInstances.$fFunctorTree_$c<$ -}
4ba7eb63788e9e9f6786ec57a70a2853
  $fFunctorTree_$c<$ ::
    a -> TraversableInstances.Tree b -> TraversableInstances.Tree a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (eta :: a) (eta1 :: TraversableInstances.Tree b) ->
                 TraversableInstances.$fFunctorTree_$cfmap
                   @ b
                   @ a
                   (\ (ds :: b) -> eta)
                   eta1) -}
4ba7eb63788e9e9f6786ec57a70a2853
  $fFunctorTree_$cfmap ::
    (a -> b)
    -> TraversableInstances.Tree a -> TraversableInstances.Tree b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U> -}
729de049f804209d218b6ac6412958e0
  $fOrdIdentity ::
    GHC.Classes.Ord a =>
    GHC.Classes.Ord (TraversableInstances.Identity a)
  DFunId
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(1*U(1*U,1*U),1*U,1*U,1*U,1*U,1*U,1*U,1*U)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dOrd :: GHC.Classes.Ord a).
                  @ (TraversableInstances.Identity a)
                  (TraversableInstances.$fOrdIdentity_$cp1Ord @ a $dOrd)
                  (TraversableInstances.$fOrdIdentity_$ccompare @ a $dOrd)
                  (TraversableInstances.$fOrdIdentity_$c< @ a $dOrd)
                  (TraversableInstances.$fOrdIdentity_$c<= @ a $dOrd)
                  (TraversableInstances.$fOrdIdentity_$c> @ a $dOrd)
                  (TraversableInstances.$fOrdIdentity_$c>= @ a $dOrd)
                  (TraversableInstances.$fOrdIdentity_$cmax @ a $dOrd)
                  (TraversableInstances.$fOrdIdentity_$cmin @ a $dOrd) -}
729de049f804209d218b6ac6412958e0
  $fOrdIdentity_$c< ::
    GHC.Classes.Ord a =>
    TraversableInstances.Identity a
    -> TraversableInstances.Identity a -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLSLLLLL),U(A,A,U,A,A,A,A,A)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Classes.<
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Classes.Ord a>_R
                 ->_R Sym (TraversableInstances.N:Identity[0] <a>_R)
                 ->_R Sym (TraversableInstances.N:Identity[0] <a>_R)
                 ->_R <GHC.Types.Bool>_R) -}
729de049f804209d218b6ac6412958e0
  $fOrdIdentity_$c<= ::
    GHC.Classes.Ord a =>
    TraversableInstances.Identity a
    -> TraversableInstances.Identity a -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLSLLLL),U(A,A,A,U,A,A,A,A)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Classes.<=
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Classes.Ord a>_R
                 ->_R Sym (TraversableInstances.N:Identity[0] <a>_R)
                 ->_R Sym (TraversableInstances.N:Identity[0] <a>_R)
                 ->_R <GHC.Types.Bool>_R) -}
729de049f804209d218b6ac6412958e0
  $fOrdIdentity_$c> ::
    GHC.Classes.Ord a =>
    TraversableInstances.Identity a
    -> TraversableInstances.Identity a -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLSLLL),U(A,A,A,A,U,A,A,A)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Classes.>
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Classes.Ord a>_R
                 ->_R Sym (TraversableInstances.N:Identity[0] <a>_R)
                 ->_R Sym (TraversableInstances.N:Identity[0] <a>_R)
                 ->_R <GHC.Types.Bool>_R) -}
729de049f804209d218b6ac6412958e0
  $fOrdIdentity_$c>= ::
    GHC.Classes.Ord a =>
    TraversableInstances.Identity a
    -> TraversableInstances.Identity a -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLLSLL),U(A,A,A,A,A,U,A,A)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Classes.>=
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Classes.Ord a>_R
                 ->_R Sym (TraversableInstances.N:Identity[0] <a>_R)
                 ->_R Sym (TraversableInstances.N:Identity[0] <a>_R)
                 ->_R <GHC.Types.Bool>_R) -}
729de049f804209d218b6ac6412958e0
  $fOrdIdentity_$ccompare ::
    GHC.Classes.Ord a =>
    TraversableInstances.Identity a
    -> TraversableInstances.Identity a -> GHC.Types.Ordering
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LSLLLLLL),U(A,U,A,A,A,A,A,A)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Classes.compare
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Classes.Ord a>_R
                 ->_R Sym (TraversableInstances.N:Identity[0] <a>_R)
                 ->_R Sym (TraversableInstances.N:Identity[0] <a>_R)
                 ->_R <GHC.Types.Ordering>_R) -}
729de049f804209d218b6ac6412958e0
  $fOrdIdentity_$cmax ::
    GHC.Classes.Ord a =>
    TraversableInstances.Identity a
    -> TraversableInstances.Identity a
    -> TraversableInstances.Identity a
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLLLSL),U(A,A,A,A,A,A,U,A)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Classes.max
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Classes.Ord a>_R
                 ->_R Sym (TraversableInstances.N:Identity[0] <a>_R)
                 ->_R Sym (TraversableInstances.N:Identity[0] <a>_R)
                 ->_R Sym (TraversableInstances.N:Identity[0] <a>_R)) -}
729de049f804209d218b6ac6412958e0
  $fOrdIdentity_$cmin ::
    GHC.Classes.Ord a =>
    TraversableInstances.Identity a
    -> TraversableInstances.Identity a
    -> TraversableInstances.Identity a
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLLLLS),U(A,A,A,A,A,A,A,U)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Classes.min
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Classes.Ord a>_R
                 ->_R Sym (TraversableInstances.N:Identity[0] <a>_R)
                 ->_R Sym (TraversableInstances.N:Identity[0] <a>_R)
                 ->_R Sym (TraversableInstances.N:Identity[0] <a>_R)) -}
729de049f804209d218b6ac6412958e0
  $fOrdIdentity_$cp1Ord ::
    GHC.Classes.Ord a =>
    GHC.Classes.Eq (TraversableInstances.Identity a)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,1*U(1*U(1*U,1*U),A,A,A,A,A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ a ($dOrd :: GHC.Classes.Ord a) ->
                 TraversableInstances.$fEqIdentity
                   @ a
                   (GHC.Classes.$p1Ord @ a $dOrd)) -}
cddb4f9513e650624772d2c687832791
  $fShowBig ::
    (GHC.Show.Show b, GHC.Show.Show a) =>
    GHC.Show.Show (TraversableInstances.Big a b)
  DFunId
  {- Arity: 2, Strictness: <L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a
                      @ b
                      ($dShow :: GHC.Show.Show b)
                      ($dShow1 :: GHC.Show.Show a).
                  @ (TraversableInstances.Big a b)
                  (TraversableInstances.$fShowBig_$cshowsPrec @ a @ b $dShow $dShow1)
                  (TraversableInstances.$fShowBig_$cshow @ a @ b $dShow $dShow1)
                  (TraversableInstances.$fShowBig_$cshowList
                     @ a
                     @ b
                     $dShow
                     $dShow1) -}
6a8f285090f21ceca331632577a14f9b
  $fShowBig1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Big "#) -}
2ba82b3c0a79a93c94f71dd434d70134
  $fShowBig2 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 11#) -}
cddb4f9513e650624772d2c687832791
  $fShowBig_$cshow ::
    (GHC.Show.Show b, GHC.Show.Show a) =>
    TraversableInstances.Big a b -> GHC.Base.String
  {- Arity: 3,
     Strictness: <L,U(C(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><S,1*U(U,U,U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ b
                   ($dShow :: GHC.Show.Show b)
                   ($dShow1 :: GHC.Show.Show a)
                   (x :: TraversableInstances.Big a b) ->
                 TraversableInstances.$fShowBig_$cshowsPrec
                   @ a
                   @ b
                   $dShow
                   $dShow1
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
cddb4f9513e650624772d2c687832791
  $fShowBig_$cshowList ::
    (GHC.Show.Show b, GHC.Show.Show a) =>
    [TraversableInstances.Big a b] -> GHC.Show.ShowS
  {- Arity: 4,
     Strictness: <L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   @ b
                   ($dShow :: GHC.Show.Show b)
                   ($dShow1 :: GHC.Show.Show a)
                   (eta :: [TraversableInstances.Big a b])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (TraversableInstances.Big a b)
                   (TraversableInstances.$fShowBig_$cshowsPrec
                      @ a
                      @ b
                      $dShow
                      $dShow1
                      TraversableInstances.$fFoldableConstant1)
                   eta
                   eta1) -}
cddb4f9513e650624772d2c687832791
  $fShowBig_$cshowsPrec ::
    (GHC.Show.Show b, GHC.Show.Show a) =>
    GHC.Types.Int -> TraversableInstances.Big a b -> GHC.Show.ShowS
  {- Arity: 4,
     Strictness: <L,U(C(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><S(S),1*U(U)><S,1*U(U,U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   @ b
                   (w :: GHC.Show.Show b)
                   (w1 :: GHC.Show.Show a)
                   (w2 :: GHC.Types.Int)
                   (w3 :: TraversableInstances.Big a b) ->
                 case w2 of ww { GHC.Types.I# ww1 ->
                 case w3 of ww2 { TraversableInstances.Big ww3 ww4 ww5 ->
                 TraversableInstances.$w$cshowsPrec
                   @ a
                   @ b
                   w
                   w1
                   ww1
                   ww3
                   ww4
                   ww5 } }) -}
8373cb9b5cc904797ff1fb1bafd8cdce
  $fShowBigger ::
    (GHC.Show.Show b, GHC.Show.Show a) =>
    GHC.Show.Show (TraversableInstances.Bigger a b)
  DFunId
  {- Arity: 2, Strictness: <L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a
                      @ b
                      ($dShow :: GHC.Show.Show b)
                      ($dShow1 :: GHC.Show.Show a).
                  @ (TraversableInstances.Bigger a b)
                  (TraversableInstances.$fShowBigger_$cshowsPrec
                     @ a
                     @ b
                     $dShow
                     $dShow1)
                  (TraversableInstances.$fShowBigger_$cshow @ a @ b $dShow $dShow1)
                  (TraversableInstances.$fShowBigger_$cshowList
                     @ a
                     @ b
                     $dShow
                     $dShow1) -}
1c86e7d25d6f2bfeb4cf55ba7ae521f6
  $fShowBigger1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Bigger "#) -}
8373cb9b5cc904797ff1fb1bafd8cdce
  $fShowBigger_$cshow ::
    (GHC.Show.Show b, GHC.Show.Show a) =>
    TraversableInstances.Bigger a b -> GHC.Base.String
  {- Arity: 3,
     Strictness: <L,U(C(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><S,1*U(U,U,U,U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ b
                   ($dShow :: GHC.Show.Show b)
                   ($dShow1 :: GHC.Show.Show a)
                   (x :: TraversableInstances.Bigger a b) ->
                 TraversableInstances.$fShowBigger_$cshowsPrec
                   @ a
                   @ b
                   $dShow
                   $dShow1
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
8373cb9b5cc904797ff1fb1bafd8cdce
  $fShowBigger_$cshowList ::
    (GHC.Show.Show b, GHC.Show.Show a) =>
    [TraversableInstances.Bigger a b] -> GHC.Show.ShowS
  {- Arity: 4,
     Strictness: <L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   @ b
                   ($dShow :: GHC.Show.Show b)
                   ($dShow1 :: GHC.Show.Show a)
                   (eta :: [TraversableInstances.Bigger a b])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (TraversableInstances.Bigger a b)
                   (TraversableInstances.$fShowBigger_$cshowsPrec
                      @ a
                      @ b
                      $dShow
                      $dShow1
                      TraversableInstances.$fFoldableConstant1)
                   eta
                   eta1) -}
8373cb9b5cc904797ff1fb1bafd8cdce
  $fShowBigger_$cshowsPrec ::
    (GHC.Show.Show b, GHC.Show.Show a) =>
    GHC.Types.Int -> TraversableInstances.Bigger a b -> GHC.Show.ShowS
  {- Arity: 4,
     Strictness: <L,U(C(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><S(S),1*U(U)><S,1*U(U,U,U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   @ b
                   (w :: GHC.Show.Show b)
                   (w1 :: GHC.Show.Show a)
                   (w2 :: GHC.Types.Int)
                   (w3 :: TraversableInstances.Bigger a b) ->
                 case w2 of ww { GHC.Types.I# ww1 ->
                 case w3 of ww2 { TraversableInstances.Bigger ww3 ww4 ww5 ww6 ->
                 TraversableInstances.$w$cshowsPrec1
                   @ a
                   @ b
                   w
                   w1
                   ww1
                   ww3
                   ww4
                   ww5
                   ww6 } }) -}
a06a627f62d93f6fedbee61792bf9f78
  $fShowConstant ::
    GHC.Show.Show a =>
    GHC.Show.Show (TraversableInstances.Constant a b)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a @ b ($dShow :: GHC.Show.Show a).
                  @ (TraversableInstances.Constant a b)
                  (TraversableInstances.$fShowConstant_$cshowsPrec @ a @ b $dShow)
                  (TraversableInstances.$fShowConstant_$cshow @ a @ b $dShow)
                  (TraversableInstances.$fShowConstant_$cshowList @ a @ b $dShow) -}
32bdf33975634957d5507f76bf9643b8
  $fShowConstant1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "}"#) -}
56604a791d70bbc670bf8c601255ae91
  $fShowConstant2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "getConstant = "#) -}
0498d5d078f76de1d63892d2084f6688
  $fShowConstant3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Constant {"#) -}
72119ba14924dcc00ec6cc22b107241f
  $fShowConstant4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.Base.++
                   @ GHC.Types.Char
                   TraversableInstances.$fShowConstant1
                   (GHC.Types.[] @ GHC.Types.Char)) -}
a06a627f62d93f6fedbee61792bf9f78
  $fShowConstant_$cshow ::
    GHC.Show.Show a =>
    TraversableInstances.Constant a b -> GHC.Base.String
  {- Arity: 2, Strictness: <L,1*U(1*C1(C1(C1(U))),A,A)><L,U>,
     Unfolding: (\ @ a
                   @ b
                   ($dShow :: GHC.Show.Show a)
                   (x :: TraversableInstances.Constant a b) ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   TraversableInstances.$fShowConstant3
                   (GHC.Base.++
                      @ GHC.Types.Char
                      TraversableInstances.$fShowConstant2
                      (GHC.Show.showsPrec
                         @ a
                         $dShow
                         TraversableInstances.$fFoldableConstant1
                         x `cast` (TraversableInstances.N:Constant[0] <a>_R <b>_P)
                         TraversableInstances.$fShowConstant4))) -}
a06a627f62d93f6fedbee61792bf9f78
  $fShowConstant_$cshowList ::
    GHC.Show.Show a =>
    [TraversableInstances.Constant a b] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ b
                   ($dShow :: GHC.Show.Show a)
                   (eta :: [TraversableInstances.Constant a b])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (TraversableInstances.Constant a b)
                   (TraversableInstances.$fShowConstant_$cshowsPrec
                      @ a
                      @ b
                      $dShow
                      TraversableInstances.$fFoldableConstant1)
                   eta
                   eta1) -}
a06a627f62d93f6fedbee61792bf9f78
  $fShowConstant_$cshowsPrec ::
    GHC.Show.Show a =>
    GHC.Types.Int
    -> TraversableInstances.Constant a b -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,1*U(1*C1(C1(U)),A,A)><S(S),1*U(U)><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ b
                   (w :: GHC.Show.Show a)
                   (w1 :: GHC.Types.Int)
                   (w2 :: TraversableInstances.Constant a b) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 TraversableInstances.$w$cshowsPrec2 @ a @ b w ww1 w2 }) -}
729de049f804209d218b6ac6412958e0
  $fShowIdentity ::
    GHC.Show.Show a => GHC.Show.Show (TraversableInstances.Identity a)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dShow :: GHC.Show.Show a).
                  @ (TraversableInstances.Identity a)
                  (TraversableInstances.$fShowIdentity_$cshowsPrec @ a $dShow)
                  (TraversableInstances.$fShowIdentity_$cshow @ a $dShow)
                  (TraversableInstances.$fShowIdentity_$cshowList @ a $dShow) -}
a07320197a5bc80ddac415a8f3f6e5b1
  $fShowIdentity1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Identity "#) -}
729de049f804209d218b6ac6412958e0
  $fShowIdentity_$cshow ::
    GHC.Show.Show a =>
    TraversableInstances.Identity a -> GHC.Base.String
  {- Arity: 2, Strictness: <L,1*U(1*C1(C1(C1(U))),A,A)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (x :: TraversableInstances.Identity a) ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b
                      (c :: GHC.Types.Char -> b -> b)[OneShot]
                      (n :: b)[OneShot] ->
                    GHC.Base.foldr
                      @ GHC.Types.Char
                      @ b
                      c
                      n
                      TraversableInstances.$fShowIdentity1)
                   (GHC.Show.showsPrec
                      @ a
                      $dShow
                      TraversableInstances.$fShowBig2
                      x `cast` (TraversableInstances.N:Identity[0] <a>_R)
                      (GHC.Types.[] @ GHC.Types.Char))) -}
729de049f804209d218b6ac6412958e0
  $fShowIdentity_$cshowList ::
    GHC.Show.Show a =>
    [TraversableInstances.Identity a] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (eta :: [TraversableInstances.Identity a])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (TraversableInstances.Identity a)
                   (TraversableInstances.$fShowIdentity_$cshowsPrec
                      @ a
                      $dShow
                      TraversableInstances.$fFoldableConstant1)
                   eta
                   eta1) -}
729de049f804209d218b6ac6412958e0
  $fShowIdentity_$cshowsPrec ::
    GHC.Show.Show a =>
    GHC.Types.Int -> TraversableInstances.Identity a -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,1*U(1*C1(C1(U)),A,A)><S(S),1*U(U)><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (w :: GHC.Show.Show a)
                   (w1 :: GHC.Types.Int)
                   (w2 :: TraversableInstances.Identity a) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 TraversableInstances.$w$cshowsPrec3 @ a w ww1 w2 }) -}
b205c9375ec1b24a907de4864e47820f
  $fShowList ::
    GHC.Show.Show a => GHC.Show.Show (TraversableInstances.List a)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dShow :: GHC.Show.Show a).
                  @ (TraversableInstances.List a)
                  (TraversableInstances.$fShowList_$cshowsPrec @ a $dShow)
                  (TraversableInstances.$fShowList_$cshow @ a $dShow)
                  (TraversableInstances.$fShowList_$cshowList @ a $dShow) -}
b205c9375ec1b24a907de4864e47820f
  $fShowList_$cshow ::
    GHC.Show.Show a => TraversableInstances.List a -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(C(C1(U)),A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (x :: TraversableInstances.List a) ->
                 TraversableInstances.$fShowList_$cshowsPrec
                   @ a
                   $dShow
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
b205c9375ec1b24a907de4864e47820f
  $fShowList_$cshowList ::
    GHC.Show.Show a => [TraversableInstances.List a] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (eta :: [TraversableInstances.List a])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (TraversableInstances.List a)
                   (TraversableInstances.$fShowList_$cshowsPrec
                      @ a
                      $dShow
                      TraversableInstances.$fFoldableConstant1)
                   eta
                   eta1) -}
b205c9375ec1b24a907de4864e47820f
  $fShowList_$cshowsPrec ::
    GHC.Show.Show a =>
    GHC.Types.Int -> TraversableInstances.List a -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><L,1*U(U)><S,1*U> -}
9b0dc1c42b799f2c204b6c11f0bab139
  $fShowOptional ::
    GHC.Show.Show a => GHC.Show.Show (TraversableInstances.Optional a)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dShow :: GHC.Show.Show a).
                  @ (TraversableInstances.Optional a)
                  (TraversableInstances.$fShowOptional_$cshowsPrec @ a $dShow)
                  (TraversableInstances.$fShowOptional_$cshow @ a $dShow)
                  (TraversableInstances.$fShowOptional_$cshowList @ a $dShow) -}
886813dfda1d8a64ca7691f95a096347
  $fShowOptional1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Yep "#) -}
ca26ee1f5cf2386c94447ecb1103e83d
  $fShowOptional2 :: GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (GHC.Base.++
                   @ GHC.Types.Char
                   TraversableInstances.$fShowOptional3) -}
bcf2ba0f3e40e6711a17fd11088dd1df
  $fShowOptional3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Nada"#) -}
9b0dc1c42b799f2c204b6c11f0bab139
  $fShowOptional_$cshow ::
    GHC.Show.Show a =>
    TraversableInstances.Optional a -> GHC.Base.String
  {- Arity: 2, Strictness: <L,1*U(1*C1(C1(C1(U))),A,A)><S,1*U>,
     Unfolding: (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (x :: TraversableInstances.Optional a) ->
                 case x of wild {
                   TraversableInstances.Nada -> TraversableInstances.$fShowOptional3
                   TraversableInstances.Yep b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        TraversableInstances.$fShowOptional1
                        (GHC.Show.showsPrec
                           @ a
                           $dShow
                           TraversableInstances.$fShowBig2
                           b1
                           (GHC.Types.[] @ GHC.Types.Char)) }) -}
9b0dc1c42b799f2c204b6c11f0bab139
  $fShowOptional_$cshowList ::
    GHC.Show.Show a =>
    [TraversableInstances.Optional a] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (eta :: [TraversableInstances.Optional a])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (TraversableInstances.Optional a)
                   (TraversableInstances.$fShowOptional_$cshowsPrec
                      @ a
                      $dShow
                      TraversableInstances.$fFoldableConstant1)
                   eta
                   eta1) -}
9b0dc1c42b799f2c204b6c11f0bab139
  $fShowOptional_$cshowsPrec ::
    GHC.Show.Show a =>
    GHC.Types.Int -> TraversableInstances.Optional a -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(1*C1(C1(U)),A,A)><L,1*U(U)><S,1*U>,
     Unfolding: (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (ds :: GHC.Types.Int)
                   (ds1 :: TraversableInstances.Optional a) ->
                 case ds1 of wild {
                   TraversableInstances.Nada -> TraversableInstances.$fShowOptional2
                   TraversableInstances.Yep b1
                   -> case ds of wild1 { GHC.Types.I# x ->
                      let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec @ a $dShow TraversableInstances.$fShowBig2 b1
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11#) of wild2 {
                        GHC.Types.False
                        -> \ (x1 :: GHC.Base.String) ->
                           GHC.Base.++
                             @ GHC.Types.Char
                             TraversableInstances.$fShowOptional1
                             (g x1)
                        GHC.Types.True
                        -> \ (x1 :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows7
                             (GHC.Base.++
                                @ GHC.Types.Char
                                TraversableInstances.$fShowOptional1
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows4 x1))) } } }) -}
96406d61d01da17b40bba6954858f9d9
  $fShowPair ::
    (GHC.Show.Show b, GHC.Show.Show a) =>
    GHC.Show.Show (TraversableInstances.Pair a b)
  DFunId
  {- Arity: 2, Strictness: <L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a
                      @ b
                      ($dShow :: GHC.Show.Show b)
                      ($dShow1 :: GHC.Show.Show a).
                  @ (TraversableInstances.Pair a b)
                  (TraversableInstances.$fShowPair_$cshowsPrec
                     @ a
                     @ b
                     $dShow
                     $dShow1)
                  (TraversableInstances.$fShowPair_$cshow @ a @ b $dShow $dShow1)
                  (TraversableInstances.$fShowPair_$cshowList
                     @ a
                     @ b
                     $dShow
                     $dShow1) -}
9ce373be2ec175b3a4d9d72b05e9229a
  $fShowPair1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Pair "#) -}
96406d61d01da17b40bba6954858f9d9
  $fShowPair_$cshow ::
    (GHC.Show.Show b, GHC.Show.Show a) =>
    TraversableInstances.Pair a b -> GHC.Base.String
  {- Arity: 3,
     Strictness: <L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><S,1*U(U,U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ b
                   ($dShow :: GHC.Show.Show b)
                   ($dShow1 :: GHC.Show.Show a)
                   (x :: TraversableInstances.Pair a b) ->
                 TraversableInstances.$fShowPair_$cshowsPrec
                   @ a
                   @ b
                   $dShow
                   $dShow1
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
96406d61d01da17b40bba6954858f9d9
  $fShowPair_$cshowList ::
    (GHC.Show.Show b, GHC.Show.Show a) =>
    [TraversableInstances.Pair a b] -> GHC.Show.ShowS
  {- Arity: 4,
     Strictness: <L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   @ b
                   ($dShow :: GHC.Show.Show b)
                   ($dShow1 :: GHC.Show.Show a)
                   (eta :: [TraversableInstances.Pair a b])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (TraversableInstances.Pair a b)
                   (TraversableInstances.$fShowPair_$cshowsPrec
                      @ a
                      @ b
                      $dShow
                      $dShow1
                      TraversableInstances.$fFoldableConstant1)
                   eta
                   eta1) -}
96406d61d01da17b40bba6954858f9d9
  $fShowPair_$cshowsPrec ::
    (GHC.Show.Show b, GHC.Show.Show a) =>
    GHC.Types.Int -> TraversableInstances.Pair a b -> GHC.Show.ShowS
  {- Arity: 4,
     Strictness: <L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><S(S),1*U(U)><S,1*U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   @ b
                   (w :: GHC.Show.Show b)
                   (w1 :: GHC.Show.Show a)
                   (w2 :: GHC.Types.Int)
                   (w3 :: TraversableInstances.Pair a b) ->
                 case w2 of ww { GHC.Types.I# ww1 ->
                 case w3 of ww2 { TraversableInstances.Pair ww3 ww4 ->
                 TraversableInstances.$w$cshowsPrec4
                   @ a
                   @ b
                   w
                   w1
                   ww1
                   ww3
                   ww4 } }) -}
830583bcd30f054061d98a8af9ec4905
  $fShowS ::
    (GHC.Show.Show (n a), GHC.Show.Show a) =>
    GHC.Show.Show (TraversableInstances.S n a)
  DFunId
  {- Arity: 2, Strictness: <L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ (n :: * -> *)
                      @ a
                      ($dShow :: GHC.Show.Show (n a))
                      ($dShow1 :: GHC.Show.Show a).
                  @ (TraversableInstances.S n a)
                  (TraversableInstances.$fShowS_$cshowsPrec @ n @ a $dShow $dShow1)
                  (TraversableInstances.$fShowS_$cshow @ n @ a $dShow $dShow1)
                  (TraversableInstances.$fShowS_$cshowList @ n @ a $dShow $dShow1) -}
803a4159179cefa5607b58d868fc47d7
  $fShowS1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "S "#) -}
830583bcd30f054061d98a8af9ec4905
  $fShowS_$cshow ::
    (GHC.Show.Show (n a), GHC.Show.Show a) =>
    TraversableInstances.S n a -> GHC.Base.String
  {- Arity: 3,
     Strictness: <L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><S,1*U(U,U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ (n :: * -> *)
                   @ a
                   ($dShow :: GHC.Show.Show (n a))
                   ($dShow1 :: GHC.Show.Show a)
                   (x :: TraversableInstances.S n a) ->
                 TraversableInstances.$fShowS_$cshowsPrec
                   @ n
                   @ a
                   $dShow
                   $dShow1
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
830583bcd30f054061d98a8af9ec4905
  $fShowS_$cshowList ::
    (GHC.Show.Show (n a), GHC.Show.Show a) =>
    [TraversableInstances.S n a] -> GHC.Show.ShowS
  {- Arity: 4,
     Strictness: <L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ (n :: * -> *)
                   @ a
                   ($dShow :: GHC.Show.Show (n a))
                   ($dShow1 :: GHC.Show.Show a)
                   (eta :: [TraversableInstances.S n a])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (TraversableInstances.S n a)
                   (TraversableInstances.$fShowS_$cshowsPrec
                      @ n
                      @ a
                      $dShow
                      $dShow1
                      TraversableInstances.$fFoldableConstant1)
                   eta
                   eta1) -}
830583bcd30f054061d98a8af9ec4905
  $fShowS_$cshowsPrec ::
    (GHC.Show.Show (n a), GHC.Show.Show a) =>
    GHC.Types.Int -> TraversableInstances.S n a -> GHC.Show.ShowS
  {- Arity: 4,
     Strictness: <L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><S(S),1*U(U)><S,1*U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ @ (n :: * -> *)
                   @ a
                   (w :: GHC.Show.Show (n a))
                   (w1 :: GHC.Show.Show a)
                   (w2 :: GHC.Types.Int)
                   (w3 :: TraversableInstances.S n a) ->
                 case w2 of ww { GHC.Types.I# ww1 ->
                 case w3 of ww2 { TraversableInstances.S ww3 ww4 ->
                 TraversableInstances.$w$cshowsPrec5
                   @ n
                   @ a
                   w
                   w1
                   ww1
                   ww3
                   ww4 } }) -}
721a5d38cc38fed0984ecc96f773ca01
  $fShowThree ::
    (GHC.Show.Show c, GHC.Show.Show b, GHC.Show.Show a) =>
    GHC.Show.Show (TraversableInstances.Three a b c)
  DFunId
  {- Arity: 3,
     Strictness: <L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a
                      @ b
                      @ c
                      ($dShow :: GHC.Show.Show c)
                      ($dShow1 :: GHC.Show.Show b)
                      ($dShow2 :: GHC.Show.Show a).
                  @ (TraversableInstances.Three a b c)
                  (TraversableInstances.$fShowThree_$cshowsPrec
                     @ a
                     @ b
                     @ c
                     $dShow
                     $dShow1
                     $dShow2)
                  (TraversableInstances.$fShowThree_$cshow
                     @ a
                     @ b
                     @ c
                     $dShow
                     $dShow1
                     $dShow2)
                  (TraversableInstances.$fShowThree_$cshowList
                     @ a
                     @ b
                     @ c
                     $dShow
                     $dShow1
                     $dShow2) -}
9c81d04439f2a7f9de334ac832e34050
  $fShowThree1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Three "#) -}
721a5d38cc38fed0984ecc96f773ca01
  $fShowThree_$cshow ::
    (GHC.Show.Show c, GHC.Show.Show b, GHC.Show.Show a) =>
    TraversableInstances.Three a b c -> GHC.Base.String
  {- Arity: 4,
     Strictness: <L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><S,1*U(U,U,U)>,
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   @ b
                   @ c
                   ($dShow :: GHC.Show.Show c)
                   ($dShow1 :: GHC.Show.Show b)
                   ($dShow2 :: GHC.Show.Show a)
                   (x :: TraversableInstances.Three a b c) ->
                 TraversableInstances.$fShowThree_$cshowsPrec
                   @ a
                   @ b
                   @ c
                   $dShow
                   $dShow1
                   $dShow2
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
721a5d38cc38fed0984ecc96f773ca01
  $fShowThree_$cshowList ::
    (GHC.Show.Show c, GHC.Show.Show b, GHC.Show.Show a) =>
    [TraversableInstances.Three a b c] -> GHC.Show.ShowS
  {- Arity: 5,
     Strictness: <L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (5, True, False)
                (\ @ a
                   @ b
                   @ c
                   ($dShow :: GHC.Show.Show c)
                   ($dShow1 :: GHC.Show.Show b)
                   ($dShow2 :: GHC.Show.Show a)
                   (eta :: [TraversableInstances.Three a b c])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (TraversableInstances.Three a b c)
                   (TraversableInstances.$fShowThree_$cshowsPrec
                      @ a
                      @ b
                      @ c
                      $dShow
                      $dShow1
                      $dShow2
                      TraversableInstances.$fFoldableConstant1)
                   eta
                   eta1) -}
721a5d38cc38fed0984ecc96f773ca01
  $fShowThree_$cshowsPrec ::
    (GHC.Show.Show c, GHC.Show.Show b, GHC.Show.Show a) =>
    GHC.Types.Int -> TraversableInstances.Three a b c -> GHC.Show.ShowS
  {- Arity: 5,
     Strictness: <L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><S(S),1*U(U)><S,1*U(U,U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (5, True, False)
                (\ @ a
                   @ b
                   @ c
                   (w :: GHC.Show.Show c)
                   (w1 :: GHC.Show.Show b)
                   (w2 :: GHC.Show.Show a)
                   (w3 :: GHC.Types.Int)
                   (w4 :: TraversableInstances.Three a b c) ->
                 case w3 of ww { GHC.Types.I# ww1 ->
                 case w4 of ww2 { TraversableInstances.Three ww3 ww4 ww5 ->
                 TraversableInstances.$w$cshowsPrec6
                   @ a
                   @ b
                   @ c
                   w
                   w1
                   w2
                   ww1
                   ww3
                   ww4
                   ww5 } }) -}
4ba7eb63788e9e9f6786ec57a70a2853
  $fShowTree ::
    GHC.Show.Show a => GHC.Show.Show (TraversableInstances.Tree a)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dShow :: GHC.Show.Show a).
                  @ (TraversableInstances.Tree a)
                  (TraversableInstances.$fShowTree_$cshowsPrec @ a $dShow)
                  (TraversableInstances.$fShowTree_$cshow @ a $dShow)
                  (TraversableInstances.$fShowTree_$cshowList @ a $dShow) -}
4ba7eb63788e9e9f6786ec57a70a2853
  $fShowTree_$cshow ::
    GHC.Show.Show a => TraversableInstances.Tree a -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(C(C1(U)),A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (x :: TraversableInstances.Tree a) ->
                 TraversableInstances.$fShowTree_$cshowsPrec
                   @ a
                   $dShow
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
4ba7eb63788e9e9f6786ec57a70a2853
  $fShowTree_$cshowList ::
    GHC.Show.Show a => [TraversableInstances.Tree a] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (eta :: [TraversableInstances.Tree a])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (TraversableInstances.Tree a)
                   (TraversableInstances.$fShowTree_$cshowsPrec
                      @ a
                      $dShow
                      TraversableInstances.$fFoldableConstant1)
                   eta
                   eta1) -}
4ba7eb63788e9e9f6786ec57a70a2853
  $fShowTree_$cshowsPrec ::
    GHC.Show.Show a =>
    GHC.Types.Int -> TraversableInstances.Tree a -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><L,1*U(U)><S,1*U> -}
cddb4f9513e650624772d2c687832791
  $fTraversableBig ::
    Data.Traversable.Traversable (TraversableInstances.Big a)
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a.
                  @ (TraversableInstances.Big a)
                  (TraversableInstances.$fFunctorBig @ a)
                  (TraversableInstances.$fFoldableBig @ a)
                  (TraversableInstances.$fTraversableBig_$ctraverse @ a)
                  (TraversableInstances.$fTraversableBig_$csequenceA @ a)
                  (TraversableInstances.$fTraversableBig_$cmapM @ a)
                  (TraversableInstances.$fTraversableBig_$csequence @ a) -}
cddb4f9513e650624772d2c687832791
  $fTraversableBig_$cmapM ::
    GHC.Base.Monad m =>
    (a1 -> m b)
    -> TraversableInstances.Big a a1
    -> m (TraversableInstances.Big a b)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(S(LLC(C(S))LL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,1*C1(C1(U)),A,A),A,A,A,A)><L,C(U)><S,1*U(U,U,U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ (m :: * -> *)
                   @ a1
                   @ b
                   ($dMonad :: GHC.Base.Monad m)
                   (eta :: a1 -> m b)
                   (eta1 :: TraversableInstances.Big a a1) ->
                 TraversableInstances.$fTraversableBig_$ctraverse
                   @ a
                   @ m
                   @ a1
                   @ b
                   (GHC.Base.$p1Monad @ m $dMonad)
                   eta
                   eta1) -}
cddb4f9513e650624772d2c687832791
  $fTraversableBig_$csequence ::
    GHC.Base.Monad m =>
    TraversableInstances.Big a (m a1)
    -> m (TraversableInstances.Big a a1)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(LLC(C(S))LL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,1*C1(C1(U)),A,A),A,A,A,A)><S,1*U(U,U,U)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   @ (m :: * -> *)
                   @ a1
                   ($dMonad :: GHC.Base.Monad m)
                   (eta :: TraversableInstances.Big a (m a1)) ->
                 TraversableInstances.$fTraversableBig_$csequenceA
                   @ a
                   @ m
                   @ a1
                   (GHC.Base.$p1Monad @ m $dMonad)
                   eta) -}
cddb4f9513e650624772d2c687832791
  $fTraversableBig_$csequenceA ::
    GHC.Base.Applicative f =>
    TraversableInstances.Big a (f a1)
    -> f (TraversableInstances.Big a a1)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LLC(C(S))LL),U(1*U(1*C1(C1(U)),A),A,1*C1(C1(U)),A,A)><S,1*U(U,U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   @ (f :: * -> *)
                   @ a1
                   (w :: GHC.Base.Applicative f)
                   (w1 :: TraversableInstances.Big a (f a1)) ->
                 case w1 of ww { TraversableInstances.Big ww1 ww2 ww3 ->
                 TraversableInstances.$w$csequenceA @ a @ f @ a1 w ww1 ww2 ww3 }) -}
cddb4f9513e650624772d2c687832791
  $fTraversableBig_$ctraverse ::
    GHC.Base.Applicative f =>
    (a1 -> f b)
    -> TraversableInstances.Big a a1
    -> f (TraversableInstances.Big a b)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LLC(C(S))LL),U(1*U(1*C1(C1(U)),A),A,1*C1(C1(U)),A,A)><L,C(U)><S,1*U(U,U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ (f :: * -> *)
                   @ a1
                   @ b
                   (w :: GHC.Base.Applicative f)
                   (w1 :: a1 -> f b)
                   (w2 :: TraversableInstances.Big a a1) ->
                 case w2 of ww { TraversableInstances.Big ww1 ww2 ww3 ->
                 TraversableInstances.$w$ctraverse
                   @ a
                   @ f
                   @ a1
                   @ b
                   w
                   w1
                   ww1
                   ww2
                   ww3 }) -}
8373cb9b5cc904797ff1fb1bafd8cdce
  $fTraversableBigger ::
    Data.Traversable.Traversable (TraversableInstances.Bigger a)
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a.
                  @ (TraversableInstances.Bigger a)
                  (TraversableInstances.$fFunctorBigger @ a)
                  (TraversableInstances.$fFoldableBigger @ a)
                  (TraversableInstances.$fTraversableBigger_$ctraverse @ a)
                  (TraversableInstances.$fTraversableBigger_$csequenceA @ a)
                  (TraversableInstances.$fTraversableBigger_$cmapM @ a)
                  (TraversableInstances.$fTraversableBigger_$csequence @ a) -}
8373cb9b5cc904797ff1fb1bafd8cdce
  $fTraversableBigger_$cmapM ::
    GHC.Base.Monad m =>
    (a1 -> m b)
    -> TraversableInstances.Bigger a a1
    -> m (TraversableInstances.Bigger a b)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(S(LLC(C(S))LL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,C(C1(U)),A,A),A,A,A,A)><L,C(U)><S,1*U(U,U,U,U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ (m :: * -> *)
                   @ a1
                   @ b
                   ($dMonad :: GHC.Base.Monad m)
                   (eta :: a1 -> m b)
                   (eta1 :: TraversableInstances.Bigger a a1) ->
                 TraversableInstances.$fTraversableBigger_$ctraverse
                   @ a
                   @ m
                   @ a1
                   @ b
                   (GHC.Base.$p1Monad @ m $dMonad)
                   eta
                   eta1) -}
8373cb9b5cc904797ff1fb1bafd8cdce
  $fTraversableBigger_$csequence ::
    GHC.Base.Monad m =>
    TraversableInstances.Bigger a (m a1)
    -> m (TraversableInstances.Bigger a a1)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(LLC(C(S))LL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,C(C1(U)),A,A),A,A,A,A)><S,1*U(U,U,U,U)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   @ (m :: * -> *)
                   @ a1
                   ($dMonad :: GHC.Base.Monad m)
                   (eta :: TraversableInstances.Bigger a (m a1)) ->
                 TraversableInstances.$fTraversableBigger_$ctraverse
                   @ a
                   @ m
                   @ (m a1)
                   @ a1
                   (GHC.Base.$p1Monad @ m $dMonad)
                   (GHC.Base.id @ (m a1))
                   eta) -}
8373cb9b5cc904797ff1fb1bafd8cdce
  $fTraversableBigger_$csequenceA ::
    GHC.Base.Applicative f =>
    TraversableInstances.Bigger a (f a1)
    -> f (TraversableInstances.Bigger a a1)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),A),A,C(C1(U)),A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a
                   @ (f :: * -> *)
                   @ a1
                   ($dApplicative :: GHC.Base.Applicative f)
                   (eta :: TraversableInstances.Bigger a (f a1)) ->
                 TraversableInstances.$fTraversableBigger_$ctraverse
                   @ a
                   @ f
                   @ (f a1)
                   @ a1
                   $dApplicative
                   (GHC.Base.id @ (f a1))
                   eta) -}
8373cb9b5cc904797ff1fb1bafd8cdce
  $fTraversableBigger_$ctraverse ::
    GHC.Base.Applicative f =>
    (a1 -> f b)
    -> TraversableInstances.Bigger a a1
    -> f (TraversableInstances.Bigger a b)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LLC(C(S))LL),U(1*U(1*C1(C1(U)),A),A,C(C1(U)),A,A)><L,C(U)><S,1*U(U,U,U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ (f :: * -> *)
                   @ a1
                   @ b
                   (w :: GHC.Base.Applicative f)
                   (w1 :: a1 -> f b)
                   (w2 :: TraversableInstances.Bigger a a1) ->
                 case w2 of ww { TraversableInstances.Bigger ww1 ww2 ww3 ww4 ->
                 TraversableInstances.$w$ctraverse1
                   @ a
                   @ f
                   @ a1
                   @ b
                   w
                   w1
                   ww1
                   ww2
                   ww3
                   ww4 }) -}
a06a627f62d93f6fedbee61792bf9f78
  $fTraversableConstant ::
    Data.Traversable.Traversable (TraversableInstances.Constant a)
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a.
                  @ (TraversableInstances.Constant a)
                  (TraversableInstances.$fFunctorConstant @ a)
                  (TraversableInstances.$fFoldableConstant @ a)
                  (TraversableInstances.$fTraversableConstant_$ctraverse @ a)
                  (TraversableInstances.$fTraversableConstant_$csequenceA @ a)
                  (TraversableInstances.$fTraversableConstant_$cmapM @ a)
                  (TraversableInstances.$fTraversableConstant_$csequence @ a) -}
a06a627f62d93f6fedbee61792bf9f78
  $fTraversableConstant_$cmapM ::
    GHC.Base.Monad m =>
    (a1 -> m b)
    -> TraversableInstances.Constant a a1
    -> m (TraversableInstances.Constant a b)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(S(LC(S)LLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A),A,A,A,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ (m :: * -> *)
                   @ a1
                   @ b
                   ($dMonad :: GHC.Base.Monad m)
                   (eta :: a1 -> m b)
                   (eta1 :: TraversableInstances.Constant a a1) ->
                 GHC.Base.pure
                   @ m
                   (GHC.Base.$p1Monad @ m $dMonad)
                   @ (TraversableInstances.Constant a b)
                   eta1
                     `cast`
                   (Trans
                        (TraversableInstances.N:Constant[0] <a>_R <a1>_P)
                        (Sym (TraversableInstances.N:Constant[0] <a>_R <b>_P)))) -}
a06a627f62d93f6fedbee61792bf9f78
  $fTraversableConstant_$csequence ::
    GHC.Base.Monad m =>
    TraversableInstances.Constant a (m a1)
    -> m (TraversableInstances.Constant a a1)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(LC(S)LLL)LLLL),1*U(1*U(A,1*C1(U),A,A,A),A,A,A,A)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   @ (m :: * -> *)
                   @ a1
                   ($dMonad :: GHC.Base.Monad m)
                   (eta :: TraversableInstances.Constant a (m a1)) ->
                 GHC.Base.pure
                   @ m
                   (GHC.Base.$p1Monad @ m $dMonad)
                   @ (TraversableInstances.Constant a a1)
                   eta
                     `cast`
                   (Trans
                        (TraversableInstances.N:Constant[0] <a>_R <m a1>_P)
                        (Sym (TraversableInstances.N:Constant[0] <a>_R <a1>_P)))) -}
a06a627f62d93f6fedbee61792bf9f78
  $fTraversableConstant_$csequenceA ::
    GHC.Base.Applicative f =>
    TraversableInstances.Constant a (f a1)
    -> f (TraversableInstances.Constant a a1)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LC(S)LLL),1*U(A,1*C1(U),A,A,A)><L,U>,
     Unfolding: InlineRule (2, True, True)
                (\ @ a
                   @ (f :: * -> *)
                   @ a1
                   ($dApplicative :: GHC.Base.Applicative f)
                   (ds :: TraversableInstances.Constant a (f a1)) ->
                 GHC.Base.pure
                   @ f
                   $dApplicative
                   @ (TraversableInstances.Constant a a1)
                   ds
                     `cast`
                   (Trans
                        (TraversableInstances.N:Constant[0] <a>_R <f a1>_P)
                        (Sym (TraversableInstances.N:Constant[0] <a>_R <a1>_P)))) -}
a06a627f62d93f6fedbee61792bf9f78
  $fTraversableConstant_$ctraverse ::
    GHC.Base.Applicative f =>
    (a1 -> f b)
    -> TraversableInstances.Constant a a1
    -> f (TraversableInstances.Constant a b)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LC(S)LLL),1*U(A,1*C1(U),A,A,A)><L,A><L,U>,
     Unfolding: InlineRule (3, True, True)
                (\ @ a
                   @ (f :: * -> *)
                   @ a1
                   @ b
                   ($dApplicative :: GHC.Base.Applicative f)
                   (ds :: a1 -> f b)
                   (ds1 :: TraversableInstances.Constant a a1) ->
                 GHC.Base.pure
                   @ f
                   $dApplicative
                   @ (TraversableInstances.Constant a b)
                   ds1
                     `cast`
                   (Trans
                        (TraversableInstances.N:Constant[0] <a>_R <a1>_P)
                        (Sym (TraversableInstances.N:Constant[0] <a>_R <b>_P)))) -}
729de049f804209d218b6ac6412958e0
  $fTraversableIdentity ::
    Data.Traversable.Traversable TraversableInstances.Identity
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ TraversableInstances.Identity
                  TraversableInstances.$fFunctorIdentity
                  TraversableInstances.$fFoldableIdentity
                  TraversableInstances.$fTraversableIdentity_$ctraverse
                  TraversableInstances.$fTraversableIdentity_$csequenceA
                  TraversableInstances.$fTraversableIdentity_$cmapM
                  TraversableInstances.$fTraversableIdentity_$csequence -}
729de049f804209d218b6ac6412958e0
  $fTraversableIdentity_$cmapM ::
    GHC.Base.Monad m =>
    (a -> m b)
    -> TraversableInstances.Identity a
    -> m (TraversableInstances.Identity b)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(S(S(C(C(S))L)LLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A),A,A,A,A)><L,1*C1(U)><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ (m :: * -> *)
                   @ a
                   @ b
                   ($dMonad :: GHC.Base.Monad m)
                   (eta :: a -> m b)
                   (eta1 :: TraversableInstances.Identity a) ->
                 GHC.Base.fmap
                   @ m
                   (GHC.Base.$p1Applicative @ m (GHC.Base.$p1Monad @ m $dMonad))
                   @ b
                   @ (TraversableInstances.Identity b)
                   (TraversableInstances.$fFoldableS1 @ b)
                     `cast`
                   (<b>_R ->_R Sym (TraversableInstances.N:Identity[0] <b>_R))
                   (eta eta1 `cast` (TraversableInstances.N:Identity[0] <a>_R))) -}
729de049f804209d218b6ac6412958e0
  $fTraversableIdentity_$csequence ::
    GHC.Base.Monad m =>
    TraversableInstances.Identity (m a)
    -> m (TraversableInstances.Identity a)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S(C(C(S))L)LLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A),A,A,A,A)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ (m :: * -> *)
                   @ a
                   ($dMonad :: GHC.Base.Monad m)
                   (eta :: TraversableInstances.Identity (m a)) ->
                 GHC.Base.fmap
                   @ m
                   (GHC.Base.$p1Applicative @ m (GHC.Base.$p1Monad @ m $dMonad))
                   @ a
                   @ (TraversableInstances.Identity a)
                   (TraversableInstances.$fFoldableS1 @ a)
                     `cast`
                   (<a>_R ->_R Sym (TraversableInstances.N:Identity[0] <a>_R))
                   eta `cast` (TraversableInstances.N:Identity[0] <m a>_R)) -}
729de049f804209d218b6ac6412958e0
  $fTraversableIdentity_$csequenceA ::
    GHC.Base.Applicative f =>
    TraversableInstances.Identity (f a)
    -> f (TraversableInstances.Identity a)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(C(C(S))L)LLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ (f :: * -> *)
                   @ a
                   ($dApplicative :: GHC.Base.Applicative f)
                   (eta :: TraversableInstances.Identity (f a)) ->
                 GHC.Base.fmap
                   @ f
                   (GHC.Base.$p1Applicative @ f $dApplicative)
                   @ a
                   @ (TraversableInstances.Identity a)
                   (TraversableInstances.$fFoldableS1 @ a)
                     `cast`
                   (<a>_R ->_R Sym (TraversableInstances.N:Identity[0] <a>_R))
                   eta `cast` (TraversableInstances.N:Identity[0] <f a>_R)) -}
729de049f804209d218b6ac6412958e0
  $fTraversableIdentity_$ctraverse ::
    GHC.Base.Applicative f =>
    (a -> f b)
    -> TraversableInstances.Identity a
    -> f (TraversableInstances.Identity b)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(S(C(C(S))L)LLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A)><L,1*C1(U)><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ (f :: * -> *)
                   @ a
                   @ b
                   ($dApplicative :: GHC.Base.Applicative f)
                   (eta :: a -> f b)
                   (eta1 :: TraversableInstances.Identity a) ->
                 GHC.Base.fmap
                   @ f
                   (GHC.Base.$p1Applicative @ f $dApplicative)
                   @ b
                   @ (TraversableInstances.Identity b)
                   (TraversableInstances.$fFoldableS1 @ b)
                     `cast`
                   (<b>_R ->_R Sym (TraversableInstances.N:Identity[0] <b>_R))
                   (eta eta1 `cast` (TraversableInstances.N:Identity[0] <a>_R))) -}
b205c9375ec1b24a907de4864e47820f
  $fTraversableList ::
    Data.Traversable.Traversable TraversableInstances.List
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ TraversableInstances.List
                  TraversableInstances.$fFunctorList
                  TraversableInstances.$fFoldableList
                  TraversableInstances.$fTraversableList_$ctraverse
                  TraversableInstances.$fTraversableList_$csequenceA
                  TraversableInstances.$fTraversableList_$cmapM
                  TraversableInstances.$fTraversableList_$csequence -}
b205c9375ec1b24a907de4864e47820f
  $fTraversableList_$cmapM ::
    GHC.Base.Monad m =>
    (a -> m b)
    -> TraversableInstances.List a -> m (TraversableInstances.List b)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(SLLLL),1*U(1*U(U(C(C1(U)),A),C(U),C(C1(U)),A,A),A,A,A,A)><L,C(U)><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ (m :: * -> *)
                   @ a
                   @ b
                   ($dMonad :: GHC.Base.Monad m)
                   (eta :: a -> m b)
                   (eta1 :: TraversableInstances.List a) ->
                 TraversableInstances.$fTraversableList_$ctraverse
                   @ m
                   @ a
                   @ b
                   (GHC.Base.$p1Monad @ m $dMonad)
                   eta
                   eta1) -}
b205c9375ec1b24a907de4864e47820f
  $fTraversableList_$csequence ::
    GHC.Base.Monad m =>
    TraversableInstances.List (m a) -> m (TraversableInstances.List a)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLLLL),1*U(1*U(U(C(C1(U)),A),C(U),C(C1(U)),A,A),A,A,A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ (m :: * -> *)
                   @ a
                   ($dMonad :: GHC.Base.Monad m)
                   (eta :: TraversableInstances.List (m a)) ->
                 TraversableInstances.$fTraversableList_$ctraverse
                   @ m
                   @ (m a)
                   @ a
                   (GHC.Base.$p1Monad @ m $dMonad)
                   (GHC.Base.id @ (m a))
                   eta) -}
b205c9375ec1b24a907de4864e47820f
  $fTraversableList_$csequenceA ::
    GHC.Base.Applicative f =>
    TraversableInstances.List (f a) -> f (TraversableInstances.List a)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),A),C(U),C(C1(U)),A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ (f :: * -> *)
                   @ a
                   ($dApplicative :: GHC.Base.Applicative f)
                   (eta :: TraversableInstances.List (f a)) ->
                 TraversableInstances.$fTraversableList_$ctraverse
                   @ f
                   @ (f a)
                   @ a
                   $dApplicative
                   (GHC.Base.id @ (f a))
                   eta) -}
b205c9375ec1b24a907de4864e47820f
  $fTraversableList_$ctraverse ::
    GHC.Base.Applicative f =>
    (a -> f b)
    -> TraversableInstances.List a -> f (TraversableInstances.List b)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S,U(U(C(C1(U)),A),C(U),C(C1(U)),A,A)><L,C(U)><S,1*U> -}
9b0dc1c42b799f2c204b6c11f0bab139
  $fTraversableOptional ::
    Data.Traversable.Traversable TraversableInstances.Optional
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ TraversableInstances.Optional
                  TraversableInstances.$fFunctorOptional
                  TraversableInstances.$fFoldableOptional
                  TraversableInstances.$fTraversableOptional_$ctraverse
                  TraversableInstances.$fTraversableOptional_$csequenceA
                  TraversableInstances.$fTraversableOptional_$cmapM
                  TraversableInstances.$fTraversableOptional_$csequence -}
9b0dc1c42b799f2c204b6c11f0bab139
  $fTraversableOptional_$cmapM ::
    GHC.Base.Monad m =>
    (a -> m b)
    -> TraversableInstances.Optional a
    -> m (TraversableInstances.Optional b)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(SLLLL),1*U(1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,A,A),A,A,A,A)><L,1*C1(U)><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ (m :: * -> *)
                   @ a
                   @ b
                   ($dMonad :: GHC.Base.Monad m)
                   (eta :: a -> m b)
                   (eta1 :: TraversableInstances.Optional a) ->
                 TraversableInstances.$fTraversableOptional_$ctraverse
                   @ m
                   @ a
                   @ b
                   (GHC.Base.$p1Monad @ m $dMonad)
                   eta
                   eta1) -}
9b0dc1c42b799f2c204b6c11f0bab139
  $fTraversableOptional_$csequence ::
    GHC.Base.Monad m =>
    TraversableInstances.Optional (m a)
    -> m (TraversableInstances.Optional a)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLLLL),1*U(1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,A,A),A,A,A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ (m :: * -> *)
                   @ a
                   ($dMonad :: GHC.Base.Monad m)
                   (eta :: TraversableInstances.Optional (m a)) ->
                 TraversableInstances.$fTraversableOptional_$csequenceA
                   @ m
                   @ a
                   (GHC.Base.$p1Monad @ m $dMonad)
                   eta) -}
9b0dc1c42b799f2c204b6c11f0bab139
  $fTraversableOptional_$csequenceA ::
    GHC.Base.Applicative f =>
    TraversableInstances.Optional (f a)
    -> f (TraversableInstances.Optional a)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,A,A)><S,1*U>,
     Unfolding: (\ @ (f :: * -> *)
                   @ a
                   ($dApplicative :: GHC.Base.Applicative f)
                   (eta :: TraversableInstances.Optional (f a)) ->
                 case eta of wild {
                   TraversableInstances.Nada
                   -> GHC.Base.pure
                        @ f
                        $dApplicative
                        @ (TraversableInstances.Optional a)
                        (TraversableInstances.Nada @ a)
                   TraversableInstances.Yep a1
                   -> GHC.Base.fmap
                        @ f
                        (GHC.Base.$p1Applicative @ f $dApplicative)
                        @ a
                        @ (TraversableInstances.Optional a)
                        (TraversableInstances.Yep @ a)
                        a1 }) -}
9b0dc1c42b799f2c204b6c11f0bab139
  $fTraversableOptional_$ctraverse ::
    GHC.Base.Applicative f =>
    (a -> f b)
    -> TraversableInstances.Optional a
    -> f (TraversableInstances.Optional b)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S,1*U(1*U(1*C1(C1(U)),A),1*C1(U),A,A,A)><L,1*C1(U)><S,1*U>,
     Unfolding: (\ @ (f :: * -> *)
                   @ a
                   @ b
                   ($dApplicative :: GHC.Base.Applicative f)
                   (eta :: a -> f b)
                   (eta1 :: TraversableInstances.Optional a) ->
                 case eta1 of wild {
                   TraversableInstances.Nada
                   -> GHC.Base.pure
                        @ f
                        $dApplicative
                        @ (TraversableInstances.Optional b)
                        (TraversableInstances.Nada @ b)
                   TraversableInstances.Yep a1
                   -> GHC.Base.fmap
                        @ f
                        (GHC.Base.$p1Applicative @ f $dApplicative)
                        @ b
                        @ (TraversableInstances.Optional b)
                        (TraversableInstances.Yep @ b)
                        (eta a1) }) -}
96406d61d01da17b40bba6954858f9d9
  $fTraversablePair ::
    Data.Traversable.Traversable (TraversableInstances.Pair a)
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a.
                  @ (TraversableInstances.Pair a)
                  (TraversableInstances.$fFunctorPair @ a)
                  (TraversableInstances.$fFoldablePair @ a)
                  (TraversableInstances.$fTraversablePair_$ctraverse @ a)
                  (TraversableInstances.$fTraversablePair_$csequenceA @ a)
                  (TraversableInstances.$fTraversablePair_$cmapM @ a)
                  (TraversableInstances.$fTraversablePair_$csequence @ a) -}
96406d61d01da17b40bba6954858f9d9
  $fTraversablePair_$cmapM ::
    GHC.Base.Monad m =>
    (a1 -> m b)
    -> TraversableInstances.Pair a a1
    -> m (TraversableInstances.Pair a b)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(S(S(C(C(S))L)LLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A),A,A,A,A)><L,1*C1(U)><S,1*U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ (m :: * -> *)
                   @ a1
                   @ b
                   (w :: GHC.Base.Monad m)
                   (w1 :: a1 -> m b)
                   (w2 :: TraversableInstances.Pair a a1) ->
                 case w2 of ww { TraversableInstances.Pair ww1 ww2 ->
                 TraversableInstances.$w$cmapM @ a @ m @ a1 @ b w w1 ww1 ww2 }) -}
96406d61d01da17b40bba6954858f9d9
  $fTraversablePair_$csequence ::
    GHC.Base.Monad m =>
    TraversableInstances.Pair a (m a1)
    -> m (TraversableInstances.Pair a a1)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S(C(C(S))L)LLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A),A,A,A,A)><S,1*U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   @ (m :: * -> *)
                   @ a1
                   (w :: GHC.Base.Monad m)
                   (w1 :: TraversableInstances.Pair a (m a1)) ->
                 case w1 of ww { TraversableInstances.Pair ww1 ww2 ->
                 TraversableInstances.$w$csequence @ a @ m @ a1 w ww1 ww2 }) -}
96406d61d01da17b40bba6954858f9d9
  $fTraversablePair_$csequenceA ::
    GHC.Base.Applicative f =>
    TraversableInstances.Pair a (f a1)
    -> f (TraversableInstances.Pair a a1)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(C(C(S))L)LLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A)><S,1*U(U,U)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   @ (f :: * -> *)
                   @ a1
                   ($dApplicative :: GHC.Base.Applicative f)
                   (eta :: TraversableInstances.Pair a (f a1)) ->
                 case eta of wild { TraversableInstances.Pair a2 b ->
                 GHC.Base.fmap
                   @ f
                   (GHC.Base.$p1Applicative @ f $dApplicative)
                   @ a1
                   @ (TraversableInstances.Pair a a1)
                   (TraversableInstances.Pair @ a @ a1 a2)
                   b }) -}
96406d61d01da17b40bba6954858f9d9
  $fTraversablePair_$ctraverse ::
    GHC.Base.Applicative f =>
    (a1 -> f b)
    -> TraversableInstances.Pair a a1
    -> f (TraversableInstances.Pair a b)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(S(C(C(S))L)LLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A)><L,1*C1(U)><S,1*U(U,U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ (f :: * -> *)
                   @ a1
                   @ b
                   ($dApplicative :: GHC.Base.Applicative f)
                   (eta :: a1 -> f b)
                   (eta1 :: TraversableInstances.Pair a a1) ->
                 case eta1 of wild { TraversableInstances.Pair a2 b1 ->
                 GHC.Base.fmap
                   @ f
                   (GHC.Base.$p1Applicative @ f $dApplicative)
                   @ b
                   @ (TraversableInstances.Pair a b)
                   (TraversableInstances.Pair @ a @ b a2)
                   (eta b1) }) -}
830583bcd30f054061d98a8af9ec4905
  $fTraversableS ::
    Data.Traversable.Traversable n =>
    Data.Traversable.Traversable (TraversableInstances.S n)
  DFunId
  {- Arity: 1,
     Strictness: <L,U(1*U(C(C1(U)),A),1*U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A),C(C1(C1(U))),A,A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ (n :: * -> *)
                      ($dTraversable :: Data.Traversable.Traversable n).
                  @ (TraversableInstances.S n)
                  (TraversableInstances.$fTraversableS_$cp1Traversable
                     @ n
                     $dTraversable)
                  (TraversableInstances.$fTraversableS_$cp2Traversable
                     @ n
                     $dTraversable)
                  (TraversableInstances.$fTraversableS_$ctraverse @ n $dTraversable)
                  (TraversableInstances.$fTraversableS_$csequenceA @ n $dTraversable)
                  (TraversableInstances.$fTraversableS_$cmapM @ n $dTraversable)
                  (TraversableInstances.$fTraversableS_$csequence
                     @ n
                     $dTraversable) -}
830583bcd30f054061d98a8af9ec4905
  $fTraversableS_$cmapM ::
    Data.Traversable.Traversable n =>
    forall (m :: * -> *) a b.
    GHC.Base.Monad m =>
    (a -> m b)
    -> TraversableInstances.S n a -> m (TraversableInstances.S n b)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(LLC(C(S))LL)LLLL),1*U(1*U(U(U,U),U,U,U,U),A,A,A,A)><L,U><S,1*U(U,U)>,
     Unfolding: InlineRule (4, True, False)
                (\ @ (n :: * -> *)
                   ($dTraversable :: Data.Traversable.Traversable n)
                   @ (m :: * -> *)
                   @ a
                   @ b
                   ($dMonad :: GHC.Base.Monad m)
                   (eta :: a -> m b)
                   (eta1 :: TraversableInstances.S n a) ->
                 TraversableInstances.$fTraversableS_$ctraverse
                   @ n
                   $dTraversable
                   @ m
                   @ a
                   @ b
                   (GHC.Base.$p1Monad @ m $dMonad)
                   eta
                   eta1) -}
830583bcd30f054061d98a8af9ec4905
  $fTraversableS_$cp1Traversable ::
    Data.Traversable.Traversable n =>
    GHC.Base.Functor (TraversableInstances.S n)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,1*U(1*U(C(C1(U)),A),A,A,A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ (n :: * -> *)
                   ($dTraversable :: Data.Traversable.Traversable n) ->
                 TraversableInstances.$fFunctorS
                   @ n
                   (Data.Traversable.$p1Traversable @ n $dTraversable)) -}
830583bcd30f054061d98a8af9ec4905
  $fTraversableS_$cp2Traversable ::
    Data.Traversable.Traversable n =>
    Data.Foldable.Foldable (TraversableInstances.S n)
  {- Arity: 1,
     Strictness: <L,1*U(A,1*U(A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A),A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ (n :: * -> *)
                   ($dTraversable :: Data.Traversable.Traversable n) ->
                 TraversableInstances.$fFoldableS
                   @ n
                   (Data.Traversable.$p2Traversable @ n $dTraversable)) -}
830583bcd30f054061d98a8af9ec4905
  $fTraversableS_$csequence ::
    Data.Traversable.Traversable n =>
    forall (m :: * -> *) a.
    GHC.Base.Monad m =>
    TraversableInstances.S n (m a) -> m (TraversableInstances.S n a)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(S(LLC(C(S))LL)LLLL),1*U(1*U(U(U,U),U,U,U,U),A,A,A,A)><S,1*U(U,U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ (n :: * -> *)
                   ($dTraversable :: Data.Traversable.Traversable n)
                   @ (m :: * -> *)
                   @ a
                   ($dMonad :: GHC.Base.Monad m)
                   (eta :: TraversableInstances.S n (m a)) ->
                 TraversableInstances.$fTraversableS_$csequenceA
                   @ n
                   $dTraversable
                   @ m
                   @ a
                   (GHC.Base.$p1Monad @ m $dMonad)
                   eta) -}
830583bcd30f054061d98a8af9ec4905
  $fTraversableS_$csequenceA ::
    Data.Traversable.Traversable n =>
    forall (f :: * -> *) a.
    GHC.Base.Applicative f =>
    TraversableInstances.S n (f a) -> f (TraversableInstances.S n a)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(LLC(C(S))LL),U(U(U,U),U,U,U,U)><S,1*U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ (n :: * -> *)
                   (w :: Data.Traversable.Traversable n)
                   @ (f :: * -> *)
                   @ a
                   (w1 :: GHC.Base.Applicative f)
                   (w2 :: TraversableInstances.S n (f a)) ->
                 case w2 of ww { TraversableInstances.S ww1 ww2 ->
                 TraversableInstances.$w$csequenceA1 @ n w @ f @ a w1 ww1 ww2 }) -}
830583bcd30f054061d98a8af9ec4905
  $fTraversableS_$ctraverse ::
    Data.Traversable.Traversable n =>
    forall (f :: * -> *) a b.
    GHC.Base.Applicative f =>
    (a -> f b)
    -> TraversableInstances.S n a -> f (TraversableInstances.S n b)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(LLC(C(S))LL),U(U(U,U),U,U,U,U)><L,U><S,1*U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ @ (n :: * -> *)
                   (w :: Data.Traversable.Traversable n)
                   @ (f :: * -> *)
                   @ a
                   @ b
                   (w1 :: GHC.Base.Applicative f)
                   (w2 :: a -> f b)
                   (w3 :: TraversableInstances.S n a) ->
                 case w3 of ww { TraversableInstances.S ww1 ww2 ->
                 TraversableInstances.$w$ctraverse2
                   @ n
                   w
                   @ f
                   @ a
                   @ b
                   w1
                   w2
                   ww1
                   ww2 }) -}
721a5d38cc38fed0984ecc96f773ca01
  $fTraversableThree ::
    Data.Traversable.Traversable (TraversableInstances.Three a b)
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a @ b.
                  @ (TraversableInstances.Three a b)
                  (TraversableInstances.$fFunctorThree @ a @ b)
                  (TraversableInstances.$fFoldableThree @ a @ b)
                  (TraversableInstances.$fTraversableThree_$ctraverse @ a @ b)
                  (TraversableInstances.$fTraversableThree_$csequenceA @ a @ b)
                  (TraversableInstances.$fTraversableThree_$cmapM @ a @ b)
                  (TraversableInstances.$fTraversableThree_$csequence @ a @ b) -}
721a5d38cc38fed0984ecc96f773ca01
  $fTraversableThree_$cmapM ::
    GHC.Base.Monad m =>
    (a1 -> m b1)
    -> TraversableInstances.Three a b a1
    -> m (TraversableInstances.Three a b b1)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(S(S(C(C(S))L)LLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A),A,A,A,A)><L,1*C1(U)><S,1*U(U,U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ b
                   @ (m :: * -> *)
                   @ a1
                   @ b1
                   (w :: GHC.Base.Monad m)
                   (w1 :: a1 -> m b1)
                   (w2 :: TraversableInstances.Three a b a1) ->
                 case w2 of ww { TraversableInstances.Three ww1 ww2 ww3 ->
                 TraversableInstances.$w$cmapM1
                   @ a
                   @ b
                   @ m
                   @ a1
                   @ b1
                   w
                   w1
                   ww1
                   ww2
                   ww3 }) -}
721a5d38cc38fed0984ecc96f773ca01
  $fTraversableThree_$csequence ::
    GHC.Base.Monad m =>
    TraversableInstances.Three a b (m a1)
    -> m (TraversableInstances.Three a b a1)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S(C(C(S))L)LLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A),A,A,A,A)><S,1*U(U,U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   @ b
                   @ (m :: * -> *)
                   @ a1
                   (w :: GHC.Base.Monad m)
                   (w1 :: TraversableInstances.Three a b (m a1)) ->
                 case w1 of ww { TraversableInstances.Three ww1 ww2 ww3 ->
                 TraversableInstances.$w$csequence1
                   @ a
                   @ b
                   @ m
                   @ a1
                   w
                   ww1
                   ww2
                   ww3 }) -}
721a5d38cc38fed0984ecc96f773ca01
  $fTraversableThree_$csequenceA ::
    GHC.Base.Applicative f =>
    TraversableInstances.Three a b (f a1)
    -> f (TraversableInstances.Three a b a1)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(C(C(S))L)LLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A)><S,1*U(U,U,U)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   @ b
                   @ (f :: * -> *)
                   @ a1
                   ($dApplicative :: GHC.Base.Applicative f)
                   (eta :: TraversableInstances.Three a b (f a1)) ->
                 case eta of wild { TraversableInstances.Three a2 b1 c ->
                 GHC.Base.fmap
                   @ f
                   (GHC.Base.$p1Applicative @ f $dApplicative)
                   @ a1
                   @ (TraversableInstances.Three a b a1)
                   (TraversableInstances.Three @ a @ b @ a1 a2 b1)
                   c }) -}
721a5d38cc38fed0984ecc96f773ca01
  $fTraversableThree_$ctraverse ::
    GHC.Base.Applicative f =>
    (a1 -> f b1)
    -> TraversableInstances.Three a b a1
    -> f (TraversableInstances.Three a b b1)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(S(C(C(S))L)LLLL),1*U(1*U(1*C1(C1(U)),A),A,A,A,A)><L,1*C1(U)><S,1*U(U,U,U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ b
                   @ (f :: * -> *)
                   @ a1
                   @ b1
                   ($dApplicative :: GHC.Base.Applicative f)
                   (eta :: a1 -> f b1)
                   (eta1 :: TraversableInstances.Three a b a1) ->
                 case eta1 of wild { TraversableInstances.Three a2 b2 c ->
                 GHC.Base.fmap
                   @ f
                   (GHC.Base.$p1Applicative @ f $dApplicative)
                   @ b1
                   @ (TraversableInstances.Three a b b1)
                   (TraversableInstances.Three @ a @ b @ b1 a2 b2)
                   (eta c) }) -}
4ba7eb63788e9e9f6786ec57a70a2853
  $fTraversableTree ::
    Data.Traversable.Traversable TraversableInstances.Tree
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ TraversableInstances.Tree
                  TraversableInstances.$fFunctorTree
                  TraversableInstances.$fFoldableTree
                  TraversableInstances.$fTraversableTree_$ctraverse
                  TraversableInstances.$fTraversableTree_$csequenceA
                  TraversableInstances.$fTraversableTree_$cmapM
                  TraversableInstances.$fTraversableTree_$csequence -}
4ba7eb63788e9e9f6786ec57a70a2853
  $fTraversableTree_$cmapM ::
    GHC.Base.Monad m =>
    (a -> m b)
    -> TraversableInstances.Tree a -> m (TraversableInstances.Tree b)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(SLLLL),1*U(1*U(U(C(C1(U)),A),C(U),C(C1(U)),A,A),A,A,A,A)><L,C(U)><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ (m :: * -> *)
                   @ a
                   @ b
                   ($dMonad :: GHC.Base.Monad m)
                   (eta :: a -> m b)
                   (eta1 :: TraversableInstances.Tree a) ->
                 TraversableInstances.$fTraversableTree_$ctraverse
                   @ m
                   @ a
                   @ b
                   (GHC.Base.$p1Monad @ m $dMonad)
                   eta
                   eta1) -}
4ba7eb63788e9e9f6786ec57a70a2853
  $fTraversableTree_$csequence ::
    GHC.Base.Monad m =>
    TraversableInstances.Tree (m a) -> m (TraversableInstances.Tree a)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLLLL),1*U(1*U(U(C(C1(U)),A),C(U),C(C1(U)),A,A),A,A,A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ (m :: * -> *)
                   @ a
                   ($dMonad :: GHC.Base.Monad m)
                   (eta :: TraversableInstances.Tree (m a)) ->
                 TraversableInstances.$fTraversableTree_$ctraverse
                   @ m
                   @ (m a)
                   @ a
                   (GHC.Base.$p1Monad @ m $dMonad)
                   (GHC.Base.id @ (m a))
                   eta) -}
4ba7eb63788e9e9f6786ec57a70a2853
  $fTraversableTree_$csequenceA ::
    GHC.Base.Applicative f =>
    TraversableInstances.Tree (f a) -> f (TraversableInstances.Tree a)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),A),C(U),C(C1(U)),A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ (f :: * -> *)
                   @ a
                   ($dApplicative :: GHC.Base.Applicative f)
                   (eta :: TraversableInstances.Tree (f a)) ->
                 TraversableInstances.$fTraversableTree_$ctraverse
                   @ f
                   @ (f a)
                   @ a
                   $dApplicative
                   (GHC.Base.id @ (f a))
                   eta) -}
4ba7eb63788e9e9f6786ec57a70a2853
  $fTraversableTree_$ctraverse ::
    GHC.Base.Applicative f =>
    (a -> f b)
    -> TraversableInstances.Tree a -> f (TraversableInstances.Tree b)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S,U(U(C(C1(U)),A),C(U),C(C1(U)),A,A)><L,C(U)><S,1*U> -}
7ac34e712f9efca7cef72bfd69cd7a80
  $tc'Big :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13653479451458160179##
                   9196974863349085332##
                   TraversableInstances.$trModule
                   TraversableInstances.$tc'Big1) -}
6164faeb749178821408b194b6f0ac2f
  $tc'Big1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Big"#) -}
552a1ec98a2ae6e2216359d30650b5b1
  $tc'Bigger :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17136866384303529966##
                   15338288799065348020##
                   TraversableInstances.$trModule
                   TraversableInstances.$tc'Bigger1) -}
74e027b00d7f50076b794ff80d44baba
  $tc'Bigger1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Bigger"#) -}
2c70c0b2dc88eea7c642cb5538529661
  $tc'Cons :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6657190457871418926##
                   11190926147187646509##
                   TraversableInstances.$trModule
                   TraversableInstances.$tc'Cons1) -}
d90604c3af0f0d332afabd6493af9fd4
  $tc'Cons1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Cons"#) -}
101dadb8bd6c5ca55371bf000570b197
  $tc'Constant :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3870766759386903357##
                   4307863438633510250##
                   TraversableInstances.$trModule
                   TraversableInstances.$tc'Constant1) -}
3b77cf295576d3fe995bfa53e4cb179a
  $tc'Constant1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Constant"#) -}
04b772bd4f17d7eea264a21b3ad83fcd
  $tc'Empty :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6581671583304280500##
                   10689190221903592653##
                   TraversableInstances.$trModule
                   TraversableInstances.$tc'Empty1) -}
ccc93d849b37eaf0d630546062efab17
  $tc'Empty1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Empty"#) -}
0810aa17623a4695ffa623d86404d8e6
  $tc'Identity :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1733323848537855918##
                   8209435050150624269##
                   TraversableInstances.$trModule
                   TraversableInstances.$tc'Identity1) -}
293c5fb2b0076a08e759bfca4ba9e51a
  $tc'Identity1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Identity"#) -}
a7f9d2e9551bac496da846fa3e5e9764
  $tc'Leaf :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1065157328304134782##
                   14762699412134738787##
                   TraversableInstances.$trModule
                   TraversableInstances.$tc'Leaf1) -}
58c2ec86affb70f80032cea1d8fd2472
  $tc'Leaf1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Leaf"#) -}
3d656ad24150081a4aa2b82eb01f7499
  $tc'Nada :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10070623804354004606##
                   47661613847760000##
                   TraversableInstances.$trModule
                   TraversableInstances.$tc'Nada1) -}
95f648664d7d08f0b05169d4b1b3da61
  $tc'Nada1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Nada"#) -}
e169c38335dd5e627ba790099d6c4993
  $tc'Nil :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14785025699804396455##
                   6979643339830191398##
                   TraversableInstances.$trModule
                   TraversableInstances.$tc'Nil1) -}
0b7372cd68d3dd90543ff34eb4890e2e
  $tc'Nil1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Nil"#) -}
d00e7ec0851146d843a5f81bb2d44bfb
  $tc'Node :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3762898688750083215##
                   9816591895458223805##
                   TraversableInstances.$trModule
                   TraversableInstances.$tc'Node1) -}
629a7579c78ed7f7211e7e8804eb3dae
  $tc'Node1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Node"#) -}
336cd8f94c22b2801305eb51aa986ea4
  $tc'Pair :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15528818288090502273##
                   17175363815179674008##
                   TraversableInstances.$trModule
                   TraversableInstances.$tc'Pair1) -}
f87dfce5e41a5b80714bb15fdc82afbf
  $tc'Pair1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Pair"#) -}
1fa938941a0750a8eb1ee4b319949f67
  $tc'S :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6669789934581736485##
                   11095464182186783903##
                   TraversableInstances.$trModule
                   TraversableInstances.$tc'S1) -}
2a72530f589ce92dbcbf2264c9d676d6
  $tc'S1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'S"#) -}
1602da77b3bd096add097e38ed729617
  $tc'Three :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4327136412956753216##
                   4896161407750031166##
                   TraversableInstances.$trModule
                   TraversableInstances.$tc'Three1) -}
a513ec4f3b86d5e9a998dfbdf1f249be
  $tc'Three1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Three"#) -}
081a8dd4c60e1b0c3c391047ddbeb4d0
  $tc'Yep :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1961234079843877336##
                   6135356532216339637##
                   TraversableInstances.$trModule
                   TraversableInstances.$tc'Yep1) -}
a7e4d67bc95dd006cf056d4e59b5836c
  $tc'Yep1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Yep"#) -}
f1790a6b59962e5ad42c3d964c7155d8
  $tcBig :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3509736154179519877##
                   2322378752814173052##
                   TraversableInstances.$trModule
                   TraversableInstances.$tcBig1) -}
903dfc1a432c8c217e52e77fecab65f2
  $tcBig1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Big"#) -}
1a536943c716bc3587b64e2d3e9caea6
  $tcBigger :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   18044772762423429259##
                   17366280723826968627##
                   TraversableInstances.$trModule
                   TraversableInstances.$tcBigger1) -}
50b9ed4cd76a6d713bfb5596ee14aeca
  $tcBigger1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Bigger"#) -}
9578e347e52cd7b492215cef4a995bce
  $tcConstant :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17085544452967643804##
                   3471390385854730805##
                   TraversableInstances.$trModule
                   TraversableInstances.$tcConstant1) -}
ca145f8242812dbc33619bf6b00336b4
  $tcConstant1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Constant"#) -}
3a2aed05df1ce6577d8c430c538c4925
  $tcIdentity :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10211041151199740340##
                   273268818779226363##
                   TraversableInstances.$trModule
                   TraversableInstances.$tcIdentity1) -}
8780ed0c309cccbb2466acde456d2d9e
  $tcIdentity1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Identity"#) -}
df17666e3c0807b2e043e96ec285c602
  $tcList :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8013985993476177349##
                   15632797065804618606##
                   TraversableInstances.$trModule
                   TraversableInstances.$tcList1) -}
155c3c8ab9bbb38688f5d1a6438fd19a
  $tcList1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "List"#) -}
53f54400dbcae5501f5cf7a1a5b9539c
  $tcOptional :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2382678314504731066##
                   6846547699408450064##
                   TraversableInstances.$trModule
                   TraversableInstances.$tcOptional1) -}
b57d4f3d1780756f091824ca9cfa2418
  $tcOptional1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Optional"#) -}
bb7966d0c27aeb0711470780ba62cf1d
  $tcPair :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11480650787182711000##
                   3863535732256648367##
                   TraversableInstances.$trModule
                   TraversableInstances.$tcPair1) -}
7835bfb4911daf245acae5a3fd7b9a4b
  $tcPair1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Pair"#) -}
e05d3e0733012984e17bb69d4a77e656
  $tcS :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13371924525825345434##
                   6764385124255930185##
                   TraversableInstances.$trModule
                   TraversableInstances.$tcS1) -}
b6b83c1d008020982d385d8b766b40ff
  $tcS1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "S"#) -}
67f83981e3dda14d4630d00956197422
  $tcThree :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12003471993993260472##
                   15876656799487120042##
                   TraversableInstances.$trModule
                   TraversableInstances.$tcThree1) -}
ca730f696e8387fa64220034fd944333
  $tcThree1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Three"#) -}
f5966a71f42299449b823be335263dd9
  $tcTree :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2528017033718538495##
                   11849852968961281177##
                   TraversableInstances.$trModule
                   TraversableInstances.$tcTree1) -}
5b3d79fe6c6ea6242cf87eec435c3bfd
  $tcTree1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Tree"#) -}
32c4d8fdf3935b5474b84cae819128b1
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   TraversableInstances.$trModule2
                   TraversableInstances.$trModule1) -}
3c27fcd17237ea134cd3c2450cb6e153
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "TraversableInstances"#) -}
7b28c1b767b012ebd9bbc026b699cb5e
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "chapter-exercises-0.1.0.0-MyTkAmxHPpEzugi6gUoOh"#) -}
3120363fcdda9982f12cde2d9b57b627
  $w$c/= ::
    (GHC.Classes.Eq b, GHC.Classes.Eq a) =>
    a -> b -> a -> b -> GHC.Types.Bool
  {- Arity: 6, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,U><L,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   @ b
                   (w :: GHC.Classes.Eq b)
                   (w1 :: GHC.Classes.Eq a)
                   (ww :: a)
                   (ww1 :: b)
                   (ww2 :: a)
                   (ww3 :: b) ->
                 case GHC.Classes.== @ a w1 ww ww2 of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True
                   -> case GHC.Classes.== @ b w ww1 ww3 of wild1 {
                        GHC.Types.False -> GHC.Types.True
                        GHC.Types.True -> GHC.Types.False } }) -}
2235dfb0eaa7aafcc28323ab26fdc1a3
  $w$c/=1 ::
    (GHC.Classes.Eq (n a), GHC.Classes.Eq a) =>
    n a -> a -> n a -> a -> GHC.Types.Bool
  {- Arity: 6, HasNoCafRefs,
     Strictness: <S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,U><L,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ (n :: * -> *)
                   @ a
                   (w :: GHC.Classes.Eq (n a))
                   (w1 :: GHC.Classes.Eq a)
                   (ww :: n a)
                   (ww1 :: a)
                   (ww2 :: n a)
                   (ww3 :: a) ->
                 case GHC.Classes.== @ (n a) w ww ww2 of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True
                   -> case GHC.Classes.== @ a w1 ww1 ww3 of wild1 {
                        GHC.Types.False -> GHC.Types.True
                        GHC.Types.True -> GHC.Types.False } }) -}
cf0316971370adef0cfd7e1d25636d3a
  $w$c== ::
    (GHC.Classes.Eq b, GHC.Classes.Eq a) =>
    a -> b -> b -> a -> b -> b -> GHC.Types.Bool
  {- Arity: 8, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,U><L,U><L,U><L,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   @ b
                   (w :: GHC.Classes.Eq b)
                   (w1 :: GHC.Classes.Eq a)
                   (ww :: a)
                   (ww1 :: b)
                   (ww2 :: b)
                   (ww3 :: a)
                   (ww4 :: b)
                   (ww5 :: b) ->
                 case GHC.Classes.== @ a w1 ww ww3 of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> case GHC.Classes.== @ b w ww1 ww4 of wild1 {
                        GHC.Types.False -> GHC.Types.False
                        GHC.Types.True -> GHC.Classes.== @ b w ww2 ww5 } }) -}
13ea960e3a6f801ca8bc96b8873034d0
  $w$c==1 ::
    (GHC.Classes.Eq b, GHC.Classes.Eq a) =>
    a -> b -> b -> b -> a -> b -> b -> b -> GHC.Types.Bool
  {- Arity: 10, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   @ b
                   (w :: GHC.Classes.Eq b)
                   (w1 :: GHC.Classes.Eq a)
                   (ww :: a)
                   (ww1 :: b)
                   (ww2 :: b)
                   (ww3 :: b)
                   (ww4 :: a)
                   (ww5 :: b)
                   (ww6 :: b)
                   (ww7 :: b) ->
                 case GHC.Classes.== @ a w1 ww ww4 of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> case GHC.Classes.== @ b w ww1 ww5 of wild1 {
                        GHC.Types.False -> GHC.Types.False
                        GHC.Types.True
                        -> case GHC.Classes.== @ b w ww2 ww6 of wild2 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True -> GHC.Classes.== @ b w ww3 ww7 } } }) -}
6ebbfeb33050355ed1bc881a3b1d41ad
  $w$c==2 ::
    (GHC.Classes.Eq b, GHC.Classes.Eq a) =>
    a -> b -> a -> b -> GHC.Types.Bool
  {- Arity: 6, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,U><L,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   @ b
                   (w :: GHC.Classes.Eq b)
                   (w1 :: GHC.Classes.Eq a)
                   (ww :: a)
                   (ww1 :: b)
                   (ww2 :: a)
                   (ww3 :: b) ->
                 case GHC.Classes.== @ a w1 ww ww2 of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True -> GHC.Classes.== @ b w ww1 ww3 }) -}
2487796758fedeac5aea284e650b66ca
  $w$c==3 ::
    (GHC.Classes.Eq (n a), GHC.Classes.Eq a) =>
    n a -> a -> n a -> a -> GHC.Types.Bool
  {- Arity: 6, HasNoCafRefs,
     Strictness: <S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,U><L,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ (n :: * -> *)
                   @ a
                   (w :: GHC.Classes.Eq (n a))
                   (w1 :: GHC.Classes.Eq a)
                   (ww :: n a)
                   (ww1 :: a)
                   (ww2 :: n a)
                   (ww3 :: a) ->
                 case GHC.Classes.== @ (n a) w ww ww2 of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True -> GHC.Classes.== @ a w1 ww1 ww3 }) -}
e1883276c517d597d8084d347616ee75
  $w$c==4 ::
    (GHC.Classes.Eq c, GHC.Classes.Eq b, GHC.Classes.Eq a) =>
    a -> b -> c -> a -> b -> c -> GHC.Types.Bool
  {- Arity: 9, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,U><L,U><L,U><L,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   @ b
                   @ c
                   (w :: GHC.Classes.Eq c)
                   (w1 :: GHC.Classes.Eq b)
                   (w2 :: GHC.Classes.Eq a)
                   (ww :: a)
                   (ww1 :: b)
                   (ww2 :: c)
                   (ww3 :: a)
                   (ww4 :: b)
                   (ww5 :: c) ->
                 case GHC.Classes.== @ a w2 ww ww3 of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> case GHC.Classes.== @ b w1 ww1 ww4 of wild1 {
                        GHC.Types.False -> GHC.Types.False
                        GHC.Types.True -> GHC.Classes.== @ c w ww2 ww5 } }) -}
af3c0d28dbd2b10c8ab9cfa0d2594506
  $w$cfoldMap ::
    GHC.Base.Monoid m => (a1 -> m) -> a1 -> a1 -> a1 -> m
  {- Arity: 5, HasNoCafRefs,
     Strictness: <S(LC(C(S))L),U(A,C(C1(U)),A)><L,C(U)><L,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   @ m
                   @ a1
                   (w :: GHC.Base.Monoid m)
                   (w1 :: a1 -> m)
                   (ww :: a1)
                   (ww1 :: a1)
                   (ww2 :: a1) ->
                 GHC.Base.mappend
                   @ m
                   w
                   (w1 ww)
                   (GHC.Base.mappend @ m w (w1 ww1) (w1 ww2))) -}
d0d74ab4d3d7c7b35fc6010e50430e30
  $w$cfoldMap1 ::
    Data.Foldable.Foldable n =>
    forall m a. GHC.Base.Monoid m => (a -> m) -> n a -> a -> m
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LC(C(S))L),U(U,U,U)><L,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ (n :: * -> *)
                   (w :: Data.Foldable.Foldable n)
                   @ m
                   @ a
                   (w1 :: GHC.Base.Monoid m)
                   (w2 :: a -> m)
                   (ww :: n a)
                   (ww1 :: a) ->
                 GHC.Base.mappend
                   @ m
                   w1
                   (Data.Foldable.foldMap @ n w @ m @ a w1 w2 ww)
                   (w2 ww1)) -}
ab00f661bfdef106e46764d296979516
  $w$cfoldl' :: (b -> a1 -> b) -> b -> a1 -> a1 -> a1 -> b
  {- Arity: 5, HasNoCafRefs,
     Strictness: <C(C(S)),C(C1(U))><L,U><L,U><L,U><L,U>, Inline: [0],
     Unfolding: (\ @ a
                   @ b
                   @ a1
                   (w :: b -> a1 -> b)
                   (w1 :: b)
                   (ww :: a1)
                   (ww1 :: a1)
                   (ww2 :: a1) ->
                 case w w1 ww of vx { DEFAULT ->
                 case w vx ww1 of vx1 { DEFAULT -> w vx1 ww2 } }) -}
eae534e2664f9d30fca3781df5802df8
  $w$cfoldl'1 ::
    Data.Foldable.Foldable n =>
    forall b a. (b -> a -> b) -> b -> n a -> a -> b
  {- Arity: 5, HasNoCafRefs,
     Strictness: <S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ (n :: * -> *)
                   (w :: Data.Foldable.Foldable n)
                   @ b
                   @ a
                   (w1 :: b -> a -> b)
                   (w2 :: b)
                   (ww :: n a)
                   (ww1 :: a) ->
                 (Data.Foldable.foldMap
                    @ n
                    w
                    @ (Data.Monoid.Endo (b -> b))
                    @ a
                    (Data.Monoid.$fMonoidEndo @ (b -> b))
                    (\ (x :: a) (k :: b -> b) (z :: b) ->
                     case w1 z x of vx { DEFAULT -> k vx })
                      `cast`
                    (<a>_R ->_R Sym (Data.Monoid.N:Endo[0] <b -> b>_R))
                    ww)
                   `cast`
                 (Data.Monoid.N:Endo[0] <b -> b>_R)
                   (\ (z :: b) -> w1 z ww1)
                   w2) -}
20032f1b269c45111bfcfc88bf729b65
  $w$cfoldl1 :: GHC.Prim.Void# -> a1
  {- Arity: 1, Strictness: <L,U>x, Inline: [0] -}
79a093c948e1db30bfefa9424878c949
  $w$cfoldr' :: (a1 -> b -> b) -> b -> a1 -> a1 -> a1 -> b
  {- Arity: 5, HasNoCafRefs,
     Strictness: <C(C(S)),C(C1(U))><L,U><L,U><L,U><L,U>, Inline: [0],
     Unfolding: (\ @ a
                   @ a1
                   @ b
                   (w :: a1 -> b -> b)
                   (w1 :: b)
                   (ww :: a1)
                   (ww1 :: a1)
                   (ww2 :: a1) ->
                 case w ww2 w1 of vx { DEFAULT ->
                 case w ww1 vx of vx1 { DEFAULT -> w ww vx1 } }) -}
82643122b394c332a3df37b61dd712b7
  $w$cfoldr1 :: GHC.Prim.Void# -> a1
  {- Arity: 1, Strictness: <L,U>x, Inline: [0] -}
903e2c8432b8465745e315a5f85afe9a
  $w$cfoldr2 ::
    Data.Foldable.Foldable n =>
    forall a. (a -> a -> a) -> n a -> a -> a
  {- Arity: 4,
     Strictness: <S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(U))><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ (n :: * -> *)
                   (w :: Data.Foldable.Foldable n)
                   @ a
                   (w1 :: a -> a -> a)
                   (ww :: n a)
                   (ww1 :: a) ->
                 case (Data.Foldable.foldMap
                         @ n
                         w
                         @ (Data.Monoid.Endo (GHC.Base.Maybe a))
                         @ a
                         (Data.Monoid.$fMonoidEndo @ (GHC.Base.Maybe a))
                         (\ (x :: a) (m :: GHC.Base.Maybe a) ->
                          GHC.Base.Just
                            @ a
                            (case m of wild {
                               GHC.Base.Nothing -> x GHC.Base.Just y -> w1 x y }))
                           `cast`
                         (<a>_R ->_R Sym (Data.Monoid.N:Endo[0] <GHC.Base.Maybe a>_R))
                         ww)
                        `cast`
                      (Data.Monoid.N:Endo[0] <GHC.Base.Maybe a>_R)
                        (GHC.Base.Just @ a ww1) of wild {
                   GHC.Base.Nothing -> TraversableInstances.$fFoldableList8 @ a
                   GHC.Base.Just v -> v }) -}
d6bd549cc6368405a31baf97a9324d92
  $w$clength ::
    Data.Foldable.Foldable n => forall a. n a -> a -> GHC.Types.Int
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ (n :: * -> *)
                   (w :: Data.Foldable.Foldable n)
                   @ a
                   (ww :: n a)
                   (ww1 :: a) ->
                 (Data.Foldable.foldMap
                    @ n
                    w
                    @ (Data.Monoid.Endo (GHC.Types.Int -> GHC.Types.Int))
                    @ a
                    (Data.Monoid.$fMonoidEndo @ (GHC.Types.Int -> GHC.Types.Int))
                    (TraversableInstances.$fFoldableList5 @ a)
                      `cast`
                    (<a>_R
                     ->_R Sym (Data.Monoid.N:Endo[0]
                                   <GHC.Types.Int -> GHC.Types.Int>_R))
                    ww)
                   `cast`
                 (Data.Monoid.N:Endo[0] <GHC.Types.Int -> GHC.Types.Int>_R)
                   TraversableInstances.$fFoldableS2
                   TraversableInstances.$fFoldableConstant1) -}
96406d61d01da17b40bba6954858f9d9
  $w$cmapM ::
    GHC.Base.Monad m =>
    (a1 -> m b) -> a -> a1 -> m (TraversableInstances.Pair a b)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S(S(S(C(C(S))L)LLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A),A,A,A,A)><L,1*C1(U)><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   @ (m :: * -> *)
                   @ a1
                   @ b
                   (w :: GHC.Base.Monad m)
                   (w1 :: a1 -> m b)
                   (ww :: a)
                   (ww1 :: a1) ->
                 GHC.Base.fmap
                   @ m
                   (GHC.Base.$p1Applicative @ m (GHC.Base.$p1Monad @ m w))
                   @ b
                   @ (TraversableInstances.Pair a b)
                   (TraversableInstances.Pair @ a @ b ww)
                   (w1 ww1)) -}
721a5d38cc38fed0984ecc96f773ca01
  $w$cmapM1 ::
    GHC.Base.Monad m =>
    (a1 -> m b1)
    -> a -> b -> a1 -> m (TraversableInstances.Three a b b1)
  {- Arity: 5, HasNoCafRefs,
     Strictness: <S(S(S(C(C(S))L)LLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A),A,A,A,A)><L,1*C1(U)><L,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   @ b
                   @ (m :: * -> *)
                   @ a1
                   @ b1
                   (w :: GHC.Base.Monad m)
                   (w1 :: a1 -> m b1)
                   (ww :: a)
                   (ww1 :: b)
                   (ww2 :: a1) ->
                 GHC.Base.fmap
                   @ m
                   (GHC.Base.$p1Applicative @ m (GHC.Base.$p1Monad @ m w))
                   @ b1
                   @ (TraversableInstances.Three a b b1)
                   (TraversableInstances.Three @ a @ b @ b1 ww ww1)
                   (w1 ww2)) -}
b873ae9ea46090dab26596bd3523eefe
  $w$cmaximum :: GHC.Classes.Ord a1 => a1 -> a1 -> a1 -> a1
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S(LLLLLC(C(S))LL),U(A,A,A,A,A,C(C1(U)),A,A)><L,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   @ a1
                   (w :: GHC.Classes.Ord a1)
                   (ww :: a1)
                   (ww1 :: a1)
                   (ww2 :: a1) ->
                 case GHC.Classes.>= @ a1 w ww1 ww2 of wild2 {
                   GHC.Types.False
                   -> case GHC.Classes.>= @ a1 w ww ww2 of wild1 {
                        GHC.Types.False -> ww2 GHC.Types.True -> ww }
                   GHC.Types.True
                   -> case GHC.Classes.>= @ a1 w ww ww1 of wild1 {
                        GHC.Types.False -> ww1 GHC.Types.True -> ww } }) -}
916ad67c1a2292dbae58e5811c367b36
  $w$cmaximum1 :: GHC.Prim.Void# -> a1
  {- Arity: 1, Strictness: <L,U>x, Inline: [0] -}
3e9070f4c506aa5dcfe4abaeb6851373
  $w$cminimum :: GHC.Classes.Ord a1 => a1 -> a1 -> a1 -> a1
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S(LLLC(C(S))LLLL),U(A,A,A,C(C1(U)),A,A,A,A)><L,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   @ a1
                   (w :: GHC.Classes.Ord a1)
                   (ww :: a1)
                   (ww1 :: a1)
                   (ww2 :: a1) ->
                 case GHC.Classes.<= @ a1 w ww1 ww2 of wild2 {
                   GHC.Types.False
                   -> case GHC.Classes.<= @ a1 w ww ww2 of wild1 {
                        GHC.Types.False -> ww2 GHC.Types.True -> ww }
                   GHC.Types.True
                   -> case GHC.Classes.<= @ a1 w ww ww1 of wild1 {
                        GHC.Types.False -> ww1 GHC.Types.True -> ww } }) -}
c38ec2b9bde50ffe9a9aa0870ecc9486
  $w$cminimum1 :: GHC.Prim.Void# -> a1
  {- Arity: 1, Strictness: <L,U>x, Inline: [0] -}
96406d61d01da17b40bba6954858f9d9
  $w$csequence ::
    GHC.Base.Monad m => a -> m a1 -> m (TraversableInstances.Pair a a1)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(S(S(C(C(S))L)LLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A),A,A,A,A)><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   @ (m :: * -> *)
                   @ a1
                   (w :: GHC.Base.Monad m)
                   (ww :: a)
                   (ww1 :: m a1) ->
                 GHC.Base.fmap
                   @ m
                   (GHC.Base.$p1Applicative @ m (GHC.Base.$p1Monad @ m w))
                   @ a1
                   @ (TraversableInstances.Pair a a1)
                   (TraversableInstances.Pair @ a @ a1 ww)
                   ww1) -}
721a5d38cc38fed0984ecc96f773ca01
  $w$csequence1 ::
    GHC.Base.Monad m =>
    a -> b -> m a1 -> m (TraversableInstances.Three a b a1)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S(S(S(C(C(S))L)LLLL)LLLL),1*U(1*U(1*U(1*C1(C1(U)),A),A,A,A,A),A,A,A,A)><L,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   @ b
                   @ (m :: * -> *)
                   @ a1
                   (w :: GHC.Base.Monad m)
                   (ww :: a)
                   (ww1 :: b)
                   (ww2 :: m a1) ->
                 GHC.Base.fmap
                   @ m
                   (GHC.Base.$p1Applicative @ m (GHC.Base.$p1Monad @ m w))
                   @ a1
                   @ (TraversableInstances.Three a b a1)
                   (TraversableInstances.Three @ a @ b @ a1 ww ww1)
                   ww2) -}
cddb4f9513e650624772d2c687832791
  $w$csequenceA ::
    GHC.Base.Applicative f =>
    a -> f a1 -> f a1 -> f (TraversableInstances.Big a a1)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S(LLC(C(S))LL),U(1*U(1*C1(C1(U)),A),A,1*C1(C1(U)),A,A)><L,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   @ (f :: * -> *)
                   @ a1
                   (w :: GHC.Base.Applicative f)
                   (ww :: a)
                   (ww1 :: f a1)
                   (ww2 :: f a1) ->
                 GHC.Base.<*>
                   @ f
                   w
                   @ a1
                   @ (TraversableInstances.Big a a1)
                   (GHC.Base.fmap
                      @ f
                      (GHC.Base.$p1Applicative @ f w)
                      @ a1
                      @ (a1 -> TraversableInstances.Big a a1)
                      (TraversableInstances.Big @ a @ a1 ww)
                      ww1)
                   ww2) -}
830583bcd30f054061d98a8af9ec4905
  $w$csequenceA1 ::
    Data.Traversable.Traversable n =>
    forall (f :: * -> *) a.
    GHC.Base.Applicative f =>
    n (f a) -> f a -> f (TraversableInstances.S n a)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(LLC(C(S))LL),U(U(U,U),U,U,U,U)><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ (n :: * -> *)
                   (w :: Data.Traversable.Traversable n)
                   @ (f :: * -> *)
                   @ a
                   (w1 :: GHC.Base.Applicative f)
                   (ww :: n (f a))
                   (ww1 :: f a) ->
                 GHC.Base.<*>
                   @ f
                   w1
                   @ a
                   @ (TraversableInstances.S n a)
                   (GHC.Base.fmap
                      @ f
                      (GHC.Base.$p1Applicative @ f w1)
                      @ (n a)
                      @ (a -> TraversableInstances.S n a)
                      (TraversableInstances.S @ n @ a)
                      (Data.Traversable.traverse
                         @ n
                         w
                         @ f
                         @ (f a)
                         @ a
                         w1
                         (GHC.Base.id @ (f a))
                         ww))
                   ww1) -}
b4891d836b42f3c93e73949c9febf3ec
  $w$cshowsPrec ::
    (GHC.Show.Show b, GHC.Show.Show a) =>
    GHC.Prim.Int# -> a -> b -> b -> GHC.Show.ShowS
  {- Arity: 6,
     Strictness: <L,U(C(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><S,U><L,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   @ b
                   (w :: GHC.Show.Show b)
                   (w1 :: GHC.Show.Show a)
                   (ww :: GHC.Prim.Int#)
                   (ww1 :: a)
                   (ww2 :: b)
                   (ww3 :: b) ->
                 let {
                   f :: GHC.Base.String -> GHC.Base.String
                   = GHC.Show.showsPrec @ a w1 TraversableInstances.$fShowBig2 ww1
                 } in
                 let {
                   f1 :: GHC.Base.String -> GHC.Base.String
                   = GHC.Show.showsPrec @ b w TraversableInstances.$fShowBig2 ww2
                 } in
                 let {
                   g :: GHC.Base.String -> GHC.Base.String
                   = GHC.Show.showsPrec @ b w TraversableInstances.$fShowBig2 ww3
                 } in
                 let {
                   p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,U> -}
                   = \ (x :: GHC.Base.String) ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       TraversableInstances.$fShowBig1
                       (f (GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.showSpace1
                             (f1 (GHC.Types.: @ GHC.Types.Char GHC.Show.showSpace1 (g x)))))
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11#) of wild {
                   GHC.Types.False -> p
                   GHC.Types.True
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows7
                        (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows4 x)) }) -}
c67e490e9e65e312f74e1ef33a3bea05
  $w$cshowsPrec1 ::
    (GHC.Show.Show b, GHC.Show.Show a) =>
    GHC.Prim.Int# -> a -> b -> b -> b -> GHC.Show.ShowS
  {- Arity: 7,
     Strictness: <L,U(C(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><S,U><L,U><L,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   @ b
                   (w :: GHC.Show.Show b)
                   (w1 :: GHC.Show.Show a)
                   (ww :: GHC.Prim.Int#)
                   (ww1 :: a)
                   (ww2 :: b)
                   (ww3 :: b)
                   (ww4 :: b) ->
                 let {
                   f :: GHC.Base.String -> GHC.Base.String
                   = GHC.Show.showsPrec @ a w1 TraversableInstances.$fShowBig2 ww1
                 } in
                 let {
                   f1 :: GHC.Base.String -> GHC.Base.String
                   = GHC.Show.showsPrec @ b w TraversableInstances.$fShowBig2 ww2
                 } in
                 let {
                   f2 :: GHC.Base.String -> GHC.Base.String
                   = GHC.Show.showsPrec @ b w TraversableInstances.$fShowBig2 ww3
                 } in
                 let {
                   g :: GHC.Base.String -> GHC.Base.String
                   = GHC.Show.showsPrec @ b w TraversableInstances.$fShowBig2 ww4
                 } in
                 let {
                   p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,U> -}
                   = \ (x :: GHC.Base.String) ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       TraversableInstances.$fShowBigger1
                       (f (GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.showSpace1
                             (f1
                                (GHC.Types.:
                                   @ GHC.Types.Char
                                   GHC.Show.showSpace1
                                   (f2 (GHC.Types.: @ GHC.Types.Char GHC.Show.showSpace1 (g x)))))))
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11#) of wild {
                   GHC.Types.False -> p
                   GHC.Types.True
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows7
                        (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows4 x)) }) -}
a06a627f62d93f6fedbee61792bf9f78
  $w$cshowsPrec2 ::
    GHC.Show.Show a =>
    GHC.Prim.Int#
    -> TraversableInstances.Constant a b -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(1*C1(C1(U)),A,A)><S,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   @ b
                   (w :: GHC.Show.Show a)
                   (ww :: GHC.Prim.Int#)
                   (w1 :: TraversableInstances.Constant a b) ->
                 let {
                   f :: GHC.Base.String -> GHC.Base.String
                   = GHC.Show.showsPrec
                       @ a
                       w
                       TraversableInstances.$fFoldableConstant1
                       w1 `cast` (TraversableInstances.N:Constant[0] <a>_R <b>_P)
                 } in
                 let {
                   p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                   = \ (x :: GHC.Base.String) ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       TraversableInstances.$fShowConstant3
                       (GHC.Base.++
                          @ GHC.Types.Char
                          TraversableInstances.$fShowConstant2
                          (f (GHC.Base.++
                                @ GHC.Types.Char
                                TraversableInstances.$fShowConstant1
                                x)))
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11#) of wild {
                   GHC.Types.False -> p
                   GHC.Types.True
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows7
                        (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows4 x)) }) -}
729de049f804209d218b6ac6412958e0
  $w$cshowsPrec3 ::
    GHC.Show.Show a =>
    GHC.Prim.Int# -> TraversableInstances.Identity a -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(1*C1(C1(U)),A,A)><S,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: GHC.Show.Show a)
                   (ww :: GHC.Prim.Int#)
                   (w1 :: TraversableInstances.Identity a) ->
                 let {
                   g :: GHC.Base.String -> GHC.Base.String
                   = GHC.Show.showsPrec
                       @ a
                       w
                       TraversableInstances.$fShowBig2
                       w1 `cast` (TraversableInstances.N:Identity[0] <a>_R)
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11#) of wild {
                   GHC.Types.False
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Base.++
                        @ GHC.Types.Char
                        TraversableInstances.$fShowIdentity1
                        (g x)
                   GHC.Types.True
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows7
                        (GHC.Base.++
                           @ GHC.Types.Char
                           TraversableInstances.$fShowIdentity1
                           (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows4 x))) }) -}
3beac666dcc5a25d43b26426c625b075
  $w$cshowsPrec4 ::
    (GHC.Show.Show b, GHC.Show.Show a) =>
    GHC.Prim.Int# -> a -> b -> GHC.Show.ShowS
  {- Arity: 5,
     Strictness: <L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><S,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   @ b
                   (w :: GHC.Show.Show b)
                   (w1 :: GHC.Show.Show a)
                   (ww :: GHC.Prim.Int#)
                   (ww1 :: a)
                   (ww2 :: b) ->
                 let {
                   f :: GHC.Base.String -> GHC.Base.String
                   = GHC.Show.showsPrec @ a w1 TraversableInstances.$fShowBig2 ww1
                 } in
                 let {
                   g :: GHC.Base.String -> GHC.Base.String
                   = GHC.Show.showsPrec @ b w TraversableInstances.$fShowBig2 ww2
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11#) of wild {
                   GHC.Types.False
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Base.++
                        @ GHC.Types.Char
                        TraversableInstances.$fShowPair1
                        (f (GHC.Types.: @ GHC.Types.Char GHC.Show.showSpace1 (g x)))
                   GHC.Types.True
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows7
                        (GHC.Base.++
                           @ GHC.Types.Char
                           TraversableInstances.$fShowPair1
                           (f (GHC.Types.:
                                 @ GHC.Types.Char
                                 GHC.Show.showSpace1
                                 (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows4 x))))) }) -}
e3dc9a2e982a284620e13daf7e72c9d2
  $w$cshowsPrec5 ::
    (GHC.Show.Show (n a), GHC.Show.Show a) =>
    GHC.Prim.Int# -> n a -> a -> GHC.Show.ShowS
  {- Arity: 5,
     Strictness: <L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><S,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ (n :: * -> *)
                   @ a
                   (w :: GHC.Show.Show (n a))
                   (w1 :: GHC.Show.Show a)
                   (ww :: GHC.Prim.Int#)
                   (ww1 :: n a)
                   (ww2 :: a) ->
                 let {
                   f :: GHC.Base.String -> GHC.Base.String
                   = GHC.Show.showsPrec @ (n a) w TraversableInstances.$fShowBig2 ww1
                 } in
                 let {
                   g :: GHC.Base.String -> GHC.Base.String
                   = GHC.Show.showsPrec @ a w1 TraversableInstances.$fShowBig2 ww2
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11#) of wild {
                   GHC.Types.False
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Base.++
                        @ GHC.Types.Char
                        TraversableInstances.$fShowS1
                        (f (GHC.Types.: @ GHC.Types.Char GHC.Show.showSpace1 (g x)))
                   GHC.Types.True
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows7
                        (GHC.Base.++
                           @ GHC.Types.Char
                           TraversableInstances.$fShowS1
                           (f (GHC.Types.:
                                 @ GHC.Types.Char
                                 GHC.Show.showSpace1
                                 (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows4 x))))) }) -}
ad363e7b05854841f22f54317fdc5af3
  $w$cshowsPrec6 ::
    (GHC.Show.Show c, GHC.Show.Show b, GHC.Show.Show a) =>
    GHC.Prim.Int# -> a -> b -> c -> GHC.Show.ShowS
  {- Arity: 7,
     Strictness: <L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><S,U><L,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   @ b
                   @ c
                   (w :: GHC.Show.Show c)
                   (w1 :: GHC.Show.Show b)
                   (w2 :: GHC.Show.Show a)
                   (ww :: GHC.Prim.Int#)
                   (ww1 :: a)
                   (ww2 :: b)
                   (ww3 :: c) ->
                 let {
                   f :: GHC.Base.String -> GHC.Base.String
                   = GHC.Show.showsPrec @ a w2 TraversableInstances.$fShowBig2 ww1
                 } in
                 let {
                   f1 :: GHC.Base.String -> GHC.Base.String
                   = GHC.Show.showsPrec @ b w1 TraversableInstances.$fShowBig2 ww2
                 } in
                 let {
                   g :: GHC.Base.String -> GHC.Base.String
                   = GHC.Show.showsPrec @ c w TraversableInstances.$fShowBig2 ww3
                 } in
                 let {
                   p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,U> -}
                   = \ (x :: GHC.Base.String) ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       TraversableInstances.$fShowThree1
                       (f (GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.showSpace1
                             (f1 (GHC.Types.: @ GHC.Types.Char GHC.Show.showSpace1 (g x)))))
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11#) of wild {
                   GHC.Types.False -> p
                   GHC.Types.True
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows7
                        (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows4 x)) }) -}
cddb4f9513e650624772d2c687832791
  $w$ctraverse ::
    GHC.Base.Applicative f =>
    (a1 -> f b) -> a -> a1 -> a1 -> f (TraversableInstances.Big a b)
  {- Arity: 5, HasNoCafRefs,
     Strictness: <S(LLC(C(S))LL),U(1*U(1*C1(C1(U)),A),A,1*C1(C1(U)),A,A)><L,C(U)><L,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   @ (f :: * -> *)
                   @ a1
                   @ b
                   (w :: GHC.Base.Applicative f)
                   (w1 :: a1 -> f b)
                   (ww :: a)
                   (ww1 :: a1)
                   (ww2 :: a1) ->
                 GHC.Base.<*>
                   @ f
                   w
                   @ b
                   @ (TraversableInstances.Big a b)
                   (GHC.Base.fmap
                      @ f
                      (GHC.Base.$p1Applicative @ f w)
                      @ b
                      @ (b -> TraversableInstances.Big a b)
                      (TraversableInstances.Big @ a @ b ww)
                      (w1 ww1))
                   (w1 ww2)) -}
8373cb9b5cc904797ff1fb1bafd8cdce
  $w$ctraverse1 ::
    GHC.Base.Applicative f =>
    (a1 -> f b)
    -> a -> a1 -> a1 -> a1 -> f (TraversableInstances.Bigger a b)
  {- Arity: 6, HasNoCafRefs,
     Strictness: <S(LLC(C(S))LL),U(1*U(1*C1(C1(U)),A),A,C(C1(U)),A,A)><L,C(U)><L,U><L,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   @ (f :: * -> *)
                   @ a1
                   @ b
                   (w :: GHC.Base.Applicative f)
                   (w1 :: a1 -> f b)
                   (ww :: a)
                   (ww1 :: a1)
                   (ww2 :: a1)
                   (ww3 :: a1) ->
                 GHC.Base.<*>
                   @ f
                   w
                   @ b
                   @ (TraversableInstances.Bigger a b)
                   (GHC.Base.<*>
                      @ f
                      w
                      @ b
                      @ (b -> TraversableInstances.Bigger a b)
                      (GHC.Base.fmap
                         @ f
                         (GHC.Base.$p1Applicative @ f w)
                         @ b
                         @ (b -> b -> TraversableInstances.Bigger a b)
                         (TraversableInstances.Bigger @ a @ b ww)
                         (w1 ww1))
                      (w1 ww2))
                   (w1 ww3)) -}
830583bcd30f054061d98a8af9ec4905
  $w$ctraverse2 ::
    Data.Traversable.Traversable n =>
    forall (f :: * -> *) a b.
    GHC.Base.Applicative f =>
    (a -> f b) -> n a -> a -> f (TraversableInstances.S n b)
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,1*U(A,A,1*C1(C1(C1(U))),A,A,A)><S(LLC(C(S))LL),U(U(U,U),U,U,U,U)><L,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ (n :: * -> *)
                   (w :: Data.Traversable.Traversable n)
                   @ (f :: * -> *)
                   @ a
                   @ b
                   (w1 :: GHC.Base.Applicative f)
                   (w2 :: a -> f b)
                   (ww :: n a)
                   (ww1 :: a) ->
                 GHC.Base.<*>
                   @ f
                   w1
                   @ b
                   @ (TraversableInstances.S n b)
                   (GHC.Base.fmap
                      @ f
                      (GHC.Base.$p1Applicative @ f w1)
                      @ (n b)
                      @ (b -> TraversableInstances.S n b)
                      (TraversableInstances.S @ n @ b)
                      (Data.Traversable.traverse @ n w @ f @ a @ b w1 w2 ww))
                   (w2 ww1)) -}
cddb4f9513e650624772d2c687832791
  data Big a b = Big a b b
8373cb9b5cc904797ff1fb1bafd8cdce
  data Bigger a b = Bigger a b b b
a06a627f62d93f6fedbee61792bf9f78
  type role Constant representational phantom
  newtype Constant a b = Constant {getConstant :: a}
729de049f804209d218b6ac6412958e0
  newtype Identity a = Identity a
b205c9375ec1b24a907de4864e47820f
  data List a = Nil | Cons a (TraversableInstances.List a)
9b0dc1c42b799f2c204b6c11f0bab139
  data Optional a = Nada | Yep a
96406d61d01da17b40bba6954858f9d9
  data Pair a b = Pair a b
830583bcd30f054061d98a8af9ec4905
  type role S representational nominal
  data S (n :: * -> *) a = S (n a) a
721a5d38cc38fed0984ecc96f773ca01
  data Three a b c = Three a b c
4ba7eb63788e9e9f6786ec57a70a2853
  data Tree a
    = Empty
    | Leaf a
    | Node (TraversableInstances.Tree a)
           a
           (TraversableInstances.Tree a)
bd5e40bc1ca720f432ee3557a123edc2
  getConstant :: TraversableInstances.Constant a b -> a
  RecSel Left TraversableInstances.Constant
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (0, True, True)
                TraversableInstances.getConstant1
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <TraversableInstances.Constant a b>_R
                 ->_R TraversableInstances.N:Constant[0] <a>_R <b>_P) -}
7859b5153e376768bbd7570057e2f08c
  getConstant1 ::
    TraversableInstances.Constant a b
    -> TraversableInstances.Constant a b
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, True)
                (\ @ a @ b (ds :: TraversableInstances.Constant a b) -> ds) -}
instance [safe] GHC.Classes.Eq [TraversableInstances.Big]
  = TraversableInstances.$fEqBig
instance [safe] GHC.Classes.Eq [TraversableInstances.Bigger]
  = TraversableInstances.$fEqBigger
instance [safe] GHC.Classes.Eq [TraversableInstances.Constant]
  = TraversableInstances.$fEqConstant
instance [safe] GHC.Classes.Eq [TraversableInstances.Identity]
  = TraversableInstances.$fEqIdentity
instance [safe] GHC.Classes.Eq [TraversableInstances.List]
  = TraversableInstances.$fEqList
instance [safe] GHC.Classes.Eq [TraversableInstances.Optional]
  = TraversableInstances.$fEqOptional
instance [safe] GHC.Classes.Eq [TraversableInstances.Pair]
  = TraversableInstances.$fEqPair
instance [safe] GHC.Classes.Eq [TraversableInstances.S]
  = TraversableInstances.$fEqS
instance [safe] GHC.Classes.Eq [TraversableInstances.Three]
  = TraversableInstances.$fEqThree
instance [safe] GHC.Classes.Eq [TraversableInstances.Tree]
  = TraversableInstances.$fEqTree
instance [safe] Data.Foldable.Foldable [TraversableInstances.Big]
  = TraversableInstances.$fFoldableBig
instance [safe] Data.Foldable.Foldable [TraversableInstances.Bigger]
  = TraversableInstances.$fFoldableBigger
instance [safe] Data.Foldable.Foldable [TraversableInstances.Constant]
  = TraversableInstances.$fFoldableConstant
instance [safe] Data.Foldable.Foldable [TraversableInstances.Identity]
  = TraversableInstances.$fFoldableIdentity
instance [safe] Data.Foldable.Foldable [TraversableInstances.List]
  = TraversableInstances.$fFoldableList
instance [safe] Data.Foldable.Foldable [TraversableInstances.Optional]
  = TraversableInstances.$fFoldableOptional
instance [safe] Data.Foldable.Foldable [TraversableInstances.Pair]
  = TraversableInstances.$fFoldablePair
instance [safe] Data.Foldable.Foldable [TraversableInstances.S]
  = TraversableInstances.$fFoldableS
instance [safe] Data.Foldable.Foldable [TraversableInstances.Three]
  = TraversableInstances.$fFoldableThree
instance [safe] Data.Foldable.Foldable [TraversableInstances.Tree]
  = TraversableInstances.$fFoldableTree
instance [safe] GHC.Base.Functor [TraversableInstances.Big]
  = TraversableInstances.$fFunctorBig
instance [safe] GHC.Base.Functor [TraversableInstances.Bigger]
  = TraversableInstances.$fFunctorBigger
instance [safe] GHC.Base.Functor [TraversableInstances.Constant]
  = TraversableInstances.$fFunctorConstant
instance [safe] GHC.Base.Functor [TraversableInstances.Identity]
  = TraversableInstances.$fFunctorIdentity
instance [safe] GHC.Base.Functor [TraversableInstances.List]
  = TraversableInstances.$fFunctorList
instance [safe] GHC.Base.Functor [TraversableInstances.Optional]
  = TraversableInstances.$fFunctorOptional
instance [safe] GHC.Base.Functor [TraversableInstances.Pair]
  = TraversableInstances.$fFunctorPair
instance [safe] GHC.Base.Functor [TraversableInstances.S]
  = TraversableInstances.$fFunctorS
instance [safe] GHC.Base.Functor [TraversableInstances.Three]
  = TraversableInstances.$fFunctorThree
instance [safe] GHC.Base.Functor [TraversableInstances.Tree]
  = TraversableInstances.$fFunctorTree
instance [safe] GHC.Classes.Ord [TraversableInstances.Identity]
  = TraversableInstances.$fOrdIdentity
instance [safe] GHC.Show.Show [TraversableInstances.Big]
  = TraversableInstances.$fShowBig
instance [safe] GHC.Show.Show [TraversableInstances.Bigger]
  = TraversableInstances.$fShowBigger
instance [safe] GHC.Show.Show [TraversableInstances.Constant]
  = TraversableInstances.$fShowConstant
instance [safe] GHC.Show.Show [TraversableInstances.Identity]
  = TraversableInstances.$fShowIdentity
instance [safe] GHC.Show.Show [TraversableInstances.List]
  = TraversableInstances.$fShowList
instance [safe] GHC.Show.Show [TraversableInstances.Optional]
  = TraversableInstances.$fShowOptional
instance [safe] GHC.Show.Show [TraversableInstances.Pair]
  = TraversableInstances.$fShowPair
instance [safe] GHC.Show.Show [TraversableInstances.S]
  = TraversableInstances.$fShowS
instance [safe] GHC.Show.Show [TraversableInstances.Three]
  = TraversableInstances.$fShowThree
instance [safe] GHC.Show.Show [TraversableInstances.Tree]
  = TraversableInstances.$fShowTree
instance [safe] Data.Traversable.Traversable [TraversableInstances.Big]
  = TraversableInstances.$fTraversableBig
instance [safe] Data.Traversable.Traversable [TraversableInstances.Bigger]
  = TraversableInstances.$fTraversableBigger
instance [safe] Data.Traversable.Traversable [TraversableInstances.Constant]
  = TraversableInstances.$fTraversableConstant
instance [safe] Data.Traversable.Traversable [TraversableInstances.Identity]
  = TraversableInstances.$fTraversableIdentity
instance [safe] Data.Traversable.Traversable [TraversableInstances.List]
  = TraversableInstances.$fTraversableList
instance [safe] Data.Traversable.Traversable [TraversableInstances.Optional]
  = TraversableInstances.$fTraversableOptional
instance [safe] Data.Traversable.Traversable [TraversableInstances.Pair]
  = TraversableInstances.$fTraversablePair
instance [safe] Data.Traversable.Traversable [TraversableInstances.S]
  = TraversableInstances.$fTraversableS
instance [safe] Data.Traversable.Traversable [TraversableInstances.Three]
  = TraversableInstances.$fTraversableThree
instance [safe] Data.Traversable.Traversable [TraversableInstances.Tree]
  = TraversableInstances.$fTraversableTree
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

